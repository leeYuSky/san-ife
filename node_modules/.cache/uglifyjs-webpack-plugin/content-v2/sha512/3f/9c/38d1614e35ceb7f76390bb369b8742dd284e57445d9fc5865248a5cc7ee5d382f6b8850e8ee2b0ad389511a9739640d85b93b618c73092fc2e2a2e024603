{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"configurable\",\"enumerable\",\"get\",\"r\",\"value\",\"n\",\"__esModule\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\"],\"mappings\":\"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,GAAAA,EAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,EAAAA,EAAA4B,EAAA\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 15);\\n\"]}","code":"!function(g){var I={};function n(C){if(I[C])return I[C].exports;var e=I[C]={i:C,l:!1,exports:{}};return g[C].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=g,n.c=I,n.d=function(g,I,C){n.o(g,I)||Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:C})},n.r=function(g){Object.defineProperty(g,\"__esModule\",{value:!0})},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,\"a\",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p=\"\",n(n.s=15)}([function(module,exports,__webpack_require__){eval('/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n\\nvar stylesInDom = {};\\n\\nvar\\tmemoize = function (fn) {\\n\\tvar memo;\\n\\n\\treturn function () {\\n\\t\\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\\n\\t\\treturn memo;\\n\\t};\\n};\\n\\nvar isOldIE = memoize(function () {\\n\\t// Test for IE <= 9 as proposed by Browserhacks\\n\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\n\\t// Tests for existence of standard globals is to allow style-loader\\n\\t// to operate correctly into non-standard environments\\n\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\n\\treturn window && document && document.all && !window.atob;\\n});\\n\\nvar getTarget = function (target) {\\n  return document.querySelector(target);\\n};\\n\\nvar getElement = (function (fn) {\\n\\tvar memo = {};\\n\\n\\treturn function(target) {\\n                // If passing function in options, then use it for resolve \"head\" element.\\n                // Useful for Shadow Root style i.e\\n                // {\\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\\n                // }\\n                if (typeof target === \\'function\\') {\\n                        return target();\\n                }\\n                if (typeof memo[target] === \"undefined\") {\\n\\t\\t\\tvar styleTarget = getTarget.call(this, target);\\n\\t\\t\\t// Special case to return head of iframe instead of iframe itself\\n\\t\\t\\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t// This will throw an exception if access to iframe is blocked\\n\\t\\t\\t\\t\\t// due to cross-origin restrictions\\n\\t\\t\\t\\t\\tstyleTarget = styleTarget.contentDocument.head;\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t\\tstyleTarget = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemo[target] = styleTarget;\\n\\t\\t}\\n\\t\\treturn memo[target]\\n\\t};\\n})();\\n\\nvar singleton = null;\\nvar\\tsingletonCounter = 0;\\nvar\\tstylesInsertedAtTop = [];\\n\\nvar\\tfixUrls = __webpack_require__(9);\\n\\nmodule.exports = function(list, options) {\\n\\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\\n\\t\\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\\n\\t}\\n\\n\\toptions = options || {};\\n\\n\\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\\n\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\n\\t// tags it will allow on a page\\n\\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\\n\\n\\t// By default, add <style> tags to the <head> element\\n        if (!options.insertInto) options.insertInto = \"head\";\\n\\n\\t// By default, add <style> tags to the bottom of the target\\n\\tif (!options.insertAt) options.insertAt = \"bottom\";\\n\\n\\tvar styles = listToStyles(list, options);\\n\\n\\taddStylesToDom(styles, options);\\n\\n\\treturn function update (newList) {\\n\\t\\tvar mayRemove = [];\\n\\n\\t\\tfor (var i = 0; i < styles.length; i++) {\\n\\t\\t\\tvar item = styles[i];\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\n\\n\\t\\t\\tdomStyle.refs--;\\n\\t\\t\\tmayRemove.push(domStyle);\\n\\t\\t}\\n\\n\\t\\tif(newList) {\\n\\t\\t\\tvar newStyles = listToStyles(newList, options);\\n\\t\\t\\taddStylesToDom(newStyles, options);\\n\\t\\t}\\n\\n\\t\\tfor (var i = 0; i < mayRemove.length; i++) {\\n\\t\\t\\tvar domStyle = mayRemove[i];\\n\\n\\t\\t\\tif(domStyle.refs === 0) {\\n\\t\\t\\t\\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\\n\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\nfunction addStylesToDom (styles, options) {\\n\\tfor (var i = 0; i < styles.length; i++) {\\n\\t\\tvar item = styles[i];\\n\\t\\tvar domStyle = stylesInDom[item.id];\\n\\n\\t\\tif(domStyle) {\\n\\t\\t\\tdomStyle.refs++;\\n\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvar parts = [];\\n\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction listToStyles (list, options) {\\n\\tvar styles = [];\\n\\tvar newStyles = {};\\n\\n\\tfor (var i = 0; i < list.length; i++) {\\n\\t\\tvar item = list[i];\\n\\t\\tvar id = options.base ? item[0] + options.base : item[0];\\n\\t\\tvar css = item[1];\\n\\t\\tvar media = item[2];\\n\\t\\tvar sourceMap = item[3];\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\n\\n\\t\\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\\n\\t\\telse newStyles[id].parts.push(part);\\n\\t}\\n\\n\\treturn styles;\\n}\\n\\nfunction insertStyleElement (options, style) {\\n\\tvar target = getElement(options.insertInto)\\n\\n\\tif (!target) {\\n\\t\\tthrow new Error(\"Couldn\\'t find a style target. This probably means that the value for the \\'insertInto\\' parameter is invalid.\");\\n\\t}\\n\\n\\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\\n\\n\\tif (options.insertAt === \"top\") {\\n\\t\\tif (!lastStyleElementInsertedAtTop) {\\n\\t\\t\\ttarget.insertBefore(style, target.firstChild);\\n\\t\\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\\n\\t\\t\\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\\n\\t\\t} else {\\n\\t\\t\\ttarget.appendChild(style);\\n\\t\\t}\\n\\t\\tstylesInsertedAtTop.push(style);\\n\\t} else if (options.insertAt === \"bottom\") {\\n\\t\\ttarget.appendChild(style);\\n\\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\\n\\t\\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\\n\\t\\ttarget.insertBefore(style, nextSibling);\\n\\t} else {\\n\\t\\tthrow new Error(\"[Style Loader]\\\\n\\\\n Invalid value for parameter \\'insertAt\\' (\\'options.insertAt\\') found.\\\\n Must be \\'top\\', \\'bottom\\', or Object.\\\\n (https://github.com/webpack-contrib/style-loader#insertat)\\\\n\");\\n\\t}\\n}\\n\\nfunction removeStyleElement (style) {\\n\\tif (style.parentNode === null) return false;\\n\\tstyle.parentNode.removeChild(style);\\n\\n\\tvar idx = stylesInsertedAtTop.indexOf(style);\\n\\tif(idx >= 0) {\\n\\t\\tstylesInsertedAtTop.splice(idx, 1);\\n\\t}\\n}\\n\\nfunction createStyleElement (options) {\\n\\tvar style = document.createElement(\"style\");\\n\\n\\tif(options.attrs.type === undefined) {\\n\\t\\toptions.attrs.type = \"text/css\";\\n\\t}\\n\\n\\taddAttrs(style, options.attrs);\\n\\tinsertStyleElement(options, style);\\n\\n\\treturn style;\\n}\\n\\nfunction createLinkElement (options) {\\n\\tvar link = document.createElement(\"link\");\\n\\n\\tif(options.attrs.type === undefined) {\\n\\t\\toptions.attrs.type = \"text/css\";\\n\\t}\\n\\toptions.attrs.rel = \"stylesheet\";\\n\\n\\taddAttrs(link, options.attrs);\\n\\tinsertStyleElement(options, link);\\n\\n\\treturn link;\\n}\\n\\nfunction addAttrs (el, attrs) {\\n\\tObject.keys(attrs).forEach(function (key) {\\n\\t\\tel.setAttribute(key, attrs[key]);\\n\\t});\\n}\\n\\nfunction addStyle (obj, options) {\\n\\tvar style, update, remove, result;\\n\\n\\t// If a transform function was defined, run it on the css\\n\\tif (options.transform && obj.css) {\\n\\t    result = options.transform(obj.css);\\n\\n\\t    if (result) {\\n\\t    \\t// If transform returns a value, use that instead of the original css.\\n\\t    \\t// This allows running runtime transformations on the css.\\n\\t    \\tobj.css = result;\\n\\t    } else {\\n\\t    \\t// If the transform function returns a falsy value, don\\'t add this css.\\n\\t    \\t// This allows conditional loading of css\\n\\t    \\treturn function() {\\n\\t    \\t\\t// noop\\n\\t    \\t};\\n\\t    }\\n\\t}\\n\\n\\tif (options.singleton) {\\n\\t\\tvar styleIndex = singletonCounter++;\\n\\n\\t\\tstyle = singleton || (singleton = createStyleElement(options));\\n\\n\\t\\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\\n\\t\\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\\n\\n\\t} else if (\\n\\t\\tobj.sourceMap &&\\n\\t\\ttypeof URL === \"function\" &&\\n\\t\\ttypeof URL.createObjectURL === \"function\" &&\\n\\t\\ttypeof URL.revokeObjectURL === \"function\" &&\\n\\t\\ttypeof Blob === \"function\" &&\\n\\t\\ttypeof btoa === \"function\"\\n\\t) {\\n\\t\\tstyle = createLinkElement(options);\\n\\t\\tupdate = updateLink.bind(null, style, options);\\n\\t\\tremove = function () {\\n\\t\\t\\tremoveStyleElement(style);\\n\\n\\t\\t\\tif(style.href) URL.revokeObjectURL(style.href);\\n\\t\\t};\\n\\t} else {\\n\\t\\tstyle = createStyleElement(options);\\n\\t\\tupdate = applyToTag.bind(null, style);\\n\\t\\tremove = function () {\\n\\t\\t\\tremoveStyleElement(style);\\n\\t\\t};\\n\\t}\\n\\n\\tupdate(obj);\\n\\n\\treturn function updateStyle (newObj) {\\n\\t\\tif (newObj) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tnewObj.css === obj.css &&\\n\\t\\t\\t\\tnewObj.media === obj.media &&\\n\\t\\t\\t\\tnewObj.sourceMap === obj.sourceMap\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tupdate(obj = newObj);\\n\\t\\t} else {\\n\\t\\t\\tremove();\\n\\t\\t}\\n\\t};\\n}\\n\\nvar replaceText = (function () {\\n\\tvar textStore = [];\\n\\n\\treturn function (index, replacement) {\\n\\t\\ttextStore[index] = replacement;\\n\\n\\t\\treturn textStore.filter(Boolean).join(\\'\\\\n\\');\\n\\t};\\n})();\\n\\nfunction applyToSingletonTag (style, index, remove, obj) {\\n\\tvar css = remove ? \"\" : obj.css;\\n\\n\\tif (style.styleSheet) {\\n\\t\\tstyle.styleSheet.cssText = replaceText(index, css);\\n\\t} else {\\n\\t\\tvar cssNode = document.createTextNode(css);\\n\\t\\tvar childNodes = style.childNodes;\\n\\n\\t\\tif (childNodes[index]) style.removeChild(childNodes[index]);\\n\\n\\t\\tif (childNodes.length) {\\n\\t\\t\\tstyle.insertBefore(cssNode, childNodes[index]);\\n\\t\\t} else {\\n\\t\\t\\tstyle.appendChild(cssNode);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction applyToTag (style, obj) {\\n\\tvar css = obj.css;\\n\\tvar media = obj.media;\\n\\n\\tif(media) {\\n\\t\\tstyle.setAttribute(\"media\", media)\\n\\t}\\n\\n\\tif(style.styleSheet) {\\n\\t\\tstyle.styleSheet.cssText = css;\\n\\t} else {\\n\\t\\twhile(style.firstChild) {\\n\\t\\t\\tstyle.removeChild(style.firstChild);\\n\\t\\t}\\n\\n\\t\\tstyle.appendChild(document.createTextNode(css));\\n\\t}\\n}\\n\\nfunction updateLink (link, options, obj) {\\n\\tvar css = obj.css;\\n\\tvar sourceMap = obj.sourceMap;\\n\\n\\t/*\\n\\t\\tIf convertToAbsoluteUrls isn\\'t defined, but sourcemaps are enabled\\n\\t\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\n\\t\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\n\\t\\tdirectly\\n\\t*/\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\n\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls) {\\n\\t\\tcss = fixUrls(css);\\n\\t}\\n\\n\\tif (sourceMap) {\\n\\t\\t// http://stackoverflow.com/a/26603875\\n\\t\\tcss += \"\\\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\\n\\t}\\n\\n\\tvar blob = new Blob([css], { type: \"text/css\" });\\n\\n\\tvar oldSrc = link.href;\\n\\n\\tlink.href = URL.createObjectURL(blob);\\n\\n\\tif(oldSrc) URL.revokeObjectURL(oldSrc);\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///0\\n')},function(module,exports){eval('/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n// css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t// return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\"\");\\n\\t};\\n\\n\\t// import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \"string\")\\n\\t\\t\\tmodules = [[null, modules, \"\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \"number\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t// skip already imported module\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || \\'\\';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap && typeof btoa === \\'function\\') {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn \\'/*# sourceURL=\\' + cssMapping.sourceRoot + source + \\' */\\'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\\'\\\\n\\');\\n\\t}\\n\\n\\treturn [content].join(\\'\\\\n\\');\\n}\\n\\n// Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n\\t// eslint-disable-next-line no-undef\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\n\\tvar data = \\'sourceMappingURL=data:application/json;charset=utf-8;base64,\\' + base64;\\n\\n\\treturn \\'/*# \\' + data + \\' */\\';\\n}\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1\\n')},function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = (function() {\\n\\treturn this;\\n})();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///2\\n')},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(setImmediate) {/**\\n * San\\n * Copyright 2016 Baidu Inc. All rights reserved.\\n *\\n * @file 主文件\\n * @author errorrik(errorrik@gmail.com)\\n *         otakustay(otakustay@gmail.com)\\n *         junmer(junmer@foxmail.com)\\n */\\n\\n(function (root) {\\n    // 人工调整打包代码顺序，通过注释手工写一些依赖\\n//     // require('./util/guid');\\n//     // require('./util/empty');\\n//     // require('./util/extend');\\n//     // require('./util/inherits');\\n//     // require('./util/each');\\n//     // require('./util/contains');\\n//     // require('./util/bind');\\n//     // require('./browser/on');\\n//     // require('./browser/un');\\n//     // require('./browser/svg-tags');\\n//     // require('./browser/create-el');\\n//     // require('./browser/remove-el');\\n//     // require('./util/next-tick');\\n//     // require('./browser/ie');\\n//     // require('./browser/ie-old-than-9');\\n//     // require('./browser/input-event-compatible');\\n//     // require('./browser/auto-close-tags');\\n//     // require('./util/data-types.js');\\n//     // require('./util/create-data-types-checker.js');\\n//     // require('./parser/walker');\\n//     // require('./parser/create-a-node');\\n//     // require('./parser/parse-template');\\n//     // require('./runtime/change-expr-compare');\\n//     // require('./runtime/data-change-type');\\n//     // require('./runtime/default-filters');\\n//     // require('./view/life-cycle');\\n//     // require('./view/node-type');\\n//     // require('./view/get-prop-handler');\\n//     // require('./view/is-data-change-by-element');\\n//     // require('./view/event-declaration-listener');\\n//     // require('./view/create-node');\\n\\n\\n    /**\\n * @file 生成唯一id\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 唯一id的起始值\\n *\\n * @inner\\n * @type {number}\\n */\\nvar guidIndex = 1;\\n\\n/**\\n * 唯一id的前缀\\n *\\n * @inner\\n * @type {string}\\n */\\nvar guidPrefix = (new Date()).getTime().toString(16).slice(8);\\n\\n/**\\n * 获取唯一id\\n *\\n * @inner\\n * @return {string} 唯一id\\n */\\nfunction guid() {\\n    return '_' + guidPrefix + (guidIndex++);\\n}\\n\\n// exports = module.exports = guid;\\n\\n\\n/**\\n * @file 空函数\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 啥都不干\\n */\\nfunction empty() {}\\n\\n// exports = module.exports = empty;\\n\\n\\n/**\\n * @file 属性拷贝\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 对象属性拷贝\\n *\\n * @param {Object} target 目标对象\\n * @param {Object} source 源对象\\n * @return {Object} 返回目标对象\\n */\\nfunction extend(target, source) {\\n    for (var key in source) {\\n        if (source.hasOwnProperty(key)) {\\n            var value = source[key];\\n            if (typeof value !== 'undefined') {\\n                target[key] = value;\\n            }\\n        }\\n    }\\n\\n    return target;\\n}\\n\\n// exports = module.exports = extend;\\n\\n\\n/**\\n * @file 构建类之间的继承关系\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var extend = require('./extend');\\n\\n/**\\n * 构建类之间的继承关系\\n *\\n * @param {Function} subClass 子类函数\\n * @param {Function} superClass 父类函数\\n */\\nfunction inherits(subClass, superClass) {\\n    /* jshint -W054 */\\n    var subClassProto = subClass.prototype;\\n    var F = new Function();\\n    F.prototype = superClass.prototype;\\n    subClass.prototype = new F();\\n    subClass.prototype.constructor = subClass;\\n    extend(subClass.prototype, subClassProto);\\n    /* jshint +W054 */\\n}\\n\\n// exports = module.exports = inherits;\\n\\n\\n/**\\n * @file 遍历数组\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 遍历数组集合\\n *\\n * @param {Array} array 数组源\\n * @param {function(Any,number):boolean} iterator 遍历函数\\n */\\nfunction each(array, iterator) {\\n    if (array && array.length > 0) {\\n        for (var i = 0, l = array.length; i < l; i++) {\\n            if (iterator(array[i], i) === false) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n// exports = module.exports = each;\\n\\n\\n/**\\n * @file 判断数组中是否包含某项\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('./each');\\n\\n/**\\n * 判断数组中是否包含某项\\n *\\n * @param {Array} array 数组\\n * @param {*} value 包含的项\\n * @return {boolean}\\n */\\nfunction contains(array, value) {\\n    var result = false;\\n    each(array, function (item) {\\n        result = item === value;\\n        return !result;\\n    });\\n\\n    return result;\\n}\\n\\n// exports = module.exports = contains;\\n\\n\\n/**\\n * @file bind函数\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * Function.prototype.bind 方法的兼容性封装\\n *\\n * @param {Function} func 要bind的函数\\n * @param {Object} thisArg this指向对象\\n * @param {...*} args 预设的初始参数\\n * @return {Function}\\n */\\nfunction bind(func, thisArg) {\\n    var nativeBind = Function.prototype.bind;\\n    var slice = Array.prototype.slice;\\n    // #[begin] allua\\n    if (nativeBind && func.bind === nativeBind) {\\n    // #[end]\\n        return nativeBind.apply(func, slice.call(arguments, 1));\\n    // #[begin] allua\\n    }\\n\\n    var args = slice.call(arguments, 2);\\n    return function () {\\n        return func.apply(thisArg, args.concat(slice.call(arguments)));\\n    };\\n    // #[end]\\n}\\n\\n// exports = module.exports = bind;\\n\\n\\n/**\\n * @file DOM 事件挂载\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * DOM 事件挂载\\n *\\n * @inner\\n * @param {HTMLElement} el DOM元素\\n * @param {string} eventName 事件名\\n * @param {Function} listener 监听函数\\n * @param {boolean} capture 是否是捕获阶段\\n */\\nfunction on(el, eventName, listener, capture) {\\n    // #[begin] allua\\n    if (el.addEventListener) {\\n    // #[end]\\n        el.addEventListener(eventName, listener, capture);\\n    // #[begin] allua\\n    }\\n    else {\\n        el.attachEvent('on' + eventName, listener);\\n    }\\n    // #[end]\\n}\\n\\n// exports = module.exports = on;\\n\\n\\n/**\\n * @file DOM 事件卸载\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * DOM 事件卸载\\n *\\n * @inner\\n * @param {HTMLElement} el DOM元素\\n * @param {string} eventName 事件名\\n * @param {Function} listener 监听函数\\n * @param {boolean} capture 是否是捕获阶段\\n */\\nfunction un(el, eventName, listener, capture) {\\n    // #[begin] allua\\n    if (el.addEventListener) {\\n    // #[end]\\n        el.removeEventListener(eventName, listener, capture);\\n    // #[begin] allua\\n    }\\n    else {\\n        el.detachEvent('on' + eventName, listener);\\n    }\\n    // #[end]\\n}\\n\\n// exports = module.exports = un;\\n\\n\\n/**\\n * @file 将字符串逗号切分返回对象\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n\\n/**\\n * 将字符串逗号切分返回对象\\n *\\n * @param {string} source 源字符串\\n * @return {Object}\\n */\\nfunction splitStr2Obj(source) {\\n    var result = {};\\n    each(\\n        source.split(','),\\n        function (key) {\\n            result[key] = 1;\\n        }\\n    );\\n    return result;\\n}\\n\\n// exports = module.exports = splitStr2Obj;\\n\\n\\n/**\\n * @file SVG标签表\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var splitStr2Obj = require('../util/split-str-2-obj');\\n\\n/**\\n * svgTags\\n *\\n * @see https://www.w3.org/TR/SVG/svgdtd.html 只取常用\\n * @type {Object}\\n */\\nvar svgTags = splitStr2Obj(''\\n    // structure\\n    + 'svg,g,defs,desc,metadata,symbol,use,'\\n    // image & shape\\n    + 'image,path,rect,circle,line,ellipse,polyline,polygon,'\\n    // text\\n    + 'text,tspan,tref,textpath,'\\n    // other\\n    + 'marker,pattern,clippath,mask,filter,cursor,view,animate,'\\n    // font\\n    + 'font,font-face,glyph,missing-glyph');\\n\\n// exports = module.exports = svgTags;\\n\\n\\n/**\\n * @file DOM创建\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var svgTags = require('./svg-tags');\\n\\n/**\\n * 创建 DOM 元素\\n *\\n * @param  {string} tagName tagName\\n * @return {HTMLElement}\\n */\\nfunction createEl(tagName) {\\n    if (svgTags[tagName]) {\\n        return document.createElementNS('http://www.w3.org/2000/svg', tagName);\\n    }\\n\\n    return document.createElement(tagName);\\n}\\n\\n// exports = module.exports = createEl;\\n\\n\\n/**\\n * @file 移除DOM\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 将 DOM 从页面中移除\\n *\\n * @param {HTMLElement} el DOM元素\\n */\\nfunction removeEl(el) {\\n    if (el && el.parentNode) {\\n        el.parentNode.removeChild(el);\\n    }\\n}\\n\\n// exports = module.exports = removeEl;\\n\\n\\n/**\\n * @file 在下一个时间周期运行任务\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// 该方法参照了vue2.5.0的实现，感谢vue团队\\n// SEE: https://github.com/vuejs/vue/blob/0948d999f2fddf9f90991956493f976273c5da1f/src/core/util/env.js#L68\\n\\n\\n// var bind = require('./bind');\\n\\n/**\\n * 下一个周期要执行的任务列表\\n *\\n * @inner\\n * @type {Array}\\n */\\nvar nextTasks = [];\\n\\n/**\\n * 执行下一个周期任务的函数\\n *\\n * @inner\\n * @type {Function}\\n */\\nvar nextHandler;\\n\\n/**\\n * 浏览器是否支持原生Promise\\n * 对Promise做判断，是为了禁用一些不严谨的Promise的polyfill\\n *\\n * @inner\\n * @type {boolean}\\n */\\nvar isNativePromise = typeof Promise === 'function' && /native code/.test(Promise);\\n\\n/**\\n * 在下一个时间周期运行任务\\n *\\n * @inner\\n * @param {Function} fn 要运行的任务函数\\n * @param {Object=} thisArg this指向对象\\n */\\nfunction nextTick(fn, thisArg) {\\n    if (thisArg) {\\n        fn = bind(fn, thisArg);\\n    }\\n    nextTasks.push(fn);\\n\\n    if (nextHandler) {\\n        return;\\n    }\\n\\n    nextHandler = function () {\\n        var tasks = nextTasks.slice(0);\\n        nextTasks = [];\\n        nextHandler = null;\\n\\n        for (var i = 0, l = tasks.length; i < l; i++) {\\n            tasks[i]();\\n        }\\n    };\\n\\n    // 非标准方法，但是此方法非常吻合要求。\\n    if (typeof setImmediate === 'function') {\\n        setImmediate(nextHandler);\\n    }\\n    // 用MessageChannel去做setImmediate的polyfill\\n    // 原理是将新的message事件加入到原有的dom events之后\\n    else if (typeof MessageChannel === 'function') {\\n        var channel = new MessageChannel();\\n        var port = channel.port2;\\n        channel.port1.onmessage = nextHandler;\\n        port.postMessage(1);\\n    }\\n    // for native app\\n    else if (isNativePromise) {\\n        Promise.resolve().then(nextHandler);\\n    }\\n    else {\\n        setTimeout(nextHandler, 0);\\n    }\\n}\\n\\n// exports = module.exports = nextTick;\\n\\n\\n/**\\n * @file ie版本号\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 从userAgent中ie版本号的匹配信息\\n *\\n * @type {Array}\\n */\\nvar ieVersionMatch = typeof navigator !== 'undefined'\\n    && navigator.userAgent.match(/msie\\\\s*([0-9]+)/i);\\n\\n/**\\n * ie版本号，非ie时为0\\n *\\n * @type {number}\\n */\\nvar ie = ieVersionMatch ? ieVersionMatch[1] - 0 : 0;\\n\\n// exports = module.exports = ie;\\n\\n\\n/**\\n * @file 是否 IE 并且小于 9\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ie = require('./ie');\\n\\n// HACK:\\n// 1. IE8下，设置innerHTML时如果以html comment开头，comment会被自动滤掉\\n//    为了保证stump存在，需要设置完html后，createComment并appendChild/insertBefore\\n// 2. IE8下，innerHTML还不支持custom element，所以需要用div替代，不用createElement\\n// 3. 虽然IE8已经优化了字符串+连接，碎片化连接性能不再退化\\n//    但是由于上面多个兼容场景都用 < 9 判断，所以字符串连接也沿用\\n//    所以结果是IE8下字符串连接用的是数组join的方式\\n\\n// #[begin] allua\\n/**\\n * 是否 IE 并且小于 9\\n */\\nvar ieOldThan9 = ie && ie < 9;\\n// #[end]\\n\\n// exports = module.exports = ieOldThan9;\\n\\n\\n/**\\n * @file DOM 事件挂载\\n * @author dafrok(o.o@mug.dog)\\n */\\n\\n/**\\n * DOM 事件挂载\\n *\\n * @inner\\n * @param {HTMLElement} el DOM元素\\n * @param {string} eventName 事件名\\n */\\nfunction trigger(el, eventName) {\\n    var event = document.createEvent('HTMLEvents');\\n    event.initEvent(eventName, true, true);\\n    el.dispatchEvent(event);\\n}\\n\\n// exports = module.exports = trigger;\\n\\n\\n/**\\n * @file 解决 IE9 在表单元素中删除字符时不触发事件的问题\\n * @author dafrok(o.o@mug.dog)\\n */\\n\\n// var ie = require('./ie');\\n// var on = require('./on');\\n// var trigger = require('./trigger');\\n\\n// #[begin] allua\\nif (ie === 9) {\\n    on(document, 'selectionchange', function () {\\n        var el = document.activeElement;\\n        if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {\\n            trigger(el, 'input');\\n        }\\n    });\\n}\\n// #[end]\\n\\n\\n/**\\n * @file 自闭合标签表\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var splitStr2Obj = require('../util/split-str-2-obj');\\n\\n/**\\n * 自闭合标签列表\\n *\\n * @type {Object}\\n */\\nvar autoCloseTags = splitStr2Obj('area,base,br,col,embed,hr,img,input,keygen,param,source,track,wbr');\\n\\n// exports = module.exports = autoCloseTags;\\n\\n\\n/**\\n * @file data types\\n * @author leon <ludafa@outlook.com>\\n */\\n\\n// var bind = require('./bind');\\n// var empty = require('./empty');\\n// var extend = require('./extend');\\n\\n// #[begin] error\\nvar ANONYMOUS_CLASS_NAME = '<<anonymous>>';\\n\\n/**\\n * 获取精确的类型\\n *\\n * @NOTE 如果 obj 是一个 DOMElement，我们会返回 `element`；\\n *\\n * @param  {*} obj 目标\\n * @return {string}\\n */\\nfunction getDataType(obj) {\\n\\n    if (obj && obj.nodeType === 1) {\\n        return 'element';\\n    }\\n\\n    return Object.prototype.toString\\n        .call(obj)\\n        .slice(8, -1)\\n        .toLowerCase();\\n}\\n// #[end]\\n\\n/**\\n * 创建链式的数据类型校验器\\n *\\n * @param  {Function} validate 真正的校验器\\n * @return {Function}\\n */\\nfunction createChainableChecker(validate) {\\n    var chainedChecker = function () {};\\n    chainedChecker.isRequired = empty;\\n\\n    // 只在 error 功能启用时才有实际上的 dataTypes 检测\\n    // #[begin] error\\n    var checkType = function (isRequired, data, dataName, componentName, fullDataName) {\\n\\n        var dataValue = data[dataName];\\n        var dataType = getDataType(dataValue);\\n\\n        componentName = componentName || ANONYMOUS_CLASS_NAME;\\n\\n        // 如果是 null 或 undefined，那么要提前返回啦\\n        if (dataValue == null) {\\n            // 是 required 就报错\\n            if (isRequired) {\\n                throw new Error('[SAN ERROR] '\\n                    + 'The `' + dataName + '` '\\n                    + 'is marked as required in `' + componentName + '`, '\\n                    + 'but its value is ' + dataType\\n                );\\n            }\\n            // 不是 required，那就是 ok 的\\n            return;\\n        }\\n\\n        validate(data, dataName, componentName, fullDataName);\\n\\n    };\\n\\n    chainedChecker = bind(checkType, null, false);\\n    chainedChecker.isRequired = bind(checkType, null, true);\\n    // #[end]\\n\\n\\n\\n    return chainedChecker;\\n\\n}\\n\\n// #[begin] error\\n/**\\n * 生成主要类型数据校验器\\n *\\n * @param  {string} type 主类型\\n * @return {Function}\\n */\\nfunction createPrimaryTypeChecker(type) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        var dataValue = data[dataName];\\n        var dataType = getDataType(dataValue);\\n\\n        if (dataType !== type) {\\n            throw new Error('[SAN ERROR] '\\n                + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\\n                + '(' + dataType + ' supplied to ' + componentName + ', '\\n                + 'expected ' + type + ')'\\n            );\\n        }\\n\\n    });\\n\\n}\\n\\n\\n\\n/**\\n * 生成 arrayOf 校验器\\n *\\n * @param  {Function} arrayItemChecker 数组中每项数据的校验器\\n * @return {Function}\\n */\\nfunction createArrayOfChecker(arrayItemChecker) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        if (typeof arrayItemChecker !== 'function') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `arrayOf`, expected `function`'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n        var dataType = getDataType(dataValue);\\n\\n        if (dataType !== 'array') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\\n                + '(' + dataType + ' supplied to ' + componentName + ', '\\n                + 'expected array)'\\n            );\\n        }\\n\\n        for (var i = 0, len = dataValue.length; i < len; i++) {\\n            arrayItemChecker(dataValue, i, componentName, fullDataName + '[' + i + ']');\\n        }\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 instanceOf 检测器\\n *\\n * @param  {Function|Class} expectedClass 期待的类\\n * @return {Function}\\n */\\nfunction createInstanceOfChecker(expectedClass) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        var dataValue = data[dataName];\\n\\n        if (dataValue instanceof expectedClass) {\\n            return;\\n        }\\n\\n        var dataValueClassName = dataValue.constructor && dataValue.constructor.name\\n            ? dataValue.constructor.name\\n            : ANONYMOUS_CLASS_NAME;\\n\\n        var expectedClassName = expectedClass.name || ANONYMOUS_CLASS_NAME;\\n\\n        throw new Error('[SAN ERROR] '\\n            + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\\n            + '(' + dataValueClassName + ' supplied to ' + componentName + ', '\\n            + 'expected instance of ' + expectedClassName + ')'\\n        );\\n\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 shape 校验器\\n *\\n * @param  {Object} shapeTypes shape 校验规则\\n * @return {Function}\\n */\\nfunction createShapeChecker(shapeTypes) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        if (getDataType(shapeTypes) !== 'object') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + fullDataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `shape`, expected `object`'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n        var dataType = getDataType(dataValue);\\n\\n        if (dataType !== 'object') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Invalid ' + componentName + ' data `' + fullDataName + '` of type'\\n                + '(' + dataType + ' supplied to ' + componentName + ', '\\n                + 'expected object)'\\n            );\\n        }\\n\\n        for (var shapeKeyName in shapeTypes) {\\n            if (shapeTypes.hasOwnProperty(shapeKeyName)) {\\n                var checker = shapeTypes[shapeKeyName];\\n                if (typeof checker === 'function') {\\n                    checker(dataValue, shapeKeyName, componentName, fullDataName + '.' + shapeKeyName);\\n                }\\n            }\\n        }\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 oneOf 校验器\\n *\\n * @param  {Array} expectedEnumValues 期待的枚举值\\n * @return {Function}\\n */\\nfunction createOneOfChecker(expectedEnumValues) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        if (getDataType(expectedEnumValues) !== 'array') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + fullDataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `oneOf`, array is expected.'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n\\n        for (var i = 0, len = expectedEnumValues.length; i < len; i++) {\\n            if (dataValue === expectedEnumValues[i]) {\\n                return;\\n            }\\n        }\\n\\n        throw new Error('[SAN ERROR] '\\n            + 'Invalid ' + componentName + ' data `' + fullDataName + '` of value'\\n            + '(`' + dataValue + '` supplied to ' + componentName + ', '\\n            + 'expected one of ' + expectedEnumValues.join(',') + ')'\\n        );\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 oneOfType 校验器\\n *\\n * @param  {Array<Function>} expectedEnumOfTypeValues 期待的枚举类型\\n * @return {Function}\\n */\\nfunction createOneOfTypeChecker(expectedEnumOfTypeValues) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        if (getDataType(expectedEnumOfTypeValues) !== 'array') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `oneOf`, array is expected.'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n\\n        for (var i = 0, len = expectedEnumOfTypeValues.length; i < len; i++) {\\n\\n            var checker = expectedEnumOfTypeValues[i];\\n\\n            if (typeof checker !== 'function') {\\n                continue;\\n            }\\n\\n            try {\\n                checker(data, dataName, componentName, fullDataName);\\n                // 如果 checker 完成校验没报错，那就返回了\\n                return;\\n            }\\n            catch (e) {\\n                // 如果有错误，那么应该把错误吞掉\\n            }\\n\\n        }\\n\\n        // 所有的可接受 type 都失败了，才丢一个异常\\n        throw new Error('[SAN ERROR] '\\n            + 'Invalid ' + componentName + ' data `' + dataName + '` of value'\\n            + '(`' + dataValue + '` supplied to ' + componentName + ')'\\n        );\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 objectOf 校验器\\n *\\n * @param  {Function} typeChecker 对象属性值校验器\\n * @return {Function}\\n */\\nfunction createObjectOfChecker(typeChecker) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName) {\\n\\n        if (typeof typeChecker !== 'function') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `objectOf`, expected function'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n        var dataType = getDataType(dataValue);\\n\\n        if (dataType !== 'object') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Invalid ' + componentName + ' data `' + dataName + '` of type'\\n                + '(' + dataType + ' supplied to ' + componentName + ', '\\n                + 'expected object)'\\n            );\\n        }\\n\\n        for (var dataKeyName in dataValue) {\\n            if (dataValue.hasOwnProperty(dataKeyName)) {\\n                typeChecker(\\n                    dataValue,\\n                    dataKeyName,\\n                    componentName,\\n                    fullDataName + '.' + dataKeyName\\n                );\\n            }\\n        }\\n\\n\\n    });\\n\\n}\\n\\n/**\\n * 生成 exact 校验器\\n *\\n * @param  {Object} shapeTypes object 形态定义\\n * @return {Function}\\n */\\nfunction createExactChecker(shapeTypes) {\\n\\n    return createChainableChecker(function (data, dataName, componentName, fullDataName, secret) {\\n\\n        if (getDataType(shapeTypes) !== 'object') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Data `' + dataName + '` of `' + componentName + '` has invalid '\\n                + 'DataType notation inside `exact`'\\n            );\\n        }\\n\\n        var dataValue = data[dataName];\\n        var dataValueType = getDataType(dataValue);\\n\\n        if (dataValueType !== 'object') {\\n            throw new Error('[SAN ERROR] '\\n                + 'Invalid data `' + fullDataName + '` of type `' + dataValueType + '`'\\n                + '(supplied to ' + componentName + ', expected `object`)'\\n            );\\n        }\\n\\n        var allKeys = {};\\n\\n        // 先合入 shapeTypes\\n        extend(allKeys, shapeTypes);\\n        // 再合入 dataValue\\n        extend(allKeys, dataValue);\\n        // 保证 allKeys 的类型正确\\n\\n        for (var key in allKeys) {\\n            if (allKeys.hasOwnProperty(key)) {\\n                var checker = shapeTypes[key];\\n\\n                // dataValue 中有一个多余的数据项\\n                if (!checker) {\\n                    throw new Error('[SAN ERROR] '\\n                        + 'Invalid data `' + fullDataName + '` key `' + key + '` '\\n                        + 'supplied to `' + componentName + '`. '\\n                        + '(`' + key + '` is not defined in `DataTypes.exact`)'\\n                    );\\n                }\\n\\n                if (!(key in dataValue)) {\\n                    throw new Error('[SAN ERROR] '\\n                        + 'Invalid data `' + fullDataName + '` key `' + key + '` '\\n                        + 'supplied to `' + componentName + '`. '\\n                        + '(`' + key + '` is marked `required` in `DataTypes.exact`)'\\n                    );\\n                }\\n\\n                checker(\\n                    dataValue,\\n                    key,\\n                    componentName,\\n                    fullDataName + '.' + key,\\n                    secret\\n                );\\n\\n            }\\n        }\\n\\n    });\\n\\n}\\n// #[end]\\n\\n\\n\\n/* eslint-disable fecs-valid-var-jsdoc */\\nvar DataTypes = {\\n    array: createChainableChecker(empty),\\n    object: createChainableChecker(empty),\\n    func: createChainableChecker(empty),\\n    string: createChainableChecker(empty),\\n    number: createChainableChecker(empty),\\n    bool: createChainableChecker(empty),\\n    symbol: createChainableChecker(empty),\\n    any: createChainableChecker,\\n    arrayOf: createChainableChecker,\\n    instanceOf: createChainableChecker,\\n    shape: createChainableChecker,\\n    oneOf: createChainableChecker,\\n    oneOfType: createChainableChecker,\\n    objectOf: createChainableChecker,\\n    exact: createChainableChecker\\n};\\n\\n// #[begin] error\\nDataTypes = {\\n\\n    any: createChainableChecker(empty),\\n\\n    // 类型检测\\n    array: createPrimaryTypeChecker('array'),\\n    object: createPrimaryTypeChecker('object'),\\n    func: createPrimaryTypeChecker('function'),\\n    string: createPrimaryTypeChecker('string'),\\n    number: createPrimaryTypeChecker('number'),\\n    bool: createPrimaryTypeChecker('boolean'),\\n    symbol: createPrimaryTypeChecker('symbol'),\\n\\n    // 复合类型检测\\n    arrayOf: createArrayOfChecker,\\n    instanceOf: createInstanceOfChecker,\\n    shape: createShapeChecker,\\n    oneOf: createOneOfChecker,\\n    oneOfType: createOneOfTypeChecker,\\n    objectOf: createObjectOfChecker,\\n    exact: createExactChecker\\n\\n};\\n/* eslint-enable fecs-valid-var-jsdoc */\\n// #[end]\\n\\n\\n// module.exports = DataTypes;\\n\\n\\n/**\\n * @file 创建数据检测函数\\n * @author leon<ludafa@outlook.com>\\n */\\n\\n\\n// #[begin] error\\n\\n/**\\n * 创建数据检测函数\\n *\\n * @param  {Object} dataTypes     数据格式\\n * @param  {string} componentName 组件名\\n * @return {Function}\\n */\\nfunction createDataTypesChecker(dataTypes, componentName) {\\n\\n    /**\\n     * 校验 data 是否满足 data types 的格式\\n     *\\n     * @param  {*} data 数据\\n     */\\n    return function (data) {\\n\\n        for (var dataTypeName in dataTypes) {\\n\\n            if (dataTypes.hasOwnProperty(dataTypeName)) {\\n\\n                var dataTypeChecker = dataTypes[dataTypeName];\\n\\n                if (typeof dataTypeChecker !== 'function') {\\n                    throw new Error('[SAN ERROR] '\\n                        + componentName + ':' + dataTypeName + ' is invalid; '\\n                        + 'it must be a function, usually from san.DataTypes'\\n                    );\\n                }\\n\\n                dataTypeChecker(\\n                    data,\\n                    dataTypeName,\\n                    componentName,\\n                    dataTypeName\\n                );\\n\\n\\n            }\\n        }\\n\\n    };\\n\\n}\\n\\n// #[end]\\n\\n// module.exports = createDataTypesChecker;\\n\\n\\n/**\\n * @file 字符串源码读取类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 字符串源码读取类，用于模板字符串解析过程\\n *\\n * @class\\n * @param {string} source 要读取的字符串\\n */\\nfunction Walker(source) {\\n    this.source = source;\\n    this.len = this.source.length;\\n    this.index = 0;\\n}\\n\\n/**\\n * 获取当前字符码\\n *\\n * @return {number}\\n */\\nWalker.prototype.currentCode = function () {\\n    return this.charCode(this.index);\\n};\\n\\n/**\\n * 截取字符串片段\\n *\\n * @param {number} start 起始位置\\n * @param {number} end 结束位置\\n * @return {string}\\n */\\nWalker.prototype.cut = function (start, end) {\\n    return this.source.slice(start, end);\\n};\\n\\n/**\\n * 向前读取字符\\n *\\n * @param {number} distance 读取字符数\\n */\\nWalker.prototype.go = function (distance) {\\n    this.index += distance;\\n};\\n\\n/**\\n * 读取下一个字符，返回下一个字符的 code\\n *\\n * @return {number}\\n */\\nWalker.prototype.nextCode = function () {\\n    this.go(1);\\n    return this.currentCode();\\n};\\n\\n/**\\n * 获取相应位置字符的 code\\n *\\n * @param {number} index 字符位置\\n * @return {number}\\n */\\nWalker.prototype.charCode = function (index) {\\n    return this.source.charCodeAt(index);\\n};\\n\\n/**\\n * 向前读取字符，直到遇到指定字符再停止\\n *\\n * @param {number=} charCode 指定字符的code\\n * @return {boolean} 当指定字符时，返回是否碰到指定的字符\\n */\\nWalker.prototype.goUntil = function (charCode) {\\n    var code;\\n    while (this.index < this.len && (code = this.currentCode())) {\\n        switch (code) {\\n            case 32:\\n            case 9:\\n                this.index++;\\n                break;\\n            default:\\n                if (code === charCode) {\\n                    this.index++;\\n                    return 1;\\n                }\\n                return;\\n        }\\n    }\\n};\\n\\n/**\\n * 向前读取符合规则的字符片段，并返回规则匹配结果\\n *\\n * @param {RegExp} reg 字符片段的正则表达式\\n * @return {Array}\\n */\\nWalker.prototype.match = function (reg) {\\n    reg.lastIndex = this.index;\\n\\n    var match = reg.exec(this.source);\\n    if (match) {\\n        this.index = reg.lastIndex;\\n    }\\n\\n    return match;\\n};\\n\\n// exports = module.exports = Walker;\\n\\n\\n\\n/**\\n * @file 模板解析生成的抽象节点\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 创建模板解析生成的抽象节点\\n *\\n * @param {Object=} options 节点参数\\n * @param {string=} options.tagName 标签名\\n * @param {ANode=} options.parent 父节点\\n * @param {boolean=} options.textExpr 文本节点表达式对象\\n * @return {Object}\\n */\\nfunction createANode(options) {\\n    options = options || {};\\n\\n    if (!options.textExpr) {\\n        options.directives = options.directives || {};\\n        options.props = options.props || [];\\n        options.events = options.events || [];\\n        options.children = options.children || [];\\n    }\\n\\n    return options;\\n}\\n\\n// exports = module.exports = createANode;\\n\\n\\n/**\\n * @file 把 kebab case 字符串转换成 camel case\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 把 kebab case 字符串转换成 camel case\\n *\\n * @param {string} source 源字符串\\n * @return {string}\\n */\\nfunction kebab2camel(source) {\\n    return source.replace(/-([a-z])/g, function (match, alpha) {\\n        return alpha.toUpperCase();\\n    });\\n}\\n\\n// exports = module.exports = kebab2camel;\\n\\n\\n/**\\n * @file 表达式类型\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 表达式类型\\n *\\n * @const\\n * @type {Object}\\n */\\nvar ExprType = {\\n    STRING: 1,\\n    NUMBER: 2,\\n    BOOL: 3,\\n    ACCESSOR: 4,\\n    INTERP: 5,\\n    CALL: 6,\\n    TEXT: 7,\\n    BINARY: 8,\\n    UNARY: 9,\\n    TERTIARY: 10\\n};\\n\\n// exports = module.exports = ExprType;\\n\\n\\n/**\\n * @file 创建访问表达式对象\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n\\n/**\\n * 创建访问表达式对象\\n *\\n * @param {Array} paths 访问路径\\n * @return {Object}\\n */\\nfunction createAccessor(paths) {\\n    return {\\n        type: ExprType.ACCESSOR,\\n        paths: paths\\n    };\\n}\\n\\n// exports = module.exports = createAccessor;\\n\\n\\n/**\\n * @file 读取字符串\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var ExprType = require('./expr-type');\\n\\n/**\\n * 读取字符串\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readString(walker) {\\n    var startCode = walker.currentCode();\\n    var startIndex = walker.index;\\n    var charCode;\\n\\n    walkLoop: while ((charCode = walker.nextCode())) {\\n        switch (charCode) {\\n            case 92: // \\\\\\n                walker.go(1);\\n                break;\\n            case startCode:\\n                walker.go(1);\\n                break walkLoop;\\n        }\\n    }\\n\\n    var literal = walker.cut(startIndex, walker.index);\\n    return {\\n        type: ExprType.STRING,\\n        value: (new Function('return ' + literal))()\\n    };\\n}\\n\\n// exports = module.exports = readString;\\n\\n\\n/**\\n * @file 读取数字\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var ExprType = require('./expr-type');\\n\\n/**\\n * 读取数字\\n *\\n * @inner\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readNumber(walker) {\\n    var match = walker.match(/\\\\s*(-?[0-9]+(\\\\.[0-9]+)?)/g);\\n\\n    return {\\n        type: ExprType.NUMBER,\\n        value: match[1] - 0\\n    };\\n}\\n\\n// exports = module.exports = readNumber;\\n\\n\\n/**\\n * @file 读取ident\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 读取ident\\n *\\n * @inner\\n * @param {Walker} walker 源码读取对象\\n * @return {string}\\n */\\nfunction readIdent(walker) {\\n    var match = walker.match(/\\\\s*([\\\\$0-9a-z_]+)/ig);\\n    return match[1];\\n}\\n\\n// exports = module.exports = readIdent;\\n\\n\\n/**\\n * @file 读取三元表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readLogicalORExpr = require('./read-logical-or-expr');\\n\\n/**\\n * 读取三元表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readTertiaryExpr(walker) {\\n    var conditional = readLogicalORExpr(walker);\\n    walker.goUntil();\\n\\n    if (walker.currentCode() === 63) { // ?\\n        walker.go(1);\\n        var yesExpr = readTertiaryExpr(walker);\\n        walker.goUntil();\\n\\n        if (walker.currentCode() === 58) { // :\\n            walker.go(1);\\n            return {\\n                type: ExprType.TERTIARY,\\n                segs: [\\n                    conditional,\\n                    yesExpr,\\n                    readTertiaryExpr(walker)\\n                ]\\n            };\\n        }\\n    }\\n\\n    return conditional;\\n}\\n\\n// exports = module.exports = readTertiaryExpr;\\n\\n\\n/**\\n * @file 读取访问表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var createAccessor = require('./create-accessor');\\n// var readIdent = require('./read-ident');\\n// var readTertiaryExpr = require('./read-tertiary-expr');\\n\\n/**\\n * 读取访问表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readAccessor(walker) {\\n    var firstSeg = readIdent(walker);\\n    switch (firstSeg) {\\n        case 'true':\\n        case 'false':\\n            return {\\n                type: ExprType.BOOL,\\n                value: firstSeg === 'true'\\n            };\\n    }\\n\\n    var result = createAccessor([\\n        {\\n            type: ExprType.STRING,\\n            value: firstSeg\\n        }\\n    ]);\\n\\n    /* eslint-disable no-constant-condition */\\n    accessorLoop: while (1) {\\n    /* eslint-enable no-constant-condition */\\n\\n        switch (walker.currentCode()) {\\n            case 46: // .\\n                walker.go(1);\\n\\n                // ident as string\\n                result.paths.push({\\n                    type: ExprType.STRING,\\n                    value: readIdent(walker)\\n                });\\n                break;\\n\\n            case 91: // [\\n                walker.go(1);\\n                result.paths.push(readTertiaryExpr(walker));\\n                walker.goUntil(93); // ]\\n                break;\\n\\n            default:\\n                break accessorLoop;\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n// exports = module.exports = readAccessor;\\n\\n\\n/**\\n * @file 读取括号表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var readTertiaryExpr = require('./read-tertiary-expr');\\n\\n/**\\n * 读取括号表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readParenthesizedExpr(walker) {\\n    walker.go(1);\\n    var expr = readTertiaryExpr(walker);\\n    walker.goUntil(41); // )\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readParenthesizedExpr;\\n\\n\\n/**\\n * @file 读取一元表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readString = require('./read-string');\\n// var readNumber = require('./read-number');\\n// var readAccessor = require('./read-accessor');\\n// var readParenthesizedExpr = require('./read-parenthesized-expr');\\n\\n\\n/**\\n * 读取一元表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readUnaryExpr(walker) {\\n    walker.goUntil();\\n\\n    switch (walker.currentCode()) {\\n        case 33: // !\\n            walker.go(1);\\n            return {\\n                type: ExprType.UNARY,\\n                expr: readUnaryExpr(walker)\\n            };\\n        case 34: // \\\"\\n        case 39: // '\\n            return readString(walker);\\n        case 45: // number\\n        case 48:\\n        case 49:\\n        case 50:\\n        case 51:\\n        case 52:\\n        case 53:\\n        case 54:\\n        case 55:\\n        case 56:\\n        case 57:\\n            return readNumber(walker);\\n        case 40: // (\\n            return readParenthesizedExpr(walker);\\n    }\\n\\n    return readAccessor(walker);\\n}\\n\\n// exports = module.exports = readUnaryExpr;\\n\\n\\n/**\\n * @file 读取乘法表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readUnaryExpr = require('./read-unary-expr');\\n\\n/**\\n * 读取乘法表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readMultiplicativeExpr(walker) {\\n    var expr = readUnaryExpr(walker);\\n\\n    while (1) {\\n        walker.goUntil();\\n\\n        var code = walker.currentCode();\\n        switch (code) {\\n            case 37: // %\\n            case 42: // *\\n            case 47: // /\\n                walker.go(1);\\n                expr = {\\n                    type: ExprType.BINARY,\\n                    operator: code,\\n                    segs: [expr, readUnaryExpr(walker)]\\n                };\\n                continue;\\n        }\\n\\n        break;\\n    }\\n\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readMultiplicativeExpr;\\n\\n\\n/**\\n * @file 读取加法表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readMultiplicativeExpr = require('./read-multiplicative-expr');\\n\\n\\n/**\\n * 读取加法表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readAdditiveExpr(walker) {\\n    var expr = readMultiplicativeExpr(walker);\\n\\n    while (1) {\\n        walker.goUntil();\\n        var code = walker.currentCode();\\n\\n        switch (code) {\\n            case 43: // +\\n            case 45: // -\\n                walker.go(1);\\n                expr = {\\n                    type: ExprType.BINARY,\\n                    operator: code,\\n                    segs: [expr, readMultiplicativeExpr(walker)]\\n                };\\n                continue;\\n        }\\n\\n        break;\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readAdditiveExpr;\\n\\n\\n/**\\n * @file 读取关系判断表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readAdditiveExpr = require('./read-additive-expr');\\n\\n/**\\n * 读取关系判断表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readRelationalExpr(walker) {\\n    var expr = readAdditiveExpr(walker);\\n    walker.goUntil();\\n\\n    var code = walker.currentCode();\\n    switch (code) {\\n        case 60: // <\\n        case 62: // >\\n            if (walker.nextCode() === 61) {\\n                code += 61;\\n                walker.go(1);\\n            }\\n\\n            return {\\n                type: ExprType.BINARY,\\n                operator: code,\\n                segs: [expr, readAdditiveExpr(walker)]\\n            };\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readRelationalExpr;\\n\\n\\n/**\\n * @file 读取相等比对表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readRelationalExpr = require('./read-relational-expr');\\n\\n/**\\n * 读取相等比对表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readEqualityExpr(walker) {\\n    var expr = readRelationalExpr(walker);\\n    walker.goUntil();\\n\\n    var code = walker.currentCode();\\n    switch (code) {\\n        case 61: // =\\n        case 33: // !\\n            if (walker.nextCode() === 61) {\\n                code += 61;\\n                if (walker.nextCode() === 61) {\\n                    code += 61;\\n                    walker.go(1);\\n                }\\n\\n                return {\\n                    type: ExprType.BINARY,\\n                    operator: code,\\n                    segs: [expr, readRelationalExpr(walker)]\\n                };\\n            }\\n\\n            walker.go(-1);\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readEqualityExpr;\\n\\n\\n/**\\n * @file 读取逻辑与表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readEqualityExpr = require('./read-equality-expr');\\n\\n/**\\n * 读取逻辑与表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readLogicalANDExpr(walker) {\\n    var expr = readEqualityExpr(walker);\\n    walker.goUntil();\\n\\n    if (walker.currentCode() === 38) { // &\\n        if (walker.nextCode() === 38) {\\n            walker.go(1);\\n            return {\\n                type: ExprType.BINARY,\\n                operator: 76,\\n                segs: [expr, readLogicalANDExpr(walker)]\\n            };\\n        }\\n\\n        walker.go(-1);\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readLogicalANDExpr;\\n\\n\\n/**\\n * @file 读取逻辑或表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readLogicalANDExpr = require('./read-logical-and-expr');\\n\\n/**\\n * 读取逻辑或表达式\\n *\\n * @param {Walker} walker 源码读取对象\\n * @return {Object}\\n */\\nfunction readLogicalORExpr(walker) {\\n    var expr = readLogicalANDExpr(walker);\\n    walker.goUntil();\\n\\n    if (walker.currentCode() === 124) { // |\\n        if (walker.nextCode() === 124) {\\n            walker.go(1);\\n            return {\\n                type: ExprType.BINARY,\\n                operator: 248,\\n                segs: [expr, readLogicalORExpr(walker)]\\n            };\\n        }\\n\\n        walker.go(-1);\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = readLogicalORExpr;\\n\\n\\n/**\\n * @file 解析表达式\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var Walker = require('./walker');\\n// var readTertiaryExpr = require('./read-tertiary-expr');\\n\\n/**\\n * 解析表达式\\n *\\n * @param {string} source 源码\\n * @return {Object}\\n */\\nfunction parseExpr(source) {\\n    if (typeof source === 'object' && source.type) {\\n        return source;\\n    }\\n\\n    var expr = readTertiaryExpr(new Walker(source));\\n    expr.raw = source;\\n    return expr;\\n}\\n\\n// exports = module.exports = parseExpr;\\n\\n\\n/**\\n * @file 读取调用\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('./expr-type');\\n// var readAccessor = require('./read-accessor');\\n// var readTertiaryExpr = require('./read-tertiary-expr');\\n\\n/**\\n * 读取调用\\n *\\n * @param {Walker} walker 源码读取对象\\n * @param {Array=} defaultArgs 默认参数\\n * @return {Object}\\n */\\nfunction readCall(walker, defaultArgs) {\\n    walker.goUntil();\\n    var ident = readAccessor(walker);\\n    var args = [];\\n\\n    if (walker.goUntil(40)) { // (\\n        while (!walker.goUntil(41)) { // )\\n            args.push(readTertiaryExpr(walker));\\n            walker.goUntil(44); // ,\\n        }\\n    }\\n    else if (defaultArgs) {\\n        args = defaultArgs;\\n    }\\n\\n    return {\\n        type: ExprType.CALL,\\n        name: ident,\\n        args: args\\n    };\\n}\\n\\n// exports = module.exports = readCall;\\n\\n\\n/**\\n * @file 解析调用\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var Walker = require('./walker');\\n// var readCall = require('./read-call');\\n\\n/**\\n * 解析调用\\n *\\n * @param {string} source 源码\\n * @param {Array=} defaultArgs 默认参数\\n * @return {Object}\\n */\\nfunction parseCall(source, defaultArgs) {\\n    var expr = readCall(new Walker(source), defaultArgs);\\n    expr.raw = source;\\n    return expr;\\n}\\n\\n// exports = module.exports = parseCall;\\n\\n\\n/**\\n * @file 解析插值替换\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var Walker = require('./walker');\\n// var readTertiaryExpr = require('./read-tertiary-expr');\\n// var ExprType = require('./expr-type');\\n// var readCall = require('./read-call');\\n\\n/**\\n * 解析插值替换\\n *\\n * @param {string} source 源码\\n * @return {Object}\\n */\\nfunction parseInterp(source) {\\n    var walker = new Walker(source);\\n\\n    var interp = {\\n        type: ExprType.INTERP,\\n        expr: readTertiaryExpr(walker),\\n        filters: [],\\n        raw: source\\n    };\\n\\n    while (walker.goUntil(124)) { // |\\n        var callExpr = readCall(walker);\\n        switch (callExpr.name.paths[0].value) {\\n            case 'html':\\n                break;\\n            case 'raw':\\n                interp.original = 1;\\n                break;\\n            default:\\n                interp.filters.push(callExpr);\\n        }\\n    }\\n\\n    return interp;\\n}\\n\\n// exports = module.exports = parseInterp;\\n\\n\\n/**\\n * @file 解码 HTML 字符实体\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\nvar ENTITY_DECODE_MAP = {\\n    lt: '<',\\n    gt: '>',\\n    nbsp: ' ',\\n    quot: '\\\\\\\"',\\n    emsp: '\\\\u2003',\\n    ensp: '\\\\u2002',\\n    thinsp: '\\\\u2009',\\n    copy: '\\\\xa9',\\n    reg: '\\\\xae',\\n    zwnj: '\\\\u200c',\\n    zwj: '\\\\u200d',\\n    amp: '&'\\n};\\n\\n/**\\n * 解码 HTML 字符实体\\n *\\n * @param {string} source 要解码的字符串\\n * @return {string}\\n */\\nfunction decodeHTMLEntity(source) {\\n    return source\\n        .replace(/&#([0-9]+);/g, function (match, code) {\\n            return String.fromCharCode(+code);\\n        })\\n        .replace(/&#x([0-9a-f]+);/ig, function (match, code) {\\n            return String.fromCharCode(parseInt(code, 16));\\n        })\\n        .replace(/&([a-z]+);/ig, function (match, code) {\\n            return ENTITY_DECODE_MAP[code] || match;\\n        });\\n}\\n\\n// exports = module.exports = decodeHTMLEntity;\\n\\n\\n/**\\n * @file 解析文本\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var Walker = require('./walker');\\n// var ExprType = require('./expr-type');\\n// var parseInterp = require('./parse-interp');\\n// var decodeHTMLEntity = require('../util/decode-html-entity');\\n\\n/**\\n * 对字符串进行可用于new RegExp的字面化\\n *\\n * @inner\\n * @param {string} source 需要字面化的字符串\\n * @return {string} 字符串字面化结果\\n */\\nfunction regexpLiteral(source) {\\n    return source.replace(/[\\\\^\\\\[\\\\]\\\\$\\\\(\\\\)\\\\{\\\\}\\\\?\\\\*\\\\.\\\\+\\\\\\\\]/g, function (c) {\\n        return '\\\\\\\\' + c;\\n    });\\n}\\n\\n/**\\n * 解析文本\\n *\\n * @param {string} source 源码\\n * @param {Array?} delimiters 分隔符。默认为 ['{{', '}}']\\n * @return {Object}\\n */\\nfunction parseText(source, delimiters) {\\n    delimiters = delimiters || ['{{', '}}'];\\n    var exprStartReg = new RegExp(\\n        regexpLiteral(delimiters[0]) + '\\\\\\\\s*([\\\\\\\\s\\\\\\\\S]+?)\\\\\\\\s*' + regexpLiteral(delimiters[1]),\\n        'ig'\\n    );\\n\\n    var exprMatch;\\n\\n    var walker = new Walker(source);\\n    var beforeIndex = 0;\\n\\n    var expr = {\\n        type: ExprType.TEXT,\\n        segs: []\\n    };\\n\\n    function pushStringToSeg(text) {\\n        text && expr.segs.push({\\n            type: ExprType.STRING,\\n            literal: text,\\n            value: decodeHTMLEntity(text)\\n        });\\n    }\\n\\n    while ((exprMatch = walker.match(exprStartReg)) != null) {\\n        pushStringToSeg(walker.cut(\\n            beforeIndex,\\n            walker.index - exprMatch[0].length\\n        ));\\n\\n        var interp = parseInterp(exprMatch[1]);\\n        expr.original = expr.original || interp.original;\\n\\n        expr.segs.push(interp);\\n        beforeIndex = walker.index;\\n    }\\n\\n    pushStringToSeg(walker.cut(beforeIndex));\\n\\n\\n\\n    if (expr.segs.length === 1 && expr.segs[0].type === ExprType.STRING) {\\n        expr.value = expr.segs[0].value;\\n    }\\n\\n    return expr;\\n}\\n\\n// exports = module.exports = parseText;\\n\\n\\n/**\\n * @file 解析指令\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var Walker = require('./walker');\\n// var parseExpr = require('./parse-expr');\\n// var parseCall = require('./parse-call');\\n// var parseText = require('./parse-text');\\n// var readAccessor = require('./read-accessor');\\n\\n/**\\n * 指令解析器\\n *\\n * @inner\\n * @type {Object}\\n */\\nvar directiveParsers = {\\n    'for': function (value) {\\n        var walker = new Walker(value);\\n        var match = walker.match(/^\\\\s*([\\\\$0-9a-z_]+)(\\\\s*,\\\\s*([\\\\$0-9a-z_]+))?\\\\s+in\\\\s+/ig);\\n\\n        if (match) {\\n            return {\\n                item: parseExpr(match[1]),\\n                index: parseExpr(match[3] || '$index'),\\n                value: readAccessor(walker)\\n            };\\n        }\\n\\n        // #[begin] error\\n        throw new Error('[SAN FATAL] for syntax error: ' + value);\\n        // #[end]\\n    },\\n\\n    'ref': function (value, options) {\\n        return {\\n            value: parseText(value, options.delimiters)\\n        };\\n    },\\n\\n    'if': function (value) {\\n        return {\\n            value: parseExpr(value.replace(/(^\\\\{\\\\{|\\\\}\\\\}$)/g, ''))\\n        };\\n    },\\n\\n    'elif': function (value) {\\n        return {\\n            value: parseExpr(value.replace(/(^\\\\{\\\\{|\\\\}\\\\}$)/g, ''))\\n        };\\n    },\\n\\n    'else': function (value) {\\n        return {\\n            value: {}\\n        };\\n    },\\n\\n    'html': function (value) {\\n        return {\\n            value: parseExpr(value.replace(/(^\\\\{\\\\{|\\\\}\\\\}$)/g, ''))\\n        };\\n    },\\n\\n    'transition': function (value) {\\n        return {\\n            value: parseCall(value)\\n        };\\n    }\\n};\\n\\n/**\\n * 解析指令\\n *\\n * @param {ANode} aNode 抽象节点\\n * @param {string} name 指令名称\\n * @param {string} value 指令值\\n * @param {Object} options 解析参数\\n * @param {Array?} options.delimiters 插值分隔符列表\\n */\\nfunction parseDirective(aNode, name, value, options) {\\n    if (name === 'else-if') {\\n        name = 'elif';\\n    }\\n\\n    var parser = directiveParsers[name];\\n    if (parser) {\\n        (aNode.directives[name] = parser(value, options)).raw = value;\\n    }\\n}\\n\\n// exports = module.exports = parseDirective;\\n\\n\\n/**\\n * @file 对属性信息进行处理\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('../parser/expr-type');\\n\\n/**\\n * 对属性信息进行处理\\n * 对组件的 binds 或者特殊的属性（比如 input 的 checked）需要处理\\n *\\n * 扁平化：\\n * 当 text 解析只有一项时，要么就是 string，要么就是 interp\\n * interp 有可能是绑定到组件属性的表达式，不希望被 eval text 成 string\\n * 所以这里做个处理，只有一项时直接抽出来\\n *\\n * bool属性：\\n * 当绑定项没有值时，默认为true\\n *\\n * @param {Object} prop 属性对象\\n */\\nfunction postProp(prop) {\\n    var expr = prop.expr;\\n\\n    if (expr.type === ExprType.TEXT) {\\n        switch (expr.segs.length) {\\n            case 0:\\n                prop.expr = {\\n                    type: ExprType.BOOL,\\n                    value: true\\n                };\\n                break;\\n\\n            case 1:\\n                expr = prop.expr = expr.segs[0];\\n                if (expr.type === ExprType.INTERP && expr.filters.length === 0) {\\n                    prop.expr = expr.expr;\\n                }\\n        }\\n    }\\n}\\n\\n// exports = module.exports = postProp;\\n\\n\\n/**\\n * @file 解析抽象节点属性\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var kebab2camel = require('../util/kebab2camel');\\n// var ExprType = require('./expr-type');\\n// var createAccessor = require('./create-accessor');\\n// var parseExpr = require('./parse-expr');\\n// var parseCall = require('./parse-call');\\n// var parseText = require('./parse-text');\\n// var parseDirective = require('./parse-directive');\\n// var postProp = require('./post-prop');\\n\\n\\n/**\\n * 解析抽象节点属性\\n *\\n * @param {ANode} aNode 抽象节点\\n * @param {string} name 属性名称\\n * @param {string} value 属性值\\n * @param {Object} options 解析参数\\n * @param {Array?} options.delimiters 插值分隔符列表\\n */\\nfunction integrateAttr(aNode, name, value, options) {\\n    var prefixIndex = name.indexOf('-');\\n    var realName;\\n    var prefix;\\n\\n    if (prefixIndex > 0) {\\n        prefix = name.slice(0, prefixIndex);\\n        realName = name.slice(prefixIndex + 1);\\n    }\\n\\n    switch (prefix) {\\n        case 'on':\\n            var event = {\\n                name: realName,\\n                modifier: {}\\n            };\\n            aNode.events.push(event);\\n\\n            var colonIndex;\\n            while ((colonIndex = value.indexOf(':')) > 0) {\\n                var modifier = value.slice(0, colonIndex);\\n\\n                // eventHandler(\\\"dd:aa\\\") 这种情况不能算modifier，需要辨识\\n                if (!/^[a-z]+$/i.test(modifier)) {\\n                    break;\\n                }\\n\\n                event.modifier[modifier] = true;\\n                value = value.slice(colonIndex + 1);\\n            }\\n\\n            event.expr = parseCall(value, [\\n                createAccessor([\\n                    { type: ExprType.STRING, value: '$event' }\\n                ])\\n            ]);\\n            break;\\n\\n        case 'san':\\n        case 's':\\n            parseDirective(aNode, realName, value, options);\\n            break;\\n\\n        case 'prop':\\n            integrateProp(aNode, realName, value, options);\\n            break;\\n\\n        case 'var':\\n            if (!aNode.vars) {\\n                aNode.vars = [];\\n            }\\n\\n            realName = kebab2camel(realName);\\n            aNode.vars.push({\\n                name: realName,\\n                expr: parseExpr(value.replace(/(^\\\\{\\\\{|\\\\}\\\\}$)/g, ''))\\n            });\\n            break;\\n\\n        default:\\n            integrateProp(aNode, name, value, options);\\n    }\\n}\\n\\n/**\\n * 解析抽象节点绑定属性\\n *\\n * @inner\\n * @param {ANode} aNode 抽象节点\\n * @param {string} name 属性名称\\n * @param {string} value 属性值\\n * @param {Object} options 解析参数\\n * @param {Array?} options.delimiters 插值分隔符列表\\n */\\nfunction integrateProp(aNode, name, value, options) {\\n    // parse two way binding, e.g. value=\\\"{=ident=}\\\"\\n    var xMatch = value.match(/^\\\\{=\\\\s*(.*?)\\\\s*=\\\\}$/);\\n\\n    if (xMatch) {\\n        aNode.props.push({\\n            name: name,\\n            expr: parseExpr(xMatch[1]),\\n            x: 1,\\n            raw: value\\n        });\\n\\n        return;\\n    }\\n\\n    // parse normal prop\\n    var prop = {\\n        name: name,\\n        expr: parseText(value, options.delimiters),\\n        raw: value\\n    };\\n\\n    // 这里不能把只有一个插值的属性抽取\\n    // 因为插值里的值可能是html片段，容易被注入\\n    // 组件的数据绑定在组件init时做抽取\\n    switch (name) {\\n        case 'class':\\n        case 'style':\\n            each(prop.expr.segs, function (seg) {\\n                if (seg.type === ExprType.INTERP) {\\n                    seg.filters.push({\\n                        type: ExprType.CALL,\\n                        name: createAccessor([\\n                            {\\n                                type: ExprType.STRING,\\n                                value: '_' + prop.name\\n                            }\\n                        ]),\\n                        args: []\\n                    });\\n                }\\n            });\\n            break;\\n\\n        case 'checked':\\n            if (aNode.tagName === 'input') {\\n                postProp(prop);\\n            }\\n            break;\\n    }\\n\\n    aNode.props.push(prop);\\n}\\n\\n\\n// exports = module.exports = integrateAttr;\\n\\n\\n/**\\n * @file 解析模板\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var createANode = require('./create-a-node');\\n// var Walker = require('./walker');\\n// var integrateAttr = require('./integrate-attr');\\n// var parseText = require('./parse-text');\\n// var autoCloseTags = require('../browser/auto-close-tags');\\n\\n// #[begin] error\\nfunction getXPath(stack, currentTagName) {\\n    var path = ['ROOT'];\\n    for (var i = 1, len = stack.length; i < len; i++) {\\n        path.push(stack[i].tagName);\\n    }\\n    if (currentTagName) {\\n        path.push(currentTagName);\\n    }\\n    return path.join('>');\\n}\\n// #[end]\\n\\n/* eslint-disable fecs-max-statements */\\n\\n/**\\n * 解析 template\\n *\\n * @param {string} source template源码\\n * @param {Object?} options 解析参数\\n * @param {string?} options.trimWhitespace 空白文本的处理策略。none|blank|all\\n * @param {Array?} options.delimiters 插值分隔符列表\\n * @return {ANode}\\n */\\nfunction parseTemplate(source, options) {\\n    options = options || {};\\n    options.trimWhitespace = options.trimWhitespace || 'none';\\n\\n    var rootNode = createANode();\\n\\n    if (typeof source !== 'string') {\\n        return rootNode;\\n    }\\n\\n    source = source.replace(/\\x3c!--([\\\\s\\\\S]*?)--\\x3e/mg, '').replace(/(^\\\\s+|\\\\s+$)/g, '');\\n    var walker = new Walker(source);\\n\\n    var tagReg = /<(\\\\/)?([a-z0-9-]+)\\\\s*/ig;\\n    var attrReg = /([-:0-9a-z\\\\(\\\\)\\\\[\\\\]]+)(\\\\s*=\\\\s*(['\\\"])([^\\\\3]*?)\\\\3)?\\\\s*/ig;\\n\\n    var tagMatch;\\n    var currentNode = rootNode;\\n    var stack = [rootNode];\\n    var stackIndex = 0;\\n    var beforeLastIndex = 0;\\n\\n    while ((tagMatch = walker.match(tagReg)) != null) {\\n        var tagEnd = tagMatch[1];\\n        var tagName = tagMatch[2].toLowerCase();\\n\\n        pushTextNode(source.slice(\\n            beforeLastIndex,\\n            walker.index - tagMatch[0].length\\n        ));\\n\\n        // 62: >\\n        // 47: /\\n        // 处理 </xxxx >\\n        if (tagEnd && walker.currentCode() === 62) {\\n            // 满足关闭标签的条件时，关闭标签\\n            // 向上查找到对应标签，找不到时忽略关闭\\n            var closeIndex = stackIndex;\\n\\n            // #[begin] error\\n            // 如果正在闭合一个自闭合的标签，例如 </input>，报错\\n            if (autoCloseTags[tagName]) {\\n                throw new Error(''\\n                    + '[SAN ERROR] ' + getXPath(stack, tagName) + ' is a `auto closed` tag, '\\n                    + 'so it cannot be closed with </' + tagName + '>'\\n                );\\n            }\\n\\n            // 如果关闭的 tag 和当前打开的不一致，报错\\n            if (\\n                stack[closeIndex].tagName !== tagName\\n                // 这里要把 table 自动添加 tbody 的情况给去掉\\n                && !(tagName === 'table' && stack[closeIndex].tagName === 'tbody')\\n            ) {\\n                throw new Error('[SAN ERROR] ' + getXPath(stack) + ' is closed with ' + tagName);\\n            }\\n            // #[end]\\n\\n            while (closeIndex > 0 && stack[closeIndex].tagName !== tagName) {\\n                closeIndex--;\\n            }\\n\\n            if (closeIndex > 0) {\\n                stackIndex = closeIndex - 1;\\n                currentNode = stack[stackIndex];\\n            }\\n            walker.go(1);\\n        }\\n\\n        // #[begin] error\\n        // 处理 </xxx 非正常闭合标签\\n        else if (tagEnd) {\\n\\n            // 如果闭合标签时，匹配后的下一个字符是 <，即下一个标签的开始，那么当前闭合标签未闭合\\n            if (walker.currentCode() === 60) {\\n                throw new Error(''\\n                    + '[SAN ERROR] ' + getXPath(stack)\\n                    + '\\\\'s close tag not closed'\\n                );\\n            }\\n\\n            // 闭合标签有属性\\n            throw new Error(''\\n                + '[SAN ERROR] ' + getXPath(stack)\\n                + '\\\\'s close tag has attributes'\\n            );\\n\\n        }\\n        // #[end]\\n\\n        else if (!tagEnd) {\\n            var aElement = createANode({\\n                tagName: tagName\\n            });\\n            var tagClose = autoCloseTags[tagName];\\n\\n            // 解析 attributes\\n\\n            /* eslint-disable no-constant-condition */\\n            while (1) {\\n            /* eslint-enable no-constant-condition */\\n\\n                var nextCharCode = walker.currentCode();\\n\\n                // 标签结束时跳出 attributes 读取\\n                // 标签可能直接结束或闭合结束\\n                if (nextCharCode === 62) {\\n                    walker.go(1);\\n                    break;\\n                }\\n                // 遇到 /> 按闭合处理\\n                else if (nextCharCode === 47\\n                    && walker.charCode(walker.index + 1) === 62\\n                ) {\\n                    walker.go(2);\\n                    tagClose = 1;\\n                    break;\\n                }\\n\\n                // #[begin] error\\n                // 在处理一个 open 标签时，如果遇到了 <， 即下一个标签的开始，则当前标签未能正常闭合，报错\\n                if (nextCharCode === 60) {\\n                    throw new Error('[SAN ERROR] ' + getXPath(stack, tagName) + ' is not closed');\\n                }\\n                // #[end]\\n\\n                // 读取 attribute\\n                var attrMatch = walker.match(attrReg);\\n                if (attrMatch) {\\n\\n                    // #[begin] error\\n                    // 如果属性有 =，但没取到 value，报错\\n                    if (\\n                        walker.charCode(attrMatch.index + attrMatch[1].length) === 61\\n                        && !attrMatch[2]\\n                    ) {\\n                        throw new Error(''\\n                            + '[SAN ERROR] ' + getXPath(stack, tagName) + ' attribute `'\\n                            + attrMatch[1] + '` is not wrapped with \\\"\\\"'\\n                        );\\n                    }\\n                    // #[end]\\n\\n                    integrateAttr(\\n                        aElement,\\n                        attrMatch[1],\\n                        attrMatch[2] ? attrMatch[4] : '',\\n                        options\\n                    );\\n                }\\n\\n            }\\n\\n            // match if directive for else/elif directive\\n            var elseDirective = aElement.directives['else'] || aElement.directives.elif; // eslint-disable-line dot-notation\\n            if (elseDirective) {\\n                var parentChildrenLen = currentNode.children.length;\\n\\n                while (parentChildrenLen--) {\\n                    var parentChild = currentNode.children[parentChildrenLen];\\n                    if (parentChild.textExpr) {\\n                        currentNode.children.splice(parentChildrenLen, 1);\\n                        continue;\\n                    }\\n\\n                    // #[begin] error\\n                    if (!parentChild.directives['if']) { // eslint-disable-line dot-notation\\n                        throw new Error('[SAN FATEL] else not match if.');\\n                    }\\n                    // #[end]\\n\\n                    parentChild.elses = parentChild.elses || [];\\n                    parentChild.elses.push(aElement);\\n\\n                    break;\\n                }\\n            }\\n            else {\\n                if (aElement.tagName === 'tr' && currentNode.tagName === 'table') {\\n                    var tbodyNode = createANode({\\n                        tagName: 'tbody'\\n                    });\\n                    currentNode.children.push(tbodyNode);\\n                    currentNode = tbodyNode;\\n                    stack[++stackIndex] = tbodyNode;\\n                }\\n\\n                currentNode.children.push(aElement);\\n            }\\n\\n            if (!tagClose) {\\n                currentNode = aElement;\\n                stack[++stackIndex] = aElement;\\n            }\\n        }\\n\\n        beforeLastIndex = walker.index;\\n    }\\n\\n    pushTextNode(walker.cut(beforeLastIndex));\\n\\n    return rootNode;\\n\\n    /**\\n     * 在读取栈中添加文本节点\\n     *\\n     * @inner\\n     * @param {string} text 文本内容\\n     */\\n    function pushTextNode(text) {\\n        switch (options.trimWhitespace) {\\n            case 'blank':\\n                if (/^\\\\s+$/.test(text)) {\\n                    text = null;\\n                }\\n                break;\\n\\n            case 'all':\\n                text = text.replace(/(^\\\\s+|\\\\s+$)/g, '');\\n                break;\\n        }\\n\\n        if (text) {\\n            currentNode.children.push(createANode({\\n                textExpr: parseText(text, options.delimiters)\\n            }));\\n        }\\n    }\\n}\\n\\n/* eslint-enable fecs-max-statements */\\n\\n// exports = module.exports = parseTemplate;\\n\\n\\n/**\\n * @file 默认filter\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/* eslint-disable fecs-camelcase */\\n/* eslint-disable guard-for-in */\\n\\n/**\\n * 默认filter\\n *\\n * @const\\n * @type {Object}\\n */\\nvar DEFAULT_FILTERS = {\\n\\n    /**\\n     * URL编码filter\\n     *\\n     * @param {string} source 源串\\n     * @return {string} 替换结果串\\n     */\\n    url: encodeURIComponent,\\n\\n    _class: function (source) {\\n        if (source instanceof Array) {\\n            return source.join(' ');\\n        }\\n\\n        return source;\\n    },\\n\\n    _style: function (source) {\\n        if (typeof source === 'object') {\\n            var result = '';\\n            for (var key in source) {\\n                result += key + ':' + source[key] + ';';\\n            }\\n\\n            return result;\\n        }\\n\\n        return source;\\n    },\\n\\n    _sep: function (source, sep) {\\n        return source ? sep + source : source;\\n    }\\n};\\n/* eslint-enable fecs-camelcase */\\n\\n// exports = module.exports = DEFAULT_FILTERS;\\n\\n\\n/**\\n * @file 表达式计算\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('../parser/expr-type');\\n// var DEFAULT_FILTERS = require('./default-filters');\\n// var evalArgs = require('./eval-args');\\n// var dataCache = require('./data-cache');\\n\\n/**\\n * 计算表达式的值\\n *\\n * @param {Object} expr 表达式对象\\n * @param {Data} data 数据容器对象\\n * @param {Component=} owner 所属组件环境\\n * @return {*}\\n */\\nfunction evalExpr(expr, data, owner) {\\n    if (expr.value != null) {\\n        return expr.value;\\n    }\\n\\n    var value = dataCache.get(data, expr);\\n\\n    if (value == null) {\\n        switch (expr.type) {\\n            case ExprType.UNARY:\\n                value = !evalExpr(expr.expr, data, owner);\\n                break;\\n\\n            case ExprType.BINARY:\\n                var leftValue = evalExpr(expr.segs[0], data, owner);\\n                var rightValue = evalExpr(expr.segs[1], data, owner);\\n\\n                /* eslint-disable eqeqeq */\\n                switch (expr.operator) {\\n                    case 37:\\n                        value = leftValue % rightValue;\\n                        break;\\n                    case 43:\\n                        value = leftValue + rightValue;\\n                        break;\\n                    case 45:\\n                        value = leftValue - rightValue;\\n                        break;\\n                    case 42:\\n                        value = leftValue * rightValue;\\n                        break;\\n                    case 47:\\n                        value = leftValue / rightValue;\\n                        break;\\n                    case 60:\\n                        value = leftValue < rightValue;\\n                        break;\\n                    case 62:\\n                        value = leftValue > rightValue;\\n                        break;\\n                    case 76:\\n                        value = leftValue && rightValue;\\n                        break;\\n                    case 94:\\n                        value = leftValue != rightValue;\\n                        break;\\n                    case 121:\\n                        value = leftValue <= rightValue;\\n                        break;\\n                    case 122:\\n                        value = leftValue == rightValue;\\n                        break;\\n                    case 123:\\n                        value = leftValue >= rightValue;\\n                        break;\\n                    case 155:\\n                        value = leftValue !== rightValue;\\n                        break;\\n                    case 183:\\n                        value = leftValue === rightValue;\\n                        break;\\n                    case 248:\\n                        value = leftValue || rightValue;\\n                        break;\\n                }\\n                /* eslint-enable eqeqeq */\\n                break;\\n\\n            case ExprType.TERTIARY:\\n                value = evalExpr(\\n                    expr.segs[evalExpr(expr.segs[0], data, owner) ? 1 : 2],\\n                    data,\\n                    owner\\n                );\\n                break;\\n\\n            case ExprType.ACCESSOR:\\n                value = data.get(expr);\\n                break;\\n\\n            case ExprType.INTERP:\\n                value = evalExpr(expr.expr, data, owner);\\n\\n                if (owner) {\\n                    for (var i = 0, l = expr.filters.length; i < l; i++) {\\n                        var filter = expr.filters[i];\\n                        var filterName = filter.name.paths[0].value;\\n\\n                        if (owner.filters[filterName]) {\\n                            value = owner.filters[filterName].apply(\\n                                owner,\\n                                [value].concat(evalArgs(filter.args, data, owner))\\n                            );\\n                        }\\n                        else if (DEFAULT_FILTERS[filterName]) {\\n                            value = DEFAULT_FILTERS[filterName](\\n                                value,\\n                                filter.args[0] ? filter.args[0].value : ''\\n                            );\\n                        }\\n                    }\\n                }\\n\\n                if (value == null) {\\n                    value = '';\\n                }\\n\\n                break;\\n\\n            /* eslint-disable no-redeclare */\\n            case ExprType.TEXT:\\n                var buf = '';\\n                for (var i = 0, l = expr.segs.length; i < l; i++) {\\n                    var seg = expr.segs[i];\\n                    buf += seg.value || evalExpr(seg, data, owner);\\n                }\\n                return buf;\\n        }\\n\\n        dataCache.set(data, expr, value);\\n    }\\n\\n    return value;\\n}\\n\\n// exports = module.exports = evalExpr;\\n\\n\\n/**\\n * @file 为函数调用计算参数数组的值\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var evalExpr = require('../runtime/eval-expr');\\n\\n/**\\n * 为函数调用计算参数数组的值\\n *\\n * @param {Array} args 参数表达式列表\\n * @param {Data} data 数据环境\\n * @param {Component} owner 组件环境\\n * @return {Array}\\n */\\nfunction evalArgs(args, data, owner) {\\n    var result = [];\\n    for (var i = 0; i < args.length; i++) {\\n        result.push(evalExpr(args[i], data, owner));\\n    }\\n\\n    return result;\\n}\\n\\n// exports = module.exports = evalArgs;\\n\\n\\n/**\\n * @file 数据缓存管理器\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n\\nvar dataCacheSource = {};\\nvar dataCacheClearly = 1;\\n\\n/**\\n * 数据缓存管理器\\n *\\n * @const\\n * @type {Object}\\n */\\nvar dataCache = {\\n    clear: function () {\\n        if (!dataCacheClearly) {\\n            dataCacheClearly = 1;\\n            dataCacheSource = {};\\n        }\\n    },\\n\\n    set: function (data, expr, value) {\\n        if (expr.raw) {\\n            dataCacheClearly = 0;\\n            (dataCacheSource[data.id] = dataCacheSource[data.id] || {})[expr.raw] = value;\\n        }\\n    },\\n\\n    get: function (data, expr) {\\n        if (expr.raw && dataCacheSource[data.id]) {\\n            return dataCacheSource[data.id][expr.raw];\\n        }\\n    }\\n};\\n\\n\\n// exports = module.exports = dataCache;\\n\\n\\n/**\\n * @file 比较变更表达式与目标表达式之间的关系\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('../parser/expr-type');\\n// var evalExpr = require('./eval-expr');\\n// var each = require('../util/each');\\n\\n/**\\n * 判断变更表达式与多个表达式之间的关系，0为完全没关系，1为有关系\\n *\\n * @inner\\n * @param {Object} changeExpr 目标表达式\\n * @param {Array} exprs 多个源表达式\\n * @param {Data} data 表达式所属数据环境\\n * @return {number}\\n */\\nfunction changeExprCompareExprs(changeExpr, exprs, data) {\\n    for (var i = 0, l = exprs.length; i < l; i++) {\\n        if (changeExprCompare(changeExpr, exprs[i], data)) {\\n            return 1;\\n        }\\n    }\\n\\n    return 0;\\n}\\n\\n/**\\n * 比较变更表达式与目标表达式之间的关系，用于视图更新判断\\n * 视图更新需要根据其关系，做出相应的更新行为\\n *\\n * 0: 完全没关系\\n * 1: 变更表达式是目标表达式的母项(如a与a.b) 或 表示需要完全变化\\n * 2: 变更表达式是目标表达式相等\\n * >2: 变更表达式是目标表达式的子项，如a.b.c与a.b\\n *\\n * @param {Object} changeExpr 变更表达式\\n * @param {Object} expr 要比较的目标表达式\\n * @param {Data} data 表达式所属数据环境\\n * @return {number}\\n */\\nfunction changeExprCompare(changeExpr, expr, data) {\\n    switch (expr.type) {\\n        case ExprType.ACCESSOR:\\n            var paths = expr.paths;\\n            var len = paths.length;\\n            var changePaths = changeExpr.paths;\\n            var changeLen = changePaths.length;\\n\\n            var result = 1;\\n            for (var i = 0; i < len; i++) {\\n                var pathExpr = paths[i];\\n\\n                if (pathExpr.type === ExprType.ACCESSOR\\n                    && changeExprCompare(changeExpr, pathExpr, data)\\n                ) {\\n                    return 1;\\n                }\\n\\n                if (result && i < changeLen\\n                    /* eslint-disable eqeqeq */\\n                    && (pathExpr.value || evalExpr(pathExpr, data))\\n                        != (changePaths[i].value || evalExpr(changePaths[i], data))\\n                    /* eslint-enable eqeqeq */\\n                ) {\\n                    result = 0;\\n                }\\n            }\\n\\n            if (result) {\\n                result = Math.max(1, changeLen - len + 2);\\n            }\\n            return result;\\n\\n        case ExprType.UNARY:\\n            return changeExprCompare(changeExpr, expr.expr, data) ? 1 : 0;\\n\\n\\n        case ExprType.TEXT:\\n        case ExprType.BINARY:\\n        case ExprType.TERTIARY:\\n            return changeExprCompareExprs(changeExpr, expr.segs, data);\\n\\n        case ExprType.INTERP:\\n            if (!changeExprCompare(changeExpr, expr.expr, data)) {\\n                var filterResult;\\n                each(expr.filters, function (filter) {\\n                    filterResult = changeExprCompareExprs(changeExpr, filter.args, data);\\n                    return !filterResult;\\n                });\\n\\n                return filterResult ? 1 : 0;\\n            }\\n\\n            return 1;\\n    }\\n\\n    return 0;\\n}\\n\\n// exports = module.exports = changeExprCompare;\\n\\n\\n/**\\n * @file 数据变更类型枚举\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 数据变更类型枚举\\n *\\n * @const\\n * @type {Object}\\n */\\nvar DataChangeType = {\\n    SET: 1,\\n    SPLICE: 2\\n};\\n\\n// exports = module.exports = DataChangeType;\\n\\n\\n/**\\n * @file 生命周期类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\nfunction lifeCycleOwnIs(name) {\\n    return this[name];\\n}\\n\\n/* eslint-disable fecs-valid-var-jsdoc */\\n/**\\n * 节点生命周期信息\\n *\\n * @inner\\n * @type {Object}\\n */\\nvar LifeCycle = {\\n    start: {},\\n\\n    compiled: {\\n        is: lifeCycleOwnIs,\\n        compiled: true\\n    },\\n\\n    inited: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true\\n    },\\n\\n    painting: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true,\\n        painting: true\\n    },\\n\\n    created: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true,\\n        created: true\\n    },\\n\\n    attached: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true,\\n        created: true,\\n        attached: true\\n    },\\n\\n    leaving: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true,\\n        created: true,\\n        attached: true,\\n        leaving: true\\n    },\\n\\n    detached: {\\n        is: lifeCycleOwnIs,\\n        compiled: true,\\n        inited: true,\\n        created: true,\\n        detached: true\\n    },\\n\\n    disposed: {\\n        is: lifeCycleOwnIs,\\n        disposed: true\\n    }\\n};\\n/* eslint-enable fecs-valid-var-jsdoc */\\n\\n\\n// exports = module.exports = LifeCycle;\\n\\n\\n/**\\n * @file 节点类型\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 节点类型\\n *\\n * @const\\n * @type {Object}\\n */\\nvar NodeType = {\\n    TEXT: 1,\\n    IF: 2,\\n    FOR: 3,\\n    ELEM: 4,\\n    CMPT: 5,\\n    SLOT: 6,\\n    TPL: 7\\n};\\n\\n// exports = module.exports = NodeType;\\n\\n\\n/**\\n * @file 获取 ANode props 数组中相应 name 的项\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 获取 ANode props 数组中相应 name 的项\\n *\\n * @param {Object} aNode ANode对象\\n * @param {string} name name属性匹配串\\n * @return {Object}\\n */\\nfunction getANodeProp(aNode, name) {\\n    var index = aNode.hotspot.props[name];\\n    if (index != null) {\\n        return aNode.props[index];\\n    }\\n}\\n\\n// exports = module.exports = getANodeProp;\\n\\n\\n/**\\n * @file 获取属性处理对象\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var contains = require('../util/contains');\\n// var empty = require('../util/empty');\\n// var svgTags = require('../browser/svg-tags');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var getANodeProp = require('./get-a-node-prop');\\n// var NodeType = require('./node-type');\\n\\n\\n/**\\n * HTML 属性和 DOM 操作属性的对照表\\n *\\n * @inner\\n * @const\\n * @type {Object}\\n */\\nvar HTML_ATTR_PROP_MAP = {\\n    'readonly': 'readOnly',\\n    'cellpadding': 'cellPadding',\\n    'cellspacing': 'cellSpacing',\\n    'colspan': 'colSpan',\\n    'rowspan': 'rowSpan',\\n    'valign': 'vAlign',\\n    'usemap': 'useMap',\\n    'frameborder': 'frameBorder',\\n    'for': 'htmlFor'\\n};\\n\\n/**\\n * 默认的元素的属性设置的变换方法\\n *\\n * @inner\\n * @type {Object}\\n */\\nvar defaultElementPropHandler = {\\n    prop: function (el, value, name, element) {\\n        var propName = HTML_ATTR_PROP_MAP[name] || name;\\n\\n        // input 的 type 是个特殊属性，其实也应该用 setAttribute\\n        // 但是 type 不应该运行时动态改变，否则会有兼容性问题\\n        // 所以这里直接就不管了\\n        if (propName in el) {\\n            el[propName] = value == null ? '' : value;\\n        }\\n        else {\\n            el.setAttribute(name, value);\\n        }\\n\\n        // attribute 绑定的是 text，所以不会出现 null 的情况，这里无需处理\\n        // 换句话来说，san 是做不到 attribute 时有时无的\\n        // if (value == null) {\\n        //     el.removeAttribute(name);\\n        // }\\n    },\\n\\n    output: function (element, bindInfo, data) {\\n        data.set(bindInfo.expr, element.el[bindInfo.name], {\\n            target: {\\n                id: element.id,\\n                prop: bindInfo.name\\n            }\\n        });\\n    }\\n};\\n\\nvar svgPropHandler = {\\n    prop: function (el, value, name) {\\n        el.setAttribute(name, value);\\n    }\\n};\\n\\nvar boolPropHandler = {\\n    prop: function (el, value, name, element, prop) {\\n        var propName = HTML_ATTR_PROP_MAP[name] || name;\\n        el[propName] = !!(prop && prop.raw === ''\\n            || value && value !== 'false' && value !== '0');\\n    }\\n};\\n\\n/* eslint-disable fecs-properties-quote */\\n/**\\n * 默认的属性设置变换方法\\n *\\n * @inner\\n * @type {Object}\\n */\\nvar defaultElementPropHandlers = {\\n    style: {\\n        prop: function (el, value) {\\n            el.style.cssText = value;\\n        }\\n    },\\n\\n    'class': { // eslint-disable-line\\n        prop: function (el, value) {\\n            el.className = value;\\n        }\\n    },\\n\\n    slot: {\\n        prop: empty\\n    },\\n\\n    readonly: boolPropHandler,\\n    disabled: boolPropHandler,\\n    autofocus: boolPropHandler,\\n    required: boolPropHandler,\\n    draggable: boolPropHandler\\n};\\n/* eslint-enable fecs-properties-quote */\\n\\nvar analInputChecker = {\\n    checkbox: contains,\\n    radio: function (a, b) {\\n        return a === b;\\n    }\\n};\\n\\nfunction analInputCheckedState(element, value, oper) {\\n    var bindValue = getANodeProp(element.aNode, 'value');\\n    var bindType = getANodeProp(element.aNode, 'type');\\n\\n    if (bindValue && bindType) {\\n        var type = evalExpr(bindType.expr, element.scope, element.owner);\\n\\n        if (analInputChecker[type]) {\\n            var bindChecked = getANodeProp(element.aNode, 'checked');\\n            if (!bindChecked.hintExpr) {\\n                bindChecked.hintExpr = bindValue.expr;\\n            }\\n\\n            return !!analInputChecker[type](\\n                value,\\n                evalExpr(bindValue.expr, element.scope, element.owner)\\n            );\\n        }\\n    }\\n}\\n\\nvar elementPropHandlers = {\\n    input: {\\n        multiple: boolPropHandler,\\n        checked: {\\n            prop: function (el, value, name, element) {\\n                var state = analInputCheckedState(element, value);\\n\\n                boolPropHandler.prop(\\n                    el,\\n                    state != null ? state : value,\\n                    'checked',\\n                    element\\n                );\\n            },\\n\\n            output: function (element, bindInfo, data) {\\n                var el = element.el;\\n                var bindValue = getANodeProp(element.aNode, 'value');\\n                var bindType = getANodeProp(element.aNode, 'type') || {};\\n\\n                if (bindValue && bindType) {\\n                    switch (bindType.raw) {\\n                        case 'checkbox':\\n                            data[el.checked ? 'push' : 'remove'](bindInfo.expr, el.value);\\n                            return;\\n\\n                        case 'radio':\\n                            el.checked && data.set(bindInfo.expr, el.value, {\\n                                target: {\\n                                    id: element.id,\\n                                    prop: bindInfo.name\\n                                }\\n                            });\\n                            return;\\n                    }\\n                }\\n\\n                defaultElementPropHandler.output(element, bindInfo, data);\\n            }\\n        }\\n    },\\n\\n    option: {\\n        value: {\\n            prop: function (el, value, name, element) {\\n                defaultElementPropHandler.prop(el, value, name, element);\\n\\n                if (isOptionSelected(element, value)) {\\n                    el.selected = true;\\n                }\\n            }\\n        }\\n    },\\n\\n    select: {\\n        value: {\\n            prop: function (el, value) {\\n                el.value = value || '';\\n            },\\n\\n            output: defaultElementPropHandler.output\\n        }\\n    }\\n};\\n\\nfunction isOptionSelected(element, value) {\\n    var parentSelect = element.parent;\\n    while (parentSelect) {\\n        if (parentSelect.tagName === 'select') {\\n            break;\\n        }\\n\\n        parentSelect = parentSelect.parent;\\n    }\\n\\n\\n    if (parentSelect) {\\n        var selectValue = null;\\n        var prop;\\n        var expr;\\n\\n        if ((prop = getANodeProp(parentSelect.aNode, 'value'))\\n            && (expr = prop.expr)\\n        ) {\\n            selectValue = parentSelect.nodeType === NodeType.CMPT\\n                ? evalExpr(expr, parentSelect.data, parentSelect)\\n                : evalExpr(expr, parentSelect.scope, parentSelect.owner)\\n                || '';\\n        }\\n\\n        if (selectValue === value) {\\n            return 1;\\n        }\\n    }\\n}\\n\\n\\n/**\\n * 获取属性处理对象\\n *\\n * @param {string} tagName 元素tag\\n * @param {string} attrName 属性名\\n * @return {Object}\\n */\\nfunction getPropHandler(tagName, attrName) {\\n    if (svgTags[tagName]) {\\n        return svgPropHandler;\\n    }\\n\\n    var tagPropHandlers = elementPropHandlers[tagName];\\n    if (!tagPropHandlers) {\\n        tagPropHandlers = elementPropHandlers[tagName] = {};\\n    }\\n\\n    var propHandler = tagPropHandlers[attrName];\\n    if (!propHandler) {\\n        propHandler = defaultElementPropHandlers[attrName] || defaultElementPropHandler;\\n        tagPropHandlers[attrName] = propHandler;\\n    }\\n\\n    return propHandler;\\n}\\n\\n// exports = module.exports = getPropHandler;\\n\\n\\n/**\\n * @file 判断变更是否来源于元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 判断变更是否来源于元素，来源于元素时，视图更新需要阻断\\n *\\n * @param {Object} change 变更对象\\n * @param {Element} element 元素\\n * @param {string?} propName 属性名，可选。需要精确判断是否来源于此属性时传入\\n * @return {boolean}\\n */\\nfunction isDataChangeByElement(change, element, propName) {\\n    var changeTarget = change.option.target;\\n    return changeTarget && changeTarget.id === element.id\\n        && (!propName || changeTarget.prop === propName);\\n}\\n\\n// exports = module.exports = isDataChangeByElement;\\n\\n\\n/**\\n * @file 在对象上使用accessor表达式查找方法\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var evalExpr = require('../runtime/eval-expr');\\n\\n/**\\n * 在对象上使用accessor表达式查找方法\\n *\\n * @param {Object} source 源对象\\n * @param {Object} nameExpr 表达式\\n * @param {Data} data 所属数据环境\\n * @return {Function}\\n */\\nfunction findMethod(source, nameExpr, data) {\\n    var method = source;\\n\\n    for (var i = 0; method != null && i < nameExpr.paths.length; i++) {\\n        method = method[evalExpr(nameExpr.paths[i], data)];\\n    }\\n\\n    return method;\\n}\\n\\n// exports = module.exports = findMethod;\\n\\n\\n/**\\n * @file 数据类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('../parser/expr-type');\\n// var evalExpr = require('./eval-expr');\\n// var DataChangeType = require('./data-change-type');\\n// var createAccessor = require('../parser/create-accessor');\\n// var parseExpr = require('../parser/parse-expr');\\n// var guid = require('../util/guid');\\n// var dataCache = require('./data-cache');\\n\\n/**\\n * 数据类\\n *\\n * @class\\n * @param {Object?} data 初始数据\\n * @param {Model?} parent 父级数据容器\\n */\\nfunction Data(data, parent) {\\n    this.id = guid();\\n    this.parent = parent;\\n    this.raw = data || {};\\n    this.listeners = [];\\n}\\n\\n// #[begin] error\\n// 以下两个函数只在开发模式下可用，在生产模式下不存在\\n/**\\n * DataTypes 检测\\n */\\nData.prototype.checkDataTypes = function () {\\n    if (this.typeChecker) {\\n        this.typeChecker(this.raw);\\n    }\\n};\\n\\n/**\\n * 设置 type checker\\n *\\n * @param  {Function} typeChecker 类型校验器\\n */\\nData.prototype.setTypeChecker = function (typeChecker) {\\n    this.typeChecker = typeChecker;\\n};\\n\\n// #[end]\\n\\n/**\\n * 添加数据变更的事件监听器\\n *\\n * @param {Function} listener 监听函数\\n */\\nData.prototype.listen = function (listener) {\\n    if (typeof listener === 'function') {\\n        this.listeners.push(listener);\\n    }\\n};\\n\\n/**\\n * 移除数据变更的事件监听器\\n *\\n * @param {Function} listener 监听函数\\n */\\nData.prototype.unlisten = function (listener) {\\n    var len = this.listeners.length;\\n    while (len--) {\\n        if (!listener || this.listeners[len] === listener) {\\n            this.listeners.splice(len, 1);\\n        }\\n    }\\n};\\n\\n/**\\n * 触发数据变更\\n *\\n * @param {Object} change 变更信息对象\\n */\\nData.prototype.fire = function (change) {\\n    if (change.option.silent || change.option.silence || change.option.quiet) {\\n        return;\\n    }\\n\\n    for (var i = 0; i < this.listeners.length; i++) {\\n        this.listeners[i].call(this, change);\\n    }\\n};\\n\\n/**\\n * 获取数据项\\n *\\n * @param {string|Object?} expr 数据项路径\\n * @param {Data?} callee 当前数据获取的调用环境\\n * @return {*}\\n */\\nData.prototype.get = function (expr, callee) {\\n    var value = this.raw;\\n    if (!expr) {\\n        return value;\\n    }\\n\\n    expr = parseExpr(expr);\\n\\n    var paths = expr.paths;\\n    callee = callee || this;\\n\\n    value = value[paths[0].value];\\n\\n    if (value == null && this.parent) {\\n        value = this.parent.get(expr, callee);\\n    }\\n    else {\\n        for (var i = 1, l = paths.length; value != null && i < l; i++) {\\n            value = value[paths[i].value || evalExpr(paths[i], callee)];\\n        }\\n    }\\n\\n    return value;\\n};\\n\\n\\n/**\\n * 数据对象变更操作\\n *\\n * @inner\\n * @param {Object|Array} source 要变更的源数据\\n * @param {Array} exprPaths 属性路径\\n * @param {*} value 变更属性值\\n * @param {Data} data 对应的Data对象\\n * @return {*} 变更后的新数据\\n */\\nfunction immutableSet(source, exprPaths, value, data) {\\n    if (exprPaths.length === 0) {\\n        return value;\\n    }\\n\\n    var prop = evalExpr(exprPaths[0], data);\\n    var result;\\n\\n    if (source instanceof Array) {\\n        var index = +prop;\\n\\n        result = source.slice(0);\\n        result[isNaN(index) ? prop : index] = immutableSet(source[index], exprPaths.slice(1), value, data);\\n\\n        return result;\\n    }\\n    else if (typeof source === 'object') {\\n        result = {};\\n\\n        for (var key in source) {\\n            if (key !== prop) {\\n                result[key] = source[key];\\n            }\\n        }\\n\\n        result[prop] = immutableSet(source[prop] || {}, exprPaths.slice(1), value, data);\\n\\n        return result;\\n    }\\n\\n    return source;\\n}\\n\\n/**\\n * 设置数据项\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {*} value 数据值\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n */\\nData.prototype.set = function (expr, value, option) {\\n    option = option || {};\\n\\n    // #[begin] error\\n    var exprRaw = expr;\\n    // #[end]\\n\\n    expr = parseExpr(expr);\\n\\n    // #[begin] error\\n    if (expr.type !== ExprType.ACCESSOR) {\\n        throw new Error('[SAN ERROR] Invalid Expression in Data set: ' + exprRaw);\\n    }\\n    // #[end]\\n\\n    if (this.get(expr) === value && !option.force) {\\n        return;\\n    }\\n\\n    dataCache.clear();\\n    this.raw = immutableSet(this.raw, expr.paths, value, this);\\n    this.fire({\\n        type: DataChangeType.SET,\\n        expr: expr,\\n        value: value,\\n        option: option\\n    });\\n\\n    // #[begin] error\\n    this.checkDataTypes();\\n    // #[end]\\n\\n};\\n\\n/**\\n * 合并更新数据项\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {Object} source 待合并的数据值\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n */\\nData.prototype.merge = function (expr, source, option) {\\n    option = option || {};\\n\\n    // #[begin] error\\n    var exprRaw = expr;\\n    // #[end]\\n\\n    expr = parseExpr(expr);\\n\\n    // #[begin] error\\n    if (expr.type !== ExprType.ACCESSOR) {\\n        throw new Error('[SAN ERROR] Invalid Expression in Data merge: ' + exprRaw);\\n    }\\n\\n    if (typeof this.get(expr) !== 'object') {\\n        throw new Error('[SAN ERROR] Merge Expects a Target of Type \\\\'object\\\\'; got ' + typeof oldValue);\\n    }\\n\\n    if (typeof source !== 'object') {\\n        throw new Error('[SAN ERROR] Merge Expects a Source of Type \\\\'object\\\\'; got ' + typeof source);\\n    }\\n    // #[end]\\n\\n    for (var key in source) { // eslint-disable-line\\n        this.set(\\n            createAccessor(\\n                expr.paths.concat(\\n                    [\\n                        {\\n                            type: ExprType.STRING,\\n                            value: key\\n                        }\\n                    ]\\n                )\\n            ),\\n            source[key],\\n            option\\n        );\\n    }\\n};\\n\\n/**\\n * 基于更新函数更新数据项\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {Function} fn 数据处理函数\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n */\\nData.prototype.apply = function (expr, fn, option) {\\n    // #[begin] error\\n    var exprRaw = expr;\\n    // #[end]\\n\\n    expr = parseExpr(expr);\\n\\n    // #[begin] error\\n    if (expr.type !== ExprType.ACCESSOR) {\\n        throw new Error('[SAN ERROR] Invalid Expression in Data apply: ' + exprRaw);\\n    }\\n    // #[end]\\n\\n    var oldValue = this.get(expr);\\n\\n    // #[begin] error\\n    if (typeof fn !== 'function') {\\n        throw new Error(\\n            '[SAN ERROR] Invalid Argument\\\\'s Type in Data apply: '\\n            + 'Expected Function but got ' + typeof fn\\n        );\\n    }\\n    // #[end]\\n\\n    this.set(expr, fn(oldValue), option);\\n};\\n\\n/**\\n * 数组数据项splice操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {Array} args splice 接受的参数列表，数组项与Array.prototype.splice的参数一致\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n * @return {Array} 新数组\\n */\\nData.prototype.splice = function (expr, args, option) {\\n    option = option || {};\\n    // #[begin] error\\n    var exprRaw = expr;\\n    // #[end]\\n\\n    expr = parseExpr(expr);\\n\\n    // #[begin] error\\n    if (expr.type !== ExprType.ACCESSOR) {\\n        throw new Error('[SAN ERROR] Invalid Expression in Data splice: ' + exprRaw);\\n    }\\n    // #[end]\\n\\n    var target = this.get(expr);\\n    var returnValue = [];\\n\\n    if (target instanceof Array) {\\n        var index = args[0];\\n        if (index < 0 || index > target.length) {\\n            return;\\n        }\\n\\n        var newArray = target.slice(0);\\n        returnValue = newArray.splice.apply(newArray, args);\\n        dataCache.clear();\\n        this.raw = immutableSet(this.raw, expr.paths, newArray, this);\\n\\n        this.fire({\\n            expr: expr,\\n            type: DataChangeType.SPLICE,\\n            index: index,\\n            deleteCount: returnValue.length,\\n            value: returnValue,\\n            insertions: args.slice(2),\\n            option: option\\n        });\\n    }\\n\\n    // #[begin] error\\n    this.checkDataTypes();\\n    // #[end]\\n\\n    return returnValue;\\n};\\n\\n/**\\n * 数组数据项push操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {*} item 要push的值\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n * @return {number} 新数组的length属性\\n */\\nData.prototype.push = function (expr, item, option) {\\n    var target = this.get(expr);\\n\\n    if (target instanceof Array) {\\n        this.splice(expr, [target.length, 0, item], option);\\n        return target.length + 1;\\n    }\\n};\\n\\n/**\\n * 数组数据项pop操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n * @return {*}\\n */\\nData.prototype.pop = function (expr, option) {\\n    var target = this.get(expr);\\n\\n    if (target instanceof Array) {\\n        var len = target.length;\\n        if (len) {\\n            return this.splice(expr, [len - 1, 1], option)[0];\\n        }\\n    }\\n};\\n\\n/**\\n * 数组数据项shift操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n * @return {*}\\n */\\nData.prototype.shift = function (expr, option) {\\n    return this.splice(expr, [0, 1], option)[0];\\n};\\n\\n/**\\n * 数组数据项unshift操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {*} item 要unshift的值\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n * @return {number} 新数组的length属性\\n */\\nData.prototype.unshift = function (expr, item, option) {\\n    var target = this.get(expr);\\n\\n    if (target instanceof Array) {\\n        this.splice(expr, [0, 0, item], option);\\n        return target.length + 1;\\n    }\\n};\\n\\n/**\\n * 数组数据项移除操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {number} index 要移除项的索引\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n */\\nData.prototype.removeAt = function (expr, index, option) {\\n    this.splice(expr, [index, 1], option);\\n};\\n\\n/**\\n * 数组数据项移除操作\\n *\\n * @param {string|Object} expr 数据项路径\\n * @param {*} value 要移除的项\\n * @param {Object=} option 设置参数\\n * @param {boolean} option.silent 静默设置，不触发变更事件\\n */\\nData.prototype.remove = function (expr, value, option) {\\n    var target = this.get(expr);\\n\\n    if (target instanceof Array) {\\n        var len = target.length;\\n        while (len--) {\\n            if (target[len] === value) {\\n                this.splice(expr, [len, 1], option);\\n                break;\\n            }\\n        }\\n    }\\n};\\n\\n// exports = module.exports = Data;\\n\\n\\n/**\\n * @file 声明式事件的监听函数\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var evalArgs = require('../runtime/eval-args');\\n// var findMethod = require('../runtime/find-method');\\n// var Data = require('../runtime/data');\\n\\n/**\\n * 声明式事件的监听函数\\n *\\n * @param {Object} eventBind 绑定信息对象\\n * @param {boolean} isComponentEvent 是否组件自定义事件\\n * @param {Data} data 数据环境\\n * @param {Event} e 事件对象\\n */\\nfunction eventDeclarationListener(eventBind, isComponentEvent, data, e) {\\n    var method = findMethod(this, eventBind.expr.name, data);\\n\\n    if (typeof method === 'function') {\\n        var scope = new Data(\\n            {$event: isComponentEvent ? e : e || window.event},\\n            data\\n        );\\n        method.apply(this, evalArgs(eventBind.expr.args, scope, this));\\n    }\\n}\\n\\n// exports = module.exports = eventDeclarationListener;\\n\\n\\n/**\\n * @file 自闭合标签表\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var splitStr2Obj = require('../util/split-str-2-obj');\\n\\n/**\\n * 自闭合标签列表\\n *\\n * @type {Object}\\n */\\nvar hotTags = splitStr2Obj('div,span,input,button,textarea,form,label,dl,dt,dd,ul,ol,li,a,b,u,h1,h2,h3,h4,h5,h6');\\n\\n// exports = module.exports = hotTags;\\n\\n\\n/**\\n * @file 是否浏览器环境\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\nvar isBrowser = typeof window !== 'undefined';\\n\\n// exports = module.exports = isBrowser;\\n\\n\\n/**\\n * @file insertBefore 方法的兼容性封装\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * insertBefore 方法的兼容性封装\\n *\\n * @param {HTMLNode} targetEl 要插入的节点\\n * @param {HTMLElement} parentEl 父元素\\n * @param {HTMLElement?} beforeEl 在此元素之前插入\\n */\\nfunction insertBefore(targetEl, parentEl, beforeEl) {\\n    if (parentEl) {\\n        if (beforeEl) {\\n            parentEl.insertBefore(targetEl, beforeEl);\\n        }\\n        else {\\n            parentEl.appendChild(targetEl);\\n        }\\n    }\\n}\\n\\n// exports = module.exports = insertBefore;\\n\\n\\n/**\\n * @file 判断元素是否不允许设置HTML\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// some html elements cannot set innerHTML in old ie\\n// see: https://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\\n\\n/**\\n * 判断元素是否不允许设置HTML\\n *\\n * @param {HTMLElement} el 要判断的元素\\n * @return {boolean}\\n */\\nfunction noSetHTML(el) {\\n    return /^(col|colgroup|frameset|style|table|tbody|tfoot|thead|tr|select)$/i.test(el.tagName);\\n}\\n\\n// exports = module.exports = noSetHTML;\\n\\n\\n/**\\n * @file  获取节点 stump 的 comment\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var noSetHTML = require('../browser/no-set-html');\\n\\n// #[begin] error\\n/**\\n * 获取节点 stump 的 comment\\n *\\n * @param {HTMLElement} el HTML元素\\n */\\nfunction warnSetHTML(el) {\\n    // dont warn if not in browser runtime\\n    if (!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document)) {\\n        return;\\n    }\\n\\n    // some html elements cannot set innerHTML in old ie\\n    // see: https://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\\n    if (noSetHTML(el)) {\\n        var message = '[SAN WARNING] set html for element \\\"' + el.tagName\\n            + '\\\" may cause an error in old IE';\\n        /* eslint-disable no-console */\\n        if (typeof console === 'object' && console.warn) {\\n            console.warn(message);\\n        }\\n        else {\\n            throw new Error(message);\\n        }\\n        /* eslint-enable no-console */\\n    }\\n}\\n// #[end]\\n\\n// exports = module.exports = warnSetHTML;\\n\\n\\n/**\\n * @file 判断是否结束桩\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// #[begin] reverse\\n/**\\n * 判断是否结束桩\\n *\\n * @param {HTMLElement|HTMLComment} target 要判断的元素\\n * @param {string} type 桩类型\\n * @return {boolean}\\n */\\nfunction isEndStump(target, type) {\\n    return target.nodeType === 8 && target.data === '/s-' + type;\\n}\\n// #[end]\\n\\n// exports = module.exports = isEndStump;\\n\\n\\n/**\\n * @file 获取节点在组件树中的路径\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var NodeType = require('./node-type');\\n\\n// #[begin] reverse\\n/**\\n * 获取节点在组件树中的路径\\n *\\n * @param {Node} node 节点对象\\n * @return {Array}\\n */\\nfunction getNodePath(node) {\\n    var nodePaths = [];\\n    var nodeParent = node;\\n    while (nodeParent) {\\n        switch (nodeParent.nodeType) {\\n            case NodeType.ELEM:\\n                nodePaths.unshift(nodeParent.tagName);\\n                break;\\n\\n            case NodeType.IF:\\n                nodePaths.unshift('if');\\n                break;\\n\\n            case NodeType.FOR:\\n                nodePaths.unshift('for[' + nodeParent.anode.directives['for'].raw + ']'); // eslint-disable-line dot-notation\\n                break;\\n\\n            case NodeType.SLOT:\\n                nodePaths.unshift('slot[' + (nodeParent.name || 'default') + ']');\\n                break;\\n\\n            case NodeType.TPL:\\n                nodePaths.unshift('template');\\n                break;\\n\\n            case NodeType.CMPT:\\n                nodePaths.unshift('component[' + (nodeParent.subTag || 'root') + ']');\\n                break;\\n\\n            case NodeType.TEXT:\\n                nodePaths.unshift('text');\\n                break;\\n        }\\n\\n        nodeParent = nodeParent.parent;\\n    }\\n\\n    return nodePaths;\\n}\\n// #[end]\\n\\n// exports = module.exports = getNodePath;\\n\\n\\n/**\\n * @file text 节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var isBrowser = require('../browser/is-browser');\\n// var removeEl = require('../browser/remove-el');\\n// var insertBefore = require('../browser/insert-before');\\n// var changeExprCompare = require('../runtime/change-expr-compare');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var NodeType = require('./node-type');\\n// var warnSetHTML = require('./warn-set-html');\\n// var isEndStump = require('./is-end-stump');\\n// var getNodePath = require('./get-node-path');\\n\\n\\n/**\\n * text 节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction TextNode(aNode, owner, scope, parent, reverseWalker) {\\n    this.aNode = aNode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n        var currentNode = reverseWalker.current;\\n        if (currentNode) {\\n            switch (currentNode.nodeType) {\\n                case 8:\\n                    if (currentNode.data === 's-text') {\\n                        this.sel = currentNode;\\n                        currentNode.data = this.id;\\n                        reverseWalker.goNext();\\n\\n                        while (1) { // eslint-disable-line\\n                            currentNode = reverseWalker.current;\\n                            if (!currentNode) {\\n                                throw new Error('[SAN REVERSE ERROR] Text end flag not found. \\\\nPaths: '\\n                                    + getNodePath(this).join(' > '));\\n                            }\\n\\n                            if (isEndStump(currentNode, 'text')) {\\n                                this.el = currentNode;\\n                                reverseWalker.goNext();\\n                                currentNode.data = this.id;\\n                                break;\\n                            }\\n\\n                            reverseWalker.goNext();\\n                        }\\n                    }\\n                    break;\\n\\n                case 3:\\n                    reverseWalker.goNext();\\n                    if (!this.aNode.textExpr.original) {\\n                        this.el = currentNode;\\n                    }\\n                    break;\\n            }\\n        }\\n        else {\\n            this.el = document.createTextNode('');\\n            insertBefore(this.el, reverseWalker.target, reverseWalker.current);\\n        }\\n    }\\n    // #[end]\\n}\\n\\nTextNode.prototype.nodeType = NodeType.TEXT;\\n\\n/**\\n * 将text attach到页面\\n *\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nTextNode.prototype.attach = function (parentEl, beforeEl) {\\n    this.content = evalExpr(this.aNode.textExpr, this.scope, this.owner);\\n\\n    if (this.aNode.textExpr.original) {\\n        this.sel = document.createComment(this.id);\\n        insertBefore(this.sel, parentEl, beforeEl);\\n\\n        this.el = document.createComment(this.id);\\n        insertBefore(this.el, parentEl, beforeEl);\\n\\n        var tempFlag = document.createElement('script');\\n        parentEl.insertBefore(tempFlag, this.el);\\n        tempFlag.insertAdjacentHTML('beforebegin', this.content);\\n        parentEl.removeChild(tempFlag);\\n    }\\n    else {\\n        this.el = document.createTextNode(this.content);\\n        insertBefore(this.el, parentEl, beforeEl);\\n    }\\n};\\n\\n/**\\n * 销毁 text 节点\\n */\\nTextNode.prototype.dispose = function () {\\n    this._prev = null;\\n    this.el = null;\\n    this.sel = null;\\n};\\n\\nvar textUpdateProp = isBrowser\\n    && (typeof document.createTextNode('').textContent === 'string'\\n        ? 'textContent'\\n        : 'data');\\n\\n/**\\n * 更新 text 节点的视图\\n *\\n * @param {Array} changes 数据变化信息\\n */\\nTextNode.prototype._update = function (changes) {\\n    if (this.aNode.textExpr.value) {\\n        return;\\n    }\\n\\n    var len = changes ? changes.length : 0;\\n    while (len--) {\\n        if (changeExprCompare(changes[len].expr, this.aNode.textExpr, this.scope)) {\\n            var text = evalExpr(this.aNode.textExpr, this.scope, this.owner);\\n\\n            if (text !== this.content) {\\n                this.content = text;\\n\\n                if (this.aNode.textExpr.original) {\\n                    var startRemoveEl = this.sel.nextSibling;\\n                    var parentEl = this.el.parentNode;\\n\\n                    while (startRemoveEl !== this.el) {\\n                        var removeTarget = startRemoveEl;\\n                        startRemoveEl = startRemoveEl.nextSibling;\\n                        removeEl(removeTarget);\\n                    }\\n\\n                    // #[begin] error\\n                    warnSetHTML(parentEl);\\n                    // #[end]\\n\\n                    var tempFlag = document.createElement('script');\\n                    parentEl.insertBefore(tempFlag, this.el);\\n                    tempFlag.insertAdjacentHTML('beforebegin', text);\\n                    parentEl.removeChild(tempFlag);\\n                }\\n                else {\\n                    this.el[textUpdateProp] = text;\\n                }\\n            }\\n\\n            return;\\n        }\\n    }\\n};\\n\\n// exports = module.exports = TextNode;\\n\\n\\n/**\\n * @file 判断变更数组是否影响到数据引用摘要\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 判断变更数组是否影响到数据引用摘要\\n *\\n * @param {Array} changes 变更数组\\n * @param {Object} dataRef 数据引用摘要\\n * @return {boolean}\\n */\\nfunction changesIsInDataRef(changes, dataRef) {\\n    for (var i = 0; i < changes.length; i++) {\\n        var change = changes[i];\\n\\n        if (!change.overview) {\\n            var paths = change.expr.paths;\\n            change.overview = paths[0].value;\\n\\n            if (paths.length > 1) {\\n                change.extOverview = paths[0].value + '.' + paths[1].value;\\n                change.wildOverview = paths[0].value + '.*';\\n            }\\n        }\\n\\n        if (dataRef[change.overview]\\n            || change.wildOverview && dataRef[change.wildOverview]\\n            || change.extOverview && dataRef[change.extOverview]\\n        ) {\\n            return true;\\n        }\\n    }\\n}\\n\\n// exports = module.exports = changesIsInDataRef;\\n\\n\\n/**\\n * @file 元素子节点遍历操作类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var removeEl = require('../browser/remove-el');\\n\\n// #[begin] reverse\\n/**\\n * 元素子节点遍历操作类\\n *\\n * @inner\\n * @class\\n * @param {HTMLElement} el 要遍历的元素\\n */\\nfunction DOMChildrenWalker(el) {\\n    this.raw = [];\\n    this.index = 0;\\n    this.target = el;\\n\\n    var child = el.firstChild;\\n    var next;\\n    while (child) {\\n        next = child.nextSibling;\\n\\n        switch (child.nodeType) {\\n            case 3:\\n                if (/^\\\\s*$/.test(child.data || child.textContent)) {\\n                    removeEl(child);\\n                }\\n                else {\\n                    this.raw.push(child);\\n                }\\n                break;\\n\\n            case 1:\\n            case 8:\\n                this.raw.push(child);\\n        }\\n\\n        child = next;\\n    }\\n\\n    this.current = this.raw[this.index];\\n    this.next = this.raw[this.index + 1];\\n}\\n\\n/**\\n * 往下走一个元素\\n */\\nDOMChildrenWalker.prototype.goNext = function () {\\n    this.current = this.raw[++this.index];\\n    this.next = this.raw[this.index + 1];\\n};\\n// #[end]\\n\\n// exports = module.exports = DOMChildrenWalker;\\n\\n\\n/**\\n * @file 元素节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var removeEl = require('../browser/remove-el');\\n// var changeExprCompare = require('../runtime/change-expr-compare');\\n// var changesIsInDataRef = require('../runtime/changes-is-in-data-ref');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var LifeCycle = require('./life-cycle');\\n// var NodeType = require('./node-type');\\n// var reverseElementChildren = require('./reverse-element-children');\\n// var isDataChangeByElement = require('./is-data-change-by-element');\\n// var elementUpdateChildren = require('./element-update-children');\\n// var elementOwnCreate = require('./element-own-create');\\n// var elementOwnAttach = require('./element-own-attach');\\n// var elementOwnDetach = require('./element-own-detach');\\n// var elementOwnDispose = require('./element-own-dispose');\\n// var elementOwnOnEl = require('./element-own-on-el');\\n// var elementOwnToPhase = require('./element-own-to-phase');\\n// var elementOwnAttached = require('./element-own-attached');\\n// var elementDispose = require('./element-dispose');\\n// var elementInitTagName = require('./element-init-tag-name');\\n// var handleProp = require('./handle-prop');\\n// var warnSetHTML = require('./warn-set-html');\\n// var getNodePath = require('./get-node-path');\\n\\n/**\\n * 元素节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction Element(aNode, owner, scope, parent, reverseWalker) {\\n    this.aNode = aNode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n\\n    this.lifeCycle = LifeCycle.start;\\n    this.children = [];\\n    this._elFns = [];\\n    this.parentComponent = parent.nodeType === NodeType.CMPT\\n        ? parent\\n        : parent.parentComponent;\\n\\n    this.id = guid();\\n\\n    elementInitTagName(this);\\n\\n    this._toPhase('inited');\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n        var currentNode = reverseWalker.current;\\n\\n        if (!currentNode) {\\n            throw new Error('[SAN REVERSE ERROR] Element not found. \\\\nPaths: '\\n                + getNodePath(this).join(' > '));\\n        }\\n\\n        if (currentNode.nodeType !== 1) {\\n            throw new Error('[SAN REVERSE ERROR] Element type not match, expect 1 but '\\n                + currentNode.nodeType + '.\\\\nPaths: '\\n                + getNodePath(this).join(' > '));\\n        }\\n\\n        if (currentNode.tagName.toLowerCase() !== this.tagName) {\\n            throw new Error('[SAN REVERSE ERROR] Element tagName not match, expect '\\n                + this.tagName + ' but meat ' + currentNode.tagName.toLowerCase() + '.\\\\nPaths: '\\n                + getNodePath(this).join(' > '));\\n        }\\n\\n        this.el = currentNode;\\n        reverseWalker.goNext();\\n\\n        reverseElementChildren(this);\\n\\n        this._attached();\\n    }\\n    // #[end]\\n}\\n\\n\\n\\nElement.prototype.nodeType = NodeType.ELEM;\\n\\n\\nElement.prototype.attach = elementOwnAttach;\\nElement.prototype.detach = elementOwnDetach;\\nElement.prototype.dispose = elementOwnDispose;\\nElement.prototype._create = elementOwnCreate;\\nElement.prototype._toPhase = elementOwnToPhase;\\nElement.prototype._onEl = elementOwnOnEl;\\n\\nElement.prototype._doneLeave = function () {\\n    if (this.leaveDispose) {\\n        if (!this.lifeCycle.disposed) {\\n            elementDispose(\\n                this,\\n                this.disposeNoDetach,\\n                this.disposeNoTransition\\n            );\\n        }\\n    }\\n    else if (this.lifeCycle.attached) {\\n        removeEl(this.el);\\n        this._toPhase('detached');\\n    }\\n};\\n\\n/**\\n * 视图更新\\n *\\n * @param {Array} changes 数据变化信息\\n */\\nElement.prototype._update = function (changes) {\\n    if (!changesIsInDataRef(changes, this.aNode.hotspot.data)) {\\n        return;\\n    }\\n\\n    var me = this;\\n\\n    var dynamicProps = this.aNode.hotspot.dynamicProps;\\n    for (var i = 0, l = dynamicProps.length; i < l; i++) {\\n        var prop = dynamicProps[i];\\n\\n        for (var j = 0, changeLen = changes.length; j < changeLen; j++) {\\n            var change = changes[j];\\n\\n            if (!isDataChangeByElement(change, this, prop.name)\\n                && (\\n                    changeExprCompare(change.expr, prop.expr, this.scope)\\n                    || prop.hintExpr && changeExprCompare(change.expr, prop.hintExpr, this.scope)\\n                )\\n            ) {\\n                handleProp(this, evalExpr(prop.expr, this.scope, this.owner), prop);\\n                break;\\n            }\\n        }\\n    }\\n\\n    var htmlDirective = this.aNode.directives.html;\\n    if (htmlDirective) {\\n        each(changes, function (change) {\\n            if (changeExprCompare(change.expr, htmlDirective.value, me.scope)) {\\n                // #[begin] error\\n                warnSetHTML(me.el);\\n                // #[end]\\n                me.el.innerHTML = evalExpr(htmlDirective.value, me.scope, me.owner);\\n                return false;\\n            }\\n        });\\n    }\\n    else {\\n        elementUpdateChildren(this, changes);\\n    }\\n};\\n\\n/**\\n * 执行完成attached状态的行为\\n */\\nElement.prototype._attached = elementOwnAttached;\\n\\n// exports = module.exports = Element;\\n\\n\\n/**\\n * @file 销毁节点，清空节点上的无用成员\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 销毁节点\\n *\\n * @param {Object} node 节点对象\\n */\\nfunction nodeDispose(node) {\\n    node.el = null;\\n    node.sel = null;\\n    node.owner = null;\\n    node.scope = null;\\n    node.aNode = null;\\n    node.parent = null;\\n    node.parentComponent = null;\\n    node.children = null;\\n\\n    if (node._toPhase) {\\n        node._toPhase('disposed');\\n    }\\n\\n    if (node._ondisposed) {\\n        node._ondisposed();\\n    }\\n}\\n\\n// exports = module.exports = nodeDispose;\\n\\n\\n/**\\n * @file 通过组件反解创建节点的工厂方法\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var hotTags = require('../browser/hot-tags');\\n// var NodeType = require('./node-type');\\n// var TextNode = require('./text-node');\\n// var Element = require('./element');\\n// var SlotNode = require('./slot-node');\\n// var ForNode = require('./for-node');\\n// var IfNode = require('./if-node');\\n// var TemplateNode = require('./template-node');\\n\\n// #[begin] reverse\\n/**\\n * 通过组件反解创建节点\\n *\\n * @param {ANode} aNode 抽象节点\\n * @param {DOMChildrenWalker} reverseWalker 子元素遍历对象\\n * @param {Node} parent 父亲节点\\n * @param {Model=} scope 所属数据环境\\n * @return {Node}\\n */\\nfunction createReverseNode(aNode, reverseWalker, parent, scope) {\\n    var parentIsComponent = parent.nodeType === NodeType.CMPT;\\n    var owner = parentIsComponent ? parent : (parent.childOwner || parent.owner);\\n    scope = scope || (parentIsComponent ? parent.data : (parent.childScope || parent.scope));\\n\\n    if (aNode.textExpr) {\\n        return new TextNode(aNode, owner, scope, parent, reverseWalker);\\n    }\\n\\n    if (aNode.directives['if']) { // eslint-disable-line dot-notation\\n        return new IfNode(aNode, owner, scope, parent, reverseWalker);\\n    }\\n\\n    if (aNode.directives['for']) { // eslint-disable-line dot-notation\\n        return new ForNode(aNode, owner, scope, parent, reverseWalker);\\n    }\\n\\n    if (hotTags[aNode.tagName]) {\\n        return new Element(aNode, owner, scope, parent, reverseWalker);\\n    }\\n\\n    switch (aNode.tagName) {\\n        case 'slot':\\n            return new SlotNode(aNode, owner, scope, parent, reverseWalker);\\n\\n        case 'template':\\n            return new TemplateNode(aNode, owner, scope, parent, reverseWalker);\\n\\n        default:\\n            var ComponentType = owner.getComponentType(aNode);\\n            if (ComponentType) {\\n                return new ComponentType({\\n                    aNode: aNode,\\n                    owner: owner,\\n                    scope: scope,\\n                    parent: parent,\\n                    subTag: aNode.tagName,\\n                    reverseWalker: reverseWalker\\n                });\\n            }\\n    }\\n\\n    return new Element(aNode, owner, scope, parent, reverseWalker);\\n}\\n// #[end]\\n\\n// exports = module.exports = createReverseNode;\\n\\n\\n/**\\n * @file 销毁释放元素的子元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 销毁释放元素的子元素\\n *\\n * @param {Object} element 元素节点\\n * @param {boolean=} noDetach 是否不要把节点从dom移除\\n * @param {boolean=} noTransition 是否不显示过渡动画效果\\n */\\nfunction elementDisposeChildren(element, noDetach, noTransition) {\\n    var children = element.children;\\n    var len = children && children.length;\\n    while (len--) {\\n        children[len].dispose(noDetach, noTransition);\\n    }\\n}\\n\\n// exports = module.exports = elementDisposeChildren;\\n\\n\\n/**\\n * @file 更新元素的子元素视图\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n/**\\n * 更新元素的子元素视图\\n *\\n * @param {Object} element 要更新的元素\\n * @param {Array} changes 数据变化信息\\n */\\nfunction elementUpdateChildren(element, changes) {\\n    for (var i = 0, l = element.children.length; i < l; i++) {\\n        element.children[i]._update(changes);\\n    }\\n}\\n\\n// exports = module.exports = elementUpdateChildren;\\n\\n\\n/**\\n * @file 使元素节点到达相应的生命周期\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var LifeCycle = require('./life-cycle');\\n\\n/**\\n * 使元素节点到达相应的生命周期\\n *\\n * @param {string} name 生命周期名称\\n */\\nfunction elementOwnToPhase(name) {\\n    this.lifeCycle = LifeCycle[name] || this.lifeCycle;\\n}\\n\\n// exports = module.exports = elementOwnToPhase;\\n\\n\\n/**\\n * @file 创建节点的工厂方法\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var hotTags = require('../browser/hot-tags');\\n// var NodeType = require('./node-type');\\n// var TextNode = require('./text-node');\\n// var Element = require('./element');\\n// var SlotNode = require('./slot-node');\\n// var ForNode = require('./for-node');\\n// var IfNode = require('./if-node');\\n// var TemplateNode = require('./template-node');\\n\\n\\n/**\\n * 创建节点\\n *\\n * @param {ANode} aNode 抽象节点\\n * @param {Node} parent 父亲节点\\n * @param {Model=} scope 所属数据环境\\n * @return {Node}\\n */\\nfunction createNode(aNode, parent, scope) {\\n    var parentIsComponent = parent.nodeType === NodeType.CMPT;\\n    var owner = parentIsComponent ? parent : (parent.childOwner || parent.owner);\\n    scope = scope || (parentIsComponent ? parent.data : (parent.childScope || parent.scope));\\n\\n\\n    if (aNode.textExpr) {\\n        return new TextNode(aNode, owner, scope, parent);\\n    }\\n\\n    if (aNode.directives['if']) { // eslint-disable-line dot-notation\\n        return new IfNode(aNode, owner, scope, parent);\\n    }\\n\\n    if (aNode.directives['for']) { // eslint-disable-line dot-notation\\n        return new ForNode(aNode, owner, scope, parent);\\n    }\\n\\n    if (hotTags[aNode.tagName]) {\\n        return new Element(aNode, owner, scope, parent);\\n    }\\n\\n\\n\\n    switch (aNode.tagName) {\\n        case 'slot':\\n            return new SlotNode(aNode, owner, scope, parent);\\n\\n        case 'template':\\n            return new TemplateNode(aNode, owner, scope, parent);\\n\\n        default:\\n            var ComponentType = owner.getComponentType(aNode);\\n            if (ComponentType) {\\n                return new ComponentType({\\n                    aNode: aNode,\\n                    owner: owner,\\n                    scope: scope,\\n                    parent: parent,\\n                    subTag: aNode.tagName\\n                });\\n            }\\n    }\\n\\n    return new Element(aNode, owner, scope, parent);\\n}\\n\\n// exports = module.exports = createNode;\\n\\n\\n/**\\n * @file 生成子元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var createNode = require('./create-node');\\n\\n/**\\n * 生成子元素\\n *\\n * @param {Element} element 元素\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nfunction genElementChildren(element, parentEl, beforeEl) {\\n    parentEl = parentEl || element.el;\\n\\n    var aNodeChildren = element.aNode.children;\\n    for (var i = 0; i < aNodeChildren.length; i++) {\\n        var child = createNode(aNodeChildren[i], element);\\n        element.children.push(child);\\n        child.attach(parentEl, beforeEl);\\n    }\\n}\\n\\n// exports = module.exports = genElementChildren;\\n\\n\\n/**\\n * @file 将没有 root 只有 children 的元素 attach 到页面\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var insertBefore = require('../browser/insert-before');\\n// var genElementChildren = require('./gen-element-children');\\n\\n\\n/**\\n * 将没有 root 只有 children 的元素 attach 到页面\\n * 主要用于 slot 和 template\\n *\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nfunction nodeOwnOnlyChildrenAttach(parentEl, beforeEl) {\\n    this.sel = document.createComment(this.id);\\n    insertBefore(this.sel, parentEl, beforeEl);\\n\\n    genElementChildren(this, parentEl, beforeEl);\\n\\n    this.el = document.createComment(this.id);\\n    insertBefore(this.el, parentEl, beforeEl);\\n\\n    this._toPhase('attached');\\n}\\n\\n// exports = module.exports = nodeOwnOnlyChildrenAttach;\\n\\n\\n/**\\n * @file slot 节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var createANode = require('../parser/create-a-node');\\n// var ExprType = require('../parser/expr-type');\\n// var createAccessor = require('../parser/create-accessor');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var Data = require('../runtime/data');\\n// var DataChangeType = require('../runtime/data-change-type');\\n// var changeExprCompare = require('../runtime/change-expr-compare');\\n// var insertBefore = require('../browser/insert-before');\\n// var NodeType = require('./node-type');\\n// var LifeCycle = require('./life-cycle');\\n// var getANodeProp = require('./get-a-node-prop');\\n// var nodeDispose = require('./node-dispose');\\n// var createReverseNode = require('./create-reverse-node');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n// var elementUpdateChildren = require('./element-update-children');\\n// var elementOwnToPhase = require('./element-own-to-phase');\\n// var nodeOwnOnlyChildrenAttach = require('./node-own-only-children-attach');\\n\\n\\n/**\\n * slot 节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction SlotNode(aNode, owner, scope, parent, reverseWalker) {\\n    var realANode = createANode();\\n    this.aNode = realANode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n    this.parentComponent = parent.nodeType === NodeType.CMPT\\n        ? parent\\n        : parent.parentComponent;\\n\\n    this.id = guid();\\n\\n    this.lifeCycle = LifeCycle.start;\\n    this.children = [];\\n\\n    // calc slot name\\n    this.nameBind = getANodeProp(aNode, 'name');\\n    if (this.nameBind) {\\n        this.isNamed = true;\\n        this.name = evalExpr(this.nameBind.expr, this.scope, this.owner);\\n    }\\n\\n    // calc aNode children\\n    var givenSlots = owner.givenSlots;\\n    var givenChildren;\\n    if (givenSlots) {\\n        givenChildren = this.isNamed ? givenSlots.named[this.name] : givenSlots.noname;\\n    }\\n\\n    if (givenChildren) {\\n        this.isInserted = true;\\n    }\\n\\n    realANode.children = givenChildren || aNode.children.slice(0);\\n\\n    var me = this;\\n\\n    // calc scoped slot vars\\n    realANode.vars = aNode.vars;\\n    var initData = {};\\n    each(realANode.vars, function (varItem) {\\n        me.isScoped = true;\\n        initData[varItem.name] = evalExpr(varItem.expr, scope, owner);\\n    });\\n\\n    // child owner & child scope\\n    if (this.isInserted) {\\n        this.childOwner = owner.owner;\\n        this.childScope = owner.scope;\\n    }\\n\\n    if (this.isScoped) {\\n        this.childScope = new Data(initData, this.childScope || this.scope);\\n    }\\n\\n\\n    owner.slotChildren.push(this);\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n\\n        this.sel = document.createComment(this.id);\\n        insertBefore(this.sel, reverseWalker.target, reverseWalker.current);\\n\\n        each(this.aNode.children, function (aNodeChild) {\\n            me.children.push(createReverseNode(aNodeChild, reverseWalker, me));\\n        });\\n\\n        this.el = document.createComment(this.id);\\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\\n\\n        this._toPhase('attached');\\n    }\\n    // #[end]\\n}\\n\\nSlotNode.prototype.nodeType = NodeType.SLOT;\\n\\n/**\\n * 销毁释放 slot\\n *\\n * @param {boolean=} noDetach 是否不要把节点从dom移除\\n * @param {boolean=} noTransition 是否不显示过渡动画效果\\n */\\nSlotNode.prototype.dispose = function (noDetach, noTransition) {\\n    this.childOwner = null;\\n    this.childScope = null;\\n\\n    elementDisposeChildren(this, noDetach, noTransition);\\n    nodeDispose(this);\\n};\\n\\nSlotNode.prototype.attach = nodeOwnOnlyChildrenAttach;\\nSlotNode.prototype._toPhase = elementOwnToPhase;\\n\\n/**\\n * 视图更新函数\\n *\\n * @param {Array} changes 数据变化信息\\n * @param {boolean=} isFromOuter 变化信息是否来源于父组件之外的组件\\n * @return {boolean}\\n */\\nSlotNode.prototype._update = function (changes, isFromOuter) {\\n    var me = this;\\n\\n    if (this.nameBind && evalExpr(this.nameBind.expr, this.scope, this.owner) !== me.name) {\\n        this.owner._notifyNeedReload();\\n        return false;\\n    }\\n\\n    if (isFromOuter) {\\n        if (this.isInserted) {\\n            elementUpdateChildren(this, changes);\\n        }\\n    }\\n    else {\\n        if (this.isScoped) {\\n            each(this.aNode.vars, function (varItem) {\\n                me.childScope.set(varItem.name, evalExpr(varItem.expr, me.scope, me.owner));\\n            });\\n\\n\\n            var scopedChanges = [];\\n            each(changes, function (change) {\\n                if (!me.isInserted) {\\n                    scopedChanges.push(change);\\n                }\\n\\n                each(me.aNode.vars, function (varItem) {\\n                    var name = varItem.name;\\n                    var relation = changeExprCompare(change.expr, varItem.expr, me.scope);\\n\\n                    if (relation < 1) {\\n                        return;\\n                    }\\n\\n                    if (change.type !== DataChangeType.SPLICE) {\\n                        scopedChanges.push({\\n                            type: DataChangeType.SET,\\n                            expr: createAccessor([\\n                                {type: ExprType.STRING, value: name}\\n                            ]),\\n                            value: me.childScope.get(name),\\n                            option: change.option\\n                        });\\n                    }\\n                    else if (relation === 2) {\\n                        scopedChanges.push({\\n                            expr: createAccessor([\\n                                {type: ExprType.STRING, value: name}\\n                            ]),\\n                            type: DataChangeType.SPLICE,\\n                            index: change.index,\\n                            deleteCount: change.deleteCount,\\n                            value: change.value,\\n                            insertions: change.insertions,\\n                            option: change.option\\n                        });\\n                    }\\n                });\\n            });\\n\\n            elementUpdateChildren(this, scopedChanges);\\n        }\\n        else if (!this.isInserted) {\\n            elementUpdateChildren(this, changes);\\n        }\\n    }\\n};\\n\\n// exports = module.exports = SlotNode;\\n\\n\\n/**\\n * @file 复制指令集合对象\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n/**\\n * 复制指令集合对象\\n *\\n * @param {Object} source 要复制的指令集合对象\\n * @param {Object=} excludes 需要排除的key集合\\n * @return {Object}\\n */\\nfunction cloneDirectives(source, excludes) {\\n    var result = {};\\n    excludes = excludes || {};\\n\\n    for (var key in source) {\\n        if (!excludes[key]) {\\n            result[key] = source[key];\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n// exports = module.exports = cloneDirectives;\\n\\n\\n/**\\n * @file 简单执行销毁节点的行为\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var removeEl = require('../browser/remove-el');\\n// var nodeDispose = require('./node-dispose');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n\\n/**\\n * 简单执行销毁节点的行为\\n *\\n * @param {boolean=} noDetach 是否不要把节点从dom移除\\n */\\nfunction nodeOwnSimpleDispose(noDetach) {\\n    elementDisposeChildren(this, noDetach, 1);\\n\\n    if (!noDetach) {\\n        removeEl(this.el);\\n    }\\n\\n    nodeDispose(this);\\n}\\n\\n// exports = module.exports = nodeOwnSimpleDispose;\\n\\n\\n/**\\n * @file 创建节点对应的 stump comment 元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n\\n/**\\n * 创建节点对应的 stump comment 主元素\\n */\\nfunction nodeOwnCreateStump() {\\n    this.el = this.el || document.createComment(this.id);\\n}\\n\\n// exports = module.exports = nodeOwnCreateStump;\\n\\n\\n/**\\n * @file for 指令节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var inherits = require('../util/inherits');\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var createANode = require('../parser/create-a-node');\\n// var ExprType = require('../parser/expr-type');\\n// var parseExpr = require('../parser/parse-expr');\\n// var createAccessor = require('../parser/create-accessor');\\n// var cloneDirectives = require('../parser/clone-directives');\\n// var Data = require('../runtime/data');\\n// var DataChangeType = require('../runtime/data-change-type');\\n// var changeExprCompare = require('../runtime/change-expr-compare');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var changesIsInDataRef = require('../runtime/changes-is-in-data-ref');\\n// var removeEl = require('../browser/remove-el');\\n// var insertBefore = require('../browser/insert-before');\\n// var LifeCycle = require('./life-cycle');\\n// var NodeType = require('./node-type');\\n// var createNode = require('./create-node');\\n// var createReverseNode = require('./create-reverse-node');\\n// var nodeOwnSimpleDispose = require('./node-own-simple-dispose');\\n// var nodeOwnCreateStump = require('./node-own-create-stump');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n// var dataCache = require('../runtime/data-cache');\\n\\n\\n/**\\n * 循环项的数据容器类\\n *\\n * @inner\\n * @class\\n * @param {Object} forElement for元素对象\\n * @param {*} item 当前项的数据\\n * @param {number} index 当前项的索引\\n */\\nfunction ForItemData(forElement, item, index) {\\n    this.id = guid();\\n    this.parent = forElement.scope;\\n    this.raw = {};\\n    this.listeners = [];\\n\\n    this.directive = forElement.aNode.directives['for']; // eslint-disable-line dot-notation\\n    this.raw[this.directive.item.raw] = item;\\n    this.raw[this.directive.index.raw] = index;\\n}\\n\\n/**\\n * 将数据操作的表达式，转换成为对parent数据操作的表达式\\n * 主要是对item和index进行处理\\n *\\n * @param {Object} expr 表达式\\n * @return {Object}\\n */\\nForItemData.prototype.exprResolve = function (expr) {\\n    var directive = this.directive;\\n    var me = this;\\n\\n    function resolveItem(expr) {\\n        if (expr.type === ExprType.ACCESSOR\\n            && expr.paths[0].value === directive.item.paths[0].value\\n        ) {\\n            return createAccessor(\\n                directive.value.paths.concat(\\n                    {\\n                        type: ExprType.NUMBER,\\n                        value: me.get(directive.index)\\n                    },\\n                    expr.paths.slice(1)\\n                )\\n            );\\n        }\\n\\n        return expr;\\n    }\\n\\n    expr = resolveItem(expr);\\n\\n    var resolvedPaths = [];\\n\\n    each(expr.paths, function (item) {\\n        resolvedPaths.push(\\n            item.type === ExprType.ACCESSOR\\n                && item.paths[0].value === directive.index.paths[0].value\\n            ? {\\n                type: ExprType.NUMBER,\\n                value: me.get(directive.index)\\n            }\\n            : resolveItem(item)\\n        );\\n    });\\n\\n    return createAccessor(resolvedPaths);\\n};\\n\\n// 代理数据操作方法\\ninherits(ForItemData, Data);\\neach(\\n    ['set', 'remove', 'unshift', 'shift', 'push', 'pop', 'splice'],\\n    function (method) {\\n        ForItemData.prototype['_' + method] = Data.prototype[method];\\n        ForItemData.prototype[method] = function (expr) {\\n            expr = this.exprResolve(parseExpr(expr));\\n            dataCache.clear();\\n            this.parent[method].apply(\\n                this.parent,\\n                [expr].concat(Array.prototype.slice.call(arguments, 1))\\n            );\\n        };\\n    }\\n);\\n\\n/**\\n * 创建 for 指令元素的子元素\\n *\\n * @inner\\n * @param {ForDirective} forElement for 指令元素对象\\n * @param {*} item 子元素对应数据\\n * @param {number} index 子元素对应序号\\n * @return {Element}\\n */\\nfunction createForDirectiveChild(forElement, item, index) {\\n    var itemScope = new ForItemData(forElement, item, index);\\n    return createNode(forElement.itemANode, forElement, itemScope);\\n}\\n\\n/**\\n * for 指令节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction ForNode(aNode, owner, scope, parent, reverseWalker) {\\n    this.aNode = aNode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n    this.parentComponent = parent.nodeType === NodeType.CMPT\\n        ? parent\\n        : parent.parentComponent;\\n\\n    this.id = guid();\\n    this.children = [];\\n\\n    this.itemANode = createANode({\\n        children: aNode.children,\\n        props: aNode.props,\\n        events: aNode.events,\\n        tagName: aNode.tagName,\\n        vars: aNode.vars,\\n        hotspot: aNode.hotspot,\\n        directives: cloneDirectives(aNode.directives, {\\n            'for': 1\\n        })\\n    });\\n\\n    this.param = aNode.directives['for']; // eslint-disable-line dot-notation\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n        var me = this;\\n        each(\\n            evalExpr(this.param.value, this.scope, this.owner),\\n            function (item, i) {\\n                var itemScope = new ForItemData(me, item, i);\\n                var child = createReverseNode(me.itemANode, reverseWalker, me, itemScope);\\n                me.children.push(child);\\n            }\\n        );\\n\\n        this._create();\\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\\n    }\\n    // #[end]\\n}\\n\\n\\nForNode.prototype.nodeType = NodeType.FOR;\\nForNode.prototype._create = nodeOwnCreateStump;\\nForNode.prototype.dispose = nodeOwnSimpleDispose;\\n\\n/**\\n * 将元素attach到页面的行为\\n *\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nForNode.prototype.attach = function (parentEl, beforeEl) {\\n    this._create();\\n    insertBefore(this.el, parentEl, beforeEl);\\n\\n    // paint list\\n    var el = this.el || parentEl.firstChild;\\n    var data = evalExpr(this.param.value, this.scope, this.owner);\\n    var len = data && data.length || 0;\\n    for (var i = 0; i < len; i++) {\\n        var child = createForDirectiveChild(this, data[i], i);\\n        this.children.push(child);\\n        child.attach(parentEl, el);\\n    }\\n};\\n\\n/**\\n * 将元素从页面上移除的行为\\n */\\nForNode.prototype.detach = function () {\\n    if (this.lifeCycle.attached) {\\n        elementDisposeChildren(this);\\n        this.children = [];\\n        removeEl(this.el);\\n        this.lifeCycle = LifeCycle.detached;\\n    }\\n};\\n\\n/* eslint-disable fecs-max-statements */\\n\\n/**\\n * 视图更新函数\\n *\\n * @param {Array} changes 数据变化信息\\n */\\nForNode.prototype._update = function (changes) {\\n\\n    var me = this;\\n    // 控制列表更新策略是否原样更新的变量\\n    var originalUpdate = this.aNode.directives.transition;\\n\\n\\n    var oldChildrenLen = this.children.length;\\n    var childrenChanges = new Array(oldChildrenLen);\\n\\n    function pushToChildrenChanges(change) {\\n        for (var i = 0, l = childrenChanges.length; i < l; i++) {\\n            (childrenChanges[i] = childrenChanges[i] || []).push(change);\\n        }\\n    }\\n\\n    var disposeChildren = [];\\n\\n\\n    // 判断列表是否父元素下唯一的元素\\n    // 如果是的话，可以做一些更新优化\\n    var parentEl = this.el.parentNode;\\n    var parentFirstChild = parentEl.firstChild;\\n    var parentLastChild = parentEl.lastChild;\\n    var isOnlyParentChild = oldChildrenLen > 0 // 有孩子时\\n            && parentFirstChild === this.children[0].el\\n            && (parentLastChild === this.el || parentLastChild === this.children[oldChildrenLen - 1].el)\\n        || oldChildrenLen === 0 // 无孩子时\\n            && parentFirstChild === this.el\\n            && parentLastChild === this.el;\\n\\n    // 控制列表是否整体更新的变量\\n    var isChildrenRebuild;\\n\\n    var newList = evalExpr(this.param.value, this.scope, this.owner);\\n    var newLen = newList && newList.length || 0;\\n\\n    /* eslint-disable no-redeclare */\\n    for (var cIndex = 0, cLen = changes.length; cIndex < cLen; cIndex++) {\\n        var change = changes[cIndex];\\n        var relation = changeExprCompare(change.expr, this.param.value, this.scope);\\n\\n        if (!relation) {\\n            // 无关时，直接传递给子元素更新，列表本身不需要动\\n            pushToChildrenChanges(change);\\n        }\\n        else if (relation > 2) {\\n            // 变更表达式是list绑定表达式的子项\\n            // 只需要对相应的子项进行更新\\n            var changePaths = change.expr.paths;\\n            var forLen = this.param.value.paths.length;\\n            var changeIndex = +evalExpr(changePaths[forLen], this.scope, this.owner);\\n\\n            if (isNaN(changeIndex)) {\\n                pushToChildrenChanges(change);\\n            }\\n            else {\\n                change = {\\n                    type: change.type,\\n                    expr: createAccessor(\\n                        this.param.item.paths.concat(changePaths.slice(forLen + 1))\\n                    ),\\n                    value: change.value,\\n                    index: change.index,\\n                    deleteCount: change.deleteCount,\\n                    insertions: change.insertions,\\n                    option: change.option\\n                };\\n\\n                (childrenChanges[changeIndex] = childrenChanges[changeIndex] || [])\\n                    .push(change);\\n\\n                if (this.children[changeIndex]) {\\n                    if (change.type === DataChangeType.SPLICE) {\\n                        this.children[changeIndex].scope._splice(\\n                            change.expr,\\n                            [].concat(change.index, change.deleteCount, change.insertions),\\n                            { silent: 1 }\\n                        );\\n                    }\\n                    else {\\n                        this.children[changeIndex].scope._set(\\n                            change.expr,\\n                            change.value,\\n                            { silent: 1 }\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        else if (change.type !== DataChangeType.SPLICE) {\\n            // 变更表达式是list绑定表达式本身或母项的重新设值\\n            // 此时需要更新整个列表\\n\\n\\n            // 老的比新的多的部分，标记需要dispose\\n            if (oldChildrenLen > newLen) {\\n                disposeChildren = disposeChildren.concat(this.children.slice(newLen));\\n\\n                childrenChanges = childrenChanges.slice(0, newLen);\\n                this.children = this.children.slice(0, newLen);\\n            }\\n\\n            // 整项变更\\n            for (var i = 0; i < newLen; i++) {\\n                (childrenChanges[i] = childrenChanges[i] || []).push({\\n                    type: DataChangeType.SET,\\n                    option: change.option,\\n                    expr: createAccessor(this.param.item.paths.slice(0)),\\n                    value: newList[i]\\n                });\\n\\n                // 对list更上级数据的直接设置\\n                if (relation < 2) {\\n                    childrenChanges[i].push(change);\\n                }\\n\\n                if (this.children[i]) {\\n                    this.children[i].scope._set(\\n                        this.param.item,\\n                        newList[i],\\n                        {silent: 1}\\n                    );\\n                }\\n                else {\\n                    this.children[i] = 0;\\n                }\\n            }\\n\\n            isChildrenRebuild = 1;\\n        }\\n        else if (relation === 2 && change.type === DataChangeType.SPLICE && !isChildrenRebuild) {\\n            // 变更表达式是list绑定表达式本身数组的splice操作\\n            // 此时需要删除部分项，创建部分项\\n            var changeStart = change.index;\\n            var deleteCount = change.deleteCount;\\n            var insertionsLen = change.insertions.length;\\n            var newCount = insertionsLen - deleteCount;\\n\\n            if (newCount) {\\n                var indexChange = {\\n                    type: DataChangeType.SET,\\n                    option: change.option,\\n                    expr: this.param.index\\n                };\\n\\n                for (var i = changeStart + deleteCount; i < this.children.length; i++) {\\n                    (childrenChanges[i] = childrenChanges[i] || []).push(indexChange);\\n                    this.children[i] && this.children[i].scope._set(\\n                        indexChange.expr,\\n                        i - deleteCount + insertionsLen,\\n                        {silent: 1}\\n                    );\\n                }\\n            }\\n\\n            var deleteLen = deleteCount;\\n            while (deleteLen--) {\\n                if (deleteLen < insertionsLen) {\\n                    var i = changeStart + deleteLen;\\n                    // update\\n                    (childrenChanges[i] = childrenChanges[i] || []).push({\\n                        type: DataChangeType.SET,\\n                        option: change.option,\\n                        expr: createAccessor(this.param.item.paths.slice(0)),\\n                        value: change.insertions[deleteLen]\\n                    });\\n                    if (this.children[i]) {\\n                        this.children[i].scope._set(\\n                            this.param.item,\\n                            change.insertions[deleteLen],\\n                            {silent: 1}\\n                        );\\n                    }\\n                }\\n            }\\n\\n            if (newCount < 0) {\\n                disposeChildren = disposeChildren.concat(this.children.splice(changeStart + insertionsLen, -newCount));\\n                childrenChanges.splice(changeStart + insertionsLen, -newCount);\\n            }\\n            else if (newCount > 0) {\\n                var spliceArgs = [changeStart + deleteCount, 0].concat(new Array(newCount));\\n                this.children.splice.apply(this.children, spliceArgs);\\n                childrenChanges.splice.apply(childrenChanges, spliceArgs);\\n            }\\n        }\\n    }\\n\\n    var newChildrenLen = this.children.length;\\n\\n    // 标记 length 是否发生变化\\n    if (newChildrenLen !== oldChildrenLen) {\\n        var lengthChange = {\\n            type: DataChangeType.SET,\\n            option: {},\\n            expr: createAccessor(\\n                this.param.value.paths.concat({\\n                    type: ExprType.STRING,\\n                    value: 'length'\\n                })\\n            )\\n        };\\n\\n        if (changesIsInDataRef([lengthChange], this.aNode.hotspot.data)) {\\n            pushToChildrenChanges(lengthChange);\\n        }\\n    }\\n\\n    // 清除应该干掉的 child\\n    this._doCreateAndUpdate = doCreateAndUpdate;\\n\\n    // 这里不用getTransition，getTransition和scope相关，for和forItem的scope是不同的\\n    // 所以getTransition结果本身也是不一致的。不如直接判断指令是否存在，如果存在就不进入暴力清除模式\\n    // var violentClear = isOnlyParentChild && newChildrenLen === 0 && !elementGetTransition(me);\\n    var violentClear = !originalUpdate && isOnlyParentChild && newChildrenLen === 0;\\n\\n    var disposedChildCount = 0;\\n    for (var i = 0; i < disposeChildren.length; i++) {\\n        var disposeChild = disposeChildren[i];\\n        if (disposeChild) {\\n            disposeChild._ondisposed = childDisposed;\\n            disposeChild.dispose(violentClear, violentClear);\\n        }\\n        else {\\n            childDisposed();\\n        }\\n    }\\n\\n    if (violentClear) {\\n        // cloneNode + replaceChild is faster\\n        // parentEl.innerHTML = '';\\n        var replaceNode = parentEl.cloneNode(false);\\n        parentEl.parentNode.replaceChild(replaceNode, parentEl);\\n        this.el = document.createComment(this.id);\\n        replaceNode.appendChild(this.el);\\n    }\\n\\n    if (disposeChildren.length === 0) {\\n        doCreateAndUpdate();\\n    }\\n\\n\\n    function childDisposed() {\\n        disposedChildCount++;\\n        if (disposedChildCount === disposeChildren.length\\n            && doCreateAndUpdate === me._doCreateAndUpdate\\n        ) {\\n            doCreateAndUpdate();\\n        }\\n    }\\n\\n    function doCreateAndUpdate() {\\n        me._doCreateAndUpdate = null;\\n        if (violentClear) {\\n            return;\\n        }\\n\\n\\n        var beforeEl = me.el;\\n\\n        // 对相应的项进行更新\\n        if (oldChildrenLen === 0 && isOnlyParentChild) {\\n            for (var i = 0; i < newChildrenLen; i++) {\\n                me.children[i] = createForDirectiveChild(me, newList[i], i);\\n                me.children[i].attach(parentEl, beforeEl);\\n            }\\n        }\\n        else {\\n            // 如果不attached则直接创建，如果存在则调用更新函数\\n            var j = -1;\\n            for (var i = 0; i < newChildrenLen; i++) {\\n                var child = me.children[i];\\n\\n                if (child) {\\n                    childrenChanges[i] && child._update(childrenChanges[i]);\\n                }\\n                else {\\n                    if (j < i) {\\n                        j = i + 1;\\n                        beforeEl = null;\\n                        while (j < newChildrenLen) {\\n                            var nextChild = me.children[j];\\n                            if (nextChild) {\\n                                beforeEl = nextChild.sel || nextChild.el;\\n                                break;\\n                            }\\n                            j++;\\n                        }\\n                    }\\n\\n                    me.children[i] = createForDirectiveChild(me, newList[i], i);\\n                    me.children[i].attach(parentEl, beforeEl || me.el);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n// exports = module.exports = ForNode;\\n\\n\\n/**\\n * @file 清洗条件 aNode\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var createANode = require('../parser/create-a-node');\\n// var cloneDirectives = require('../parser/clone-directives');\\n\\n\\n/**\\n * 清洗条件 aNode，返回纯净无条件指令的 aNode\\n *\\n * @param {ANode} aNode 条件节点对象\\n * @return {ANode}\\n */\\nfunction rinseCondANode(aNode) {\\n    var clearANode = createANode({\\n        children: aNode.children,\\n        props: aNode.props,\\n        events: aNode.events,\\n        tagName: aNode.tagName,\\n        vars: aNode.vars,\\n        hotspot: aNode.hotspot,\\n        directives: cloneDirectives(aNode.directives, {\\n            'if': 1,\\n            'else': 1,\\n            'elif': 1\\n        })\\n    });\\n\\n    return clearANode;\\n}\\n\\n// exports = module.exports = rinseCondANode;\\n\\n\\n/**\\n * @file if 指令节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var insertBefore = require('../browser/insert-before');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var NodeType = require('./node-type');\\n// var rinseCondANode = require('./rinse-cond-anode');\\n// var createNode = require('./create-node');\\n// var createReverseNode = require('./create-reverse-node');\\n// var nodeOwnCreateStump = require('./node-own-create-stump');\\n// var elementUpdateChildren = require('./element-update-children');\\n// var nodeOwnSimpleDispose = require('./node-own-simple-dispose');\\n\\n/**\\n * if 指令节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction IfNode(aNode, owner, scope, parent, reverseWalker) {\\n    this.aNode = aNode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n    this.parentComponent = parent.nodeType === NodeType.CMPT\\n        ? parent\\n        : parent.parentComponent;\\n\\n    this.id = guid();\\n    this.children = [];\\n\\n    this.cond = this.aNode.directives['if'].value; // eslint-disable-line dot-notation\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n        if (evalExpr(this.cond, this.scope, this.owner)) {\\n            this.elseIndex = -1;\\n            this.children[0] = createReverseNode(\\n                rinseCondANode(aNode),\\n                reverseWalker,\\n                this\\n            );\\n        }\\n        else {\\n            var me = this;\\n            each(aNode.elses, function (elseANode, index) {\\n                var elif = elseANode.directives.elif;\\n\\n                if (!elif || elif && evalExpr(elif.value, me.scope, me.owner)) {\\n                    me.elseIndex = index;\\n                    me.children[0] = createReverseNode(\\n                        rinseCondANode(elseANode),\\n                        reverseWalker,\\n                        me\\n                    );\\n                    return false;\\n                }\\n            });\\n        }\\n\\n        this._create();\\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\\n    }\\n    // #[end]\\n}\\n\\nIfNode.prototype.nodeType = NodeType.IF;\\n\\nIfNode.prototype._create = nodeOwnCreateStump;\\nIfNode.prototype.dispose = nodeOwnSimpleDispose;\\n\\nIfNode.prototype.attach = function (parentEl, beforeEl) {\\n    var me = this;\\n    var elseIndex;\\n    var child;\\n\\n    if (evalExpr(this.cond, this.scope, this.owner)) {\\n        child = createNode(rinseCondANode(me.aNode), me);\\n        elseIndex = -1;\\n    }\\n    else {\\n        each(me.aNode.elses, function (elseANode, index) {\\n            var elif = elseANode.directives.elif;\\n\\n            if (!elif || elif && evalExpr(elif.value, me.scope, me.owner)) {\\n                child = createNode(rinseCondANode(elseANode), me);\\n                elseIndex = index;\\n                return false;\\n            }\\n        });\\n    }\\n\\n    if (child) {\\n        me.children[0] = child;\\n        child.attach(parentEl, beforeEl);\\n        me.elseIndex = elseIndex;\\n    }\\n\\n\\n    this._create();\\n    insertBefore(this.el, parentEl, beforeEl);\\n};\\n\\n\\n/**\\n * 视图更新函数\\n *\\n * @param {Array} changes 数据变化信息\\n */\\nIfNode.prototype._update = function (changes) {\\n    var me = this;\\n    var childANode = me.aNode;\\n    var elseIndex;\\n\\n    if (evalExpr(this.cond, this.scope, this.owner)) {\\n        elseIndex = -1;\\n    }\\n    else {\\n        each(me.aNode.elses, function (elseANode, index) {\\n            var elif = elseANode.directives.elif;\\n\\n            if (elif && evalExpr(elif.value, me.scope, me.owner) || !elif) {\\n                elseIndex = index;\\n                childANode = elseANode;\\n                return false;\\n            }\\n        });\\n    }\\n\\n    if (elseIndex === me.elseIndex) {\\n        elementUpdateChildren(me, changes);\\n    }\\n    else {\\n        var child = me.children[0];\\n        me.children = [];\\n        if (child) {\\n            child._ondisposed = newChild;\\n            child.dispose();\\n        }\\n        else {\\n            newChild();\\n        }\\n\\n        me.elseIndex = elseIndex;\\n    }\\n\\n    function newChild() {\\n        if (typeof elseIndex !== 'undefined') {\\n            var child = createNode(rinseCondANode(childANode), me);\\n            // var parentEl = getNodeStumpParent(me);\\n            child.attach(me.el.parentNode, me.el);\\n\\n            me.children[0] = child;\\n        }\\n    }\\n};\\n\\n// exports = module.exports = IfNode;\\n\\n\\n/**\\n * @file template 节点类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var insertBefore = require('../browser/insert-before');\\n// var NodeType = require('./node-type');\\n// var LifeCycle = require('./life-cycle');\\n// var nodeDispose = require('./node-dispose');\\n// var createReverseNode = require('./create-reverse-node');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n// var elementOwnToPhase = require('./element-own-to-phase');\\n// var elementUpdateChildren = require('./element-update-children');\\n// var nodeOwnOnlyChildrenAttach = require('./node-own-only-children-attach');\\n\\n/**\\n * template 节点类\\n *\\n * @param {Object} aNode 抽象节点\\n * @param {Component} owner 所属组件环境\\n * @param {Model=} scope 所属数据环境\\n * @param {Node} parent 父亲节点\\n * @param {DOMChildrenWalker?} reverseWalker 子元素遍历对象\\n */\\nfunction TemplateNode(aNode, owner, scope, parent, reverseWalker) {\\n    this.aNode = aNode;\\n    this.owner = owner;\\n    this.scope = scope;\\n    this.parent = parent;\\n    this.parentComponent = parent.nodeType === NodeType.CMPT\\n        ? parent\\n        : parent.parentComponent;\\n\\n    this.id = guid();\\n    this.lifeCycle = LifeCycle.start;\\n    this.children = [];\\n\\n    // #[begin] reverse\\n    if (reverseWalker) {\\n        this.sel = document.createComment(this.id);\\n        insertBefore(this.sel, reverseWalker.target, reverseWalker.current);\\n\\n        var me = this;\\n        each(this.aNode.children, function (aNodeChild) {\\n            me.children.push(createReverseNode(aNodeChild, reverseWalker, me));\\n        });\\n\\n        this.el = document.createComment(this.id);\\n        insertBefore(this.el, reverseWalker.target, reverseWalker.current);\\n\\n        this._toPhase('attached');\\n    }\\n    // #[end]\\n}\\n\\n\\n\\nTemplateNode.prototype.nodeType = NodeType.TPL;\\n\\nTemplateNode.prototype.attach = nodeOwnOnlyChildrenAttach;\\n\\n/**\\n * 销毁释放\\n *\\n * @param {boolean=} noDetach 是否不要把节点从dom移除\\n * @param {boolean=} noTransition 是否不显示过渡动画效果\\n */\\nTemplateNode.prototype.dispose = function (noDetach, noTransition) {\\n    elementDisposeChildren(this, noDetach, noTransition);\\n    nodeDispose(this);\\n};\\n\\n\\nTemplateNode.prototype._toPhase = elementOwnToPhase;\\n\\n/**\\n * 视图更新函数\\n *\\n * @param {Array} changes 数据变化信息\\n */\\nTemplateNode.prototype._update = function (changes) {\\n    elementUpdateChildren(this, changes);\\n};\\n\\n// exports = module.exports = TemplateNode;\\n\\n\\n/**\\n * @file 对元素的子节点进行反解\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var each = require('../util/each');\\n// var DOMChildrenWalker = require('./dom-children-walker');\\n// var createReverseNode = require('./create-reverse-node');\\n\\n// #[begin] reverse\\n\\n/**\\n * 对元素的子节点进行反解\\n *\\n * @param {Object} element 元素\\n */\\nfunction reverseElementChildren(element) {\\n    var htmlDirective = element.aNode.directives.html;\\n\\n    if (!htmlDirective) {\\n        var reverseWalker = new DOMChildrenWalker(element.el);\\n\\n        each(element.aNode.children, function (aNodeChild) {\\n            element.children.push(createReverseNode(aNodeChild, reverseWalker, element));\\n        });\\n    }\\n}\\n// #[end]\\n\\n// exports = module.exports = reverseElementChildren;\\n\\n\\n/**\\n * @file 处理元素的属性操作\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var getPropHandler = require('./get-prop-handler');\\n\\n/**\\n * 处理元素属性操作\\n *\\n * @param {Object} element 元素对象\\n * @param {*} value 属性值\\n * @param {Object} prop 属性信息对象\\n */\\nfunction handleProp(element, value, prop) {\\n    var name = prop.name;\\n    getPropHandler(element.tagName, name).prop(element.el, value, name, element, prop);\\n}\\n\\n// exports = module.exports = handleProp;\\n\\n\\n/**\\n * @file 创建节点对应的 HTMLElement 主元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var evalExpr = require('../runtime/eval-expr');\\n// var createEl = require('../browser/create-el');\\n// var handleProp = require('./handle-prop');\\n// var LifeCycle = require('./life-cycle');\\n// var NodeType = require('./node-type');\\n\\nvar emptyPropWhenCreate = {\\n    'class': 1,\\n    'style': 1,\\n    'id': 1\\n};\\n\\n/**\\n * 创建节点对应的 HTMLElement 主元素\\n */\\nfunction elementOwnCreate() {\\n    if (!this.lifeCycle.created) {\\n        this.lifeCycle = LifeCycle.painting;\\n\\n        var isComponent = this.nodeType === NodeType.CMPT;\\n        var sourceNode = this.aNode.hotspot.sourceNode;\\n        var props = this.aNode.props;\\n\\n        if (sourceNode) {\\n            this.el = sourceNode.cloneNode();\\n            props = this.aNode.hotspot.dynamicProps;\\n        }\\n        else {\\n            this.el = createEl(this.tagName);\\n        }\\n\\n        for (var i = 0, l = props.length; i < l; i++) {\\n            var prop = props[i];\\n            var value = isComponent\\n                ? evalExpr(prop.expr, this.data, this)\\n                : evalExpr(prop.expr, this.scope, this.owner);\\n\\n            if (value || !emptyPropWhenCreate[prop.name]) {\\n                handleProp(this, value, prop);\\n            }\\n        }\\n\\n        this._toPhase('created');\\n    }\\n}\\n\\n// exports = module.exports = elementOwnCreate;\\n\\n\\n/**\\n * @file 将元素attach到页面\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var createNode = require('./create-node');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var insertBefore = require('../browser/insert-before');\\n\\n/**\\n * 将元素attach到页面\\n *\\n * @param {Object} element 元素节点\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nfunction elementAttach(element, parentEl, beforeEl) {\\n    element._create();\\n    insertBefore(element.el, parentEl, beforeEl);\\n\\n    if (!element._contentReady) {\\n        var htmlDirective = element.aNode.directives.html;\\n\\n        if (htmlDirective) {\\n            element.el.innerHTML = evalExpr(htmlDirective.value, element.scope, element.owner);\\n        }\\n        else {\\n            var aNodeChildren = element.aNode.children;\\n            for (var i = 0; i < aNodeChildren.length; i++) {\\n                var child = createNode(aNodeChildren[i], element);\\n                element.children.push(child);\\n                child.attach(element.el);\\n            }\\n        }\\n\\n        element._contentReady = 1;\\n    }\\n}\\n\\n\\n// exports = module.exports = elementAttach;\\n\\n\\n/**\\n * @file 将元素attach到页面\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var elementAttach = require('./element-attach');\\n\\n/**\\n * 将元素attach到页面\\n *\\n * @param {HTMLElement} parentEl 要添加到的父元素\\n * @param {HTMLElement＝} beforeEl 要添加到哪个元素之前\\n */\\nfunction elementOwnAttach(parentEl, beforeEl) {\\n    if (!this.lifeCycle.attached) {\\n        elementAttach(this, parentEl, beforeEl);\\n        this._attached();\\n    }\\n}\\n\\n// exports = module.exports = elementOwnAttach;\\n\\n\\n/**\\n * @file 获取 element 的 transition 控制对象\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var evalArgs = require('../runtime/eval-args');\\n// var findMethod = require('../runtime/find-method');\\n// var NodeType = require('./node-type');\\n\\n/**\\n * 获取 element 的 transition 控制对象\\n *\\n * @param {Object} element 元素\\n * @return {Object?}\\n */\\nfunction elementGetTransition(element) {\\n    var aNode = element.nodeType === NodeType.CMPT ? element.givenANode : element.aNode;\\n    var directive = aNode && aNode.directives.transition;\\n    var owner = element.owner;\\n\\n    var transition;\\n    if (directive && owner) {\\n        transition = findMethod(owner, directive.value.name);\\n\\n        if (typeof transition === 'function') {\\n            transition = transition.apply(\\n                owner,\\n                evalArgs(directive.value.args, element.scope, owner)\\n            );\\n        }\\n    }\\n\\n    return transition || element.transition;\\n}\\n\\n// exports = module.exports = elementGetTransition;\\n\\n\\n/**\\n * @file 元素节点执行leave行为\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var elementGetTransition = require('./element-get-transition');\\n\\n\\n/**\\n * 元素节点执行leave行为\\n *\\n * @param {Object} element 元素\\n */\\nfunction elementLeave(element) {\\n    var lifeCycle = element.lifeCycle;\\n    if (lifeCycle.leaving) {\\n        return;\\n    }\\n\\n    if (element.disposeNoTransition) {\\n        element._doneLeave();\\n    }\\n    else {\\n        var transition = elementGetTransition(element);\\n\\n        if (transition && transition.leave) {\\n            element._toPhase('leaving');\\n            transition.leave(element.el, function () {\\n                element._doneLeave();\\n            });\\n        }\\n        else {\\n            element._doneLeave();\\n        }\\n    }\\n}\\n\\n// exports = module.exports = elementLeave;\\n\\n\\n/**\\n * @file 将元素从页面上移除\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var elementLeave = require('./element-leave');\\n\\n/**\\n * 将元素从页面上移除\\n */\\nfunction elementOwnDetach() {\\n    elementLeave(this);\\n}\\n\\n\\n// exports = module.exports = elementOwnDetach;\\n\\n\\n/**\\n * @file 销毁释放元素\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var elementLeave = require('./element-leave');\\n\\n/**\\n * 销毁释放元素\\n *\\n * @param {boolean=} noDetach 是否不要把节点从dom移除\\n * @param {boolean=} noTransition 是否不显示过渡动画效果\\n */\\nfunction elementOwnDispose(noDetach, noTransition) {\\n    this.leaveDispose = 1;\\n    this.disposeNoDetach = noDetach;\\n    this.disposeNoTransition = noTransition;\\n\\n    elementLeave(this);\\n}\\n\\n// exports = module.exports = elementOwnDispose;\\n\\n\\n/**\\n * @file 为元素的 el 绑定事件\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var on = require('../browser/on');\\n\\n/**\\n * 为元素的 el 绑定事件\\n *\\n * @param {string} name 事件名\\n * @param {Function} listener 监听器\\n * @param {boolean} capture 是否是捕获阶段触发\\n */\\nfunction elementOwnOnEl(name, listener, capture) {\\n    if (typeof listener === 'function') {\\n        capture = !!capture;\\n        this._elFns.push([name, listener, capture]);\\n        on(this.el, name, listener, capture);\\n    }\\n}\\n\\n// exports = module.exports = elementOwnOnEl;\\n\\n\\n/**\\n * @file  事件绑定不存在的 warning\\n * @author varsha(wangshuonpu@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n\\n// #[begin] error\\n/**\\n * 事件绑定不存在的 warning\\n *\\n * @param {Object} eventBind 事件绑定对象\\n * @param {Component} owner 所属的组件对象\\n */\\nfunction warnEventListenMethod(eventBind, owner) {\\n    var valid = true;\\n    var method = owner;\\n    each(eventBind.expr.name.paths, function (path) {\\n        if (!path.value) {\\n            return false;\\n        }\\n\\n        method = method[path.value];\\n        valid = !!method;\\n        return valid;\\n    });\\n\\n    if (!valid) {\\n        var paths = [];\\n        each(eventBind.expr.name.paths, function (path) {\\n            paths.push(path.value);\\n        });\\n        var message = '[SAN WARNING] ' + eventBind.name + ' listen fail,\\\"' + paths.join('.') + '\\\" not exist';\\n\\n        /* eslint-disable no-console */\\n        if (typeof console === 'object' && console.warn) {\\n            console.warn(message);\\n        }\\n        else {\\n            throw new Error(message);\\n        }\\n        /* eslint-enable no-console */\\n    }\\n}\\n// #[end]\\n\\n// exports = module.exports = warnEventListenMethod;\\n\\n\\n/**\\n * @file 完成元素 attached 后的行为\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var bind = require('../util/bind');\\n// var empty = require('../util/empty');\\n// var isBrowser = require('../browser/is-browser');\\n// var trigger = require('../browser/trigger');\\n// var NodeType = require('./node-type');\\n// var elementGetTransition = require('./element-get-transition');\\n// var eventDeclarationListener = require('./event-declaration-listener');\\n// var getPropHandler = require('./get-prop-handler');\\n// var warnEventListenMethod = require('./warn-event-listen-method');\\n\\n/**\\n * 双绑输入框CompositionEnd事件监听函数\\n *\\n * @inner\\n */\\nfunction inputOnCompositionEnd() {\\n    if (!this.composing) {\\n        return;\\n    }\\n\\n    this.composing = 0;\\n\\n    trigger(this, 'input');\\n}\\n\\n/**\\n * 双绑输入框CompositionStart事件监听函数\\n *\\n * @inner\\n */\\nfunction inputOnCompositionStart() {\\n    this.composing = 1;\\n}\\n\\nfunction xPropOutputer(xProp, data) {\\n    getPropHandler(this.tagName, xProp.name).output(this, xProp, data);\\n}\\n\\nfunction inputXPropOutputer(element, xProp, data) {\\n    var outputer = bind(xPropOutputer, element, xProp, data);\\n    return function (e) {\\n        if (!this.composing) {\\n            outputer(e);\\n        }\\n    };\\n}\\n\\n/**\\n * 完成元素 attached 后的行为\\n *\\n * @param {Object} element 元素节点\\n */\\nfunction elementOwnAttached() {\\n    this._toPhase('created');\\n\\n    var isComponent = this.nodeType === NodeType.CMPT;\\n    var data = isComponent ? this.data : this.scope;\\n\\n    /* eslint-disable no-redeclare */\\n\\n    // 处理自身变化时双向绑定的逻辑\\n    var xProps = this.aNode.hotspot.xProps;\\n    for (var i = 0, l = xProps.length; i < l; i++) {\\n        var xProp = xProps[i];\\n\\n        switch (xProp.name) {\\n            case 'value':\\n                switch (this.tagName) {\\n                    case 'input':\\n                    case 'textarea':\\n                        if (isBrowser && window.CompositionEvent) {\\n                            this._onEl('change', inputOnCompositionEnd);\\n                            this._onEl('compositionstart', inputOnCompositionStart);\\n                            this._onEl('compositionend', inputOnCompositionEnd);\\n                        }\\n\\n                        this._onEl(\\n                            ('oninput' in this.el) ? 'input' : 'propertychange',\\n                            inputXPropOutputer(this, xProp, data)\\n                        );\\n\\n                        break;\\n\\n                    case 'select':\\n                        this._onEl('change', bind(xPropOutputer, this, xProp, data));\\n                        break;\\n                }\\n                break;\\n\\n            case 'checked':\\n                switch (this.tagName) {\\n                    case 'input':\\n                        switch (this.el.type) {\\n                            case 'checkbox':\\n                            case 'radio':\\n                                this._onEl('click', bind(xPropOutputer, this, xProp, data));\\n                        }\\n                }\\n                break;\\n        }\\n    }\\n\\n    // bind events\\n    var events = isComponent\\n        ? this.aNode.events.concat(this.nativeEvents)\\n        : this.aNode.events;\\n\\n    for (var i = 0, l = events.length; i < l; i++) {\\n        var eventBind = events[i];\\n        var owner = isComponent ? this : this.owner;\\n\\n        // 判断是否是nativeEvent，下面的warn方法和事件绑定都需要\\n        // 依此指定eventBind.expr.name位于owner还是owner.owner上\\n        if (eventBind.modifier.native) {\\n            owner = owner.owner;\\n            data = this.scope || owner.data;\\n        }\\n\\n        // #[begin] error\\n        warnEventListenMethod(eventBind, owner);\\n        // #[end]\\n\\n        this._onEl(\\n            eventBind.name,\\n            bind(\\n                eventDeclarationListener,\\n                owner,\\n                eventBind,\\n                0,\\n                data\\n            ),\\n            eventBind.modifier.capture\\n        );\\n    }\\n\\n    this._toPhase('attached');\\n\\n\\n    if (this._isInitFromEl) {\\n        this._isInitFromEl = false;\\n    }\\n    else {\\n        var transition = elementGetTransition(this);\\n        if (transition && transition.enter) {\\n            transition.enter(this.el, empty);\\n        }\\n    }\\n}\\n\\n// exports = module.exports = elementOwnAttached;\\n\\n\\n/**\\n * @file 销毁元素节点\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var un = require('../browser/un');\\n// var removeEl = require('../browser/remove-el');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n// var nodeDispose = require('./node-dispose');\\n\\n/**\\n * 销毁元素节点\\n *\\n * @param {Object} element 要销毁的元素节点\\n * @param {Object=} options 销毁行为的参数\\n */\\nfunction elementDispose(element) {\\n    elementDisposeChildren(element, 1, 1);\\n\\n    // el 事件解绑\\n    var len = element._elFns.length;\\n    while (len--) {\\n        var fn = element._elFns[len];\\n        un(element.el, fn[0], fn[1], fn[2]);\\n    }\\n    element._elFns = null;\\n\\n\\n    // 如果没有parent，说明是一个root component，一定要从dom树中remove\\n    if (!element.disposeNoDetach || !element.parent) {\\n        removeEl(element.el);\\n    }\\n\\n    if (element._toPhase) {\\n        element._toPhase('detached');\\n    }\\n\\n    nodeDispose(element);\\n}\\n\\n\\n// exports = module.exports = elementDispose;\\n\\n\\n/**\\n * @file 初始化 element 节点的 tagName 处理\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ieOldThan9 = require('../browser/ie-old-than-9');\\n\\n/**\\n * 初始化 element 节点的 tagName 处理\\n *\\n * @param {Object} node 节点对象\\n */\\nfunction elementInitTagName(node) {\\n    node.tagName = node.tagName || node.aNode.tagName || 'div';\\n\\n    // #[begin] allua\\n    // ie8- 不支持innerHTML输出自定义标签\\n    if (ieOldThan9 && node.tagName.indexOf('-') > 0) {\\n        node.tagName = 'div';\\n    }\\n    // #[end]\\n}\\n\\n\\n// exports = module.exports = elementInitTagName;\\n\\n\\n/**\\n * @file 给 devtool 发通知消息\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var isBrowser = require('../browser/is-browser');\\n\\n// #[begin] devtool\\nvar san4devtool;\\n\\n/**\\n * 给 devtool 发通知消息\\n *\\n * @param {string} name 消息名称\\n * @param {*} arg 消息参数\\n */\\nfunction emitDevtool(name, arg) {\\n    if (isBrowser && san4devtool && san4devtool.debug && window.__san_devtool__) {\\n        window.__san_devtool__.emit(name, arg);\\n    }\\n}\\n\\nemitDevtool.start = function (main) {\\n    san4devtool = main;\\n    emitDevtool('san', main);\\n};\\n// #[end]\\n\\n// exports = module.exports = emitDevtool;\\n\\n\\n/**\\n * @file 组件类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var bind = require('../util/bind');\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var extend = require('../util/extend');\\n// var nextTick = require('../util/next-tick');\\n// var emitDevtool = require('../util/emit-devtool');\\n// var ExprType = require('../parser/expr-type');\\n// var parseExpr = require('../parser/parse-expr');\\n// var createAccessor = require('../parser/create-accessor');\\n// var postProp = require('../parser/post-prop');\\n// var removeEl = require('../browser/remove-el');\\n// var Data = require('../runtime/data');\\n// var evalExpr = require('../runtime/eval-expr');\\n// var changeExprCompare = require('../runtime/change-expr-compare');\\n// var compileComponent = require('./compile-component');\\n// var componentPreheat = require('./component-preheat');\\n// var LifeCycle = require('./life-cycle');\\n// var getANodeProp = require('./get-a-node-prop');\\n// var isDataChangeByElement = require('./is-data-change-by-element');\\n// var eventDeclarationListener = require('./event-declaration-listener');\\n// var reverseElementChildren = require('./reverse-element-children');\\n// var camelComponentBinds = require('./camel-component-binds');\\n// var NodeType = require('./node-type');\\n// var elementInitTagName = require('./element-init-tag-name');\\n// var elementOwnAttached = require('./element-own-attached');\\n// var elementDispose = require('./element-dispose');\\n// var elementUpdateChildren = require('./element-update-children');\\n// var elementOwnOnEl = require('./element-own-on-el');\\n// var elementOwnCreate = require('./element-own-create');\\n// var elementOwnAttach = require('./element-own-attach');\\n// var elementOwnDetach = require('./element-own-detach');\\n// var elementOwnDispose = require('./element-own-dispose');\\n// var warnEventListenMethod = require('./warn-event-listen-method');\\n// var elementDisposeChildren = require('./element-dispose-children');\\n// var elementAttach = require('./element-attach');\\n// var handleProp = require('./handle-prop');\\n// var createDataTypesChecker = require('../util/create-data-types-checker');\\n\\n\\n\\n/**\\n * 组件类\\n *\\n * @class\\n * @param {Object} options 初始化参数\\n */\\nfunction Component(options) { // eslint-disable-line\\n    options = options || {};\\n\\n    this.lifeCycle = LifeCycle.start;\\n    this.children = [];\\n    this._elFns = [];\\n    this.listeners = {};\\n    this.slotChildren = [];\\n\\n    var clazz = this.constructor;\\n\\n    this.filters = this.filters || clazz.filters || {};\\n    this.computed = this.computed || clazz.computed || {};\\n    this.messages = this.messages || clazz.messages || {};\\n    this.subTag = options.subTag;\\n\\n    // compile\\n    compileComponent(clazz);\\n    componentPreheat(clazz);\\n\\n    var me = this;\\n    var protoANode = clazz.prototype.aNode;\\n\\n    me.givenANode = options.aNode;\\n    me.givenNamedSlotBinds = [];\\n    me.givenSlots = {\\n        named: {}\\n    };\\n\\n    this.owner = options.owner;\\n    this.scope = options.scope;\\n    this.el = options.el;\\n\\n    var parent = options.parent;\\n    if (parent) {\\n        this.parent = parent;\\n        this.parentComponent = parent.nodeType === NodeType.CMPT\\n            ? parent\\n            : parent && parent.parentComponent;\\n    }\\n\\n    this.id = guid();\\n\\n    // #[begin] reverse\\n    if (this.el) {\\n        var firstCommentNode = this.el.firstChild;\\n        if (firstCommentNode.nodeType === 3) {\\n            firstCommentNode = firstCommentNode.nextSibling;\\n        }\\n\\n        if (firstCommentNode && firstCommentNode.nodeType === 8) {\\n            var stumpMatch = firstCommentNode.data.match(/^\\\\s*s-data:([\\\\s\\\\S]+)?$/);\\n            if (stumpMatch) {\\n                var stumpText = stumpMatch[1];\\n\\n                // fill component data\\n                options.data = (new Function(\\n                    'return ' + stumpText.replace(/^[\\\\s\\\\n]*/, '')\\n                ))();\\n\\n                if (firstCommentNode.previousSibling) {\\n                    removeEl(firstCommentNode.previousSibling);\\n                }\\n                removeEl(firstCommentNode);\\n            }\\n        }\\n    }\\n    // #[end]\\n\\n    // native事件数组\\n    this.nativeEvents = [];\\n\\n    if (this.givenANode) {\\n        // 组件运行时传入的结构，做slot解析\\n        this._createGivenSlots();\\n\\n        each(this.givenANode.events, function (eventBind) {\\n            // 保存当前实例的native事件，下面创建aNode时候做合并\\n            if (eventBind.modifier.native) {\\n                me.nativeEvents.push(eventBind);\\n                return;\\n            }\\n\\n            // #[begin] error\\n            warnEventListenMethod(eventBind, options.owner);\\n            // #[end]\\n\\n            me.on(\\n                eventBind.name,\\n                bind(eventDeclarationListener, options.owner, eventBind, 1, options.scope),\\n                eventBind\\n            );\\n        });\\n\\n        this.tagName = protoANode.tagName || me.givenANode.tagName;\\n        this.binds = camelComponentBinds(this.givenANode.props);\\n    }\\n\\n    this._toPhase('compiled');\\n\\n    // init data\\n    this.data = new Data(\\n        extend(\\n            typeof this.initData === 'function' && this.initData() || {},\\n            options.data\\n        )\\n    );\\n\\n    elementInitTagName(this);\\n\\n    each(this.binds, function (bind) {\\n        postProp(bind);\\n\\n        if (me.scope) {\\n            var value = evalExpr(bind.expr, me.scope, me.owner);\\n            if (typeof value !== 'undefined') {\\n                // See: https://github.com/ecomfe/san/issues/191\\n                me.data.set(bind.name, value);\\n            }\\n        }\\n    });\\n\\n    // #[begin] error\\n    // 在初始化 + 数据绑定后，开始数据校验\\n    // NOTE: 只在开发版本中进行属性校验\\n    var dataTypes = this.dataTypes || clazz.dataTypes;\\n    if (dataTypes) {\\n        var dataTypeChecker = createDataTypesChecker(\\n            dataTypes,\\n            this.subTag || this.name || clazz.name\\n        );\\n        this.data.setTypeChecker(dataTypeChecker);\\n        this.data.checkDataTypes();\\n    }\\n    // #[end]\\n\\n    this.computedDeps = {};\\n    /* eslint-disable guard-for-in */\\n    for (var expr in this.computed) {\\n        if (!this.computedDeps[expr]) {\\n            this._calcComputed(expr);\\n        }\\n    }\\n    /* eslint-enable guard-for-in */\\n\\n    if (!this.dataChanger) {\\n        this.dataChanger = bind(this._dataChanger, this);\\n        this.data.listen(this.dataChanger);\\n    }\\n    this._toPhase('inited');\\n\\n    // #[begin] reverse\\n    if (this.el) {\\n        reverseElementChildren(this);\\n        this._attached();\\n    }\\n\\n    var walker = options.reverseWalker;\\n    if (walker) {\\n        var currentNode = walker.current;\\n        if (currentNode && currentNode.nodeType === 1) {\\n            this.el = currentNode;\\n            walker.goNext();\\n        }\\n\\n        reverseElementChildren(this);\\n\\n        this._attached();\\n    }\\n    // #[end]\\n}\\n\\n\\n\\nComponent.prototype.getComponentType = function (aNode) {\\n    return this.components[aNode.tagName];\\n};\\n\\n/**\\n * 初始化创建组件外部传入的插槽对象\\n *\\n * @protected\\n */\\nComponent.prototype._createGivenSlots = function () {\\n    var me = this;\\n    me.givenSlots.named = {};\\n\\n    // 组件运行时传入的结构，做slot解析\\n    me.givenANode && me.scope && each(me.givenANode.children, function (child) {\\n        var target;\\n\\n        var slotBind = !child.textExpr && getANodeProp(child, 'slot');\\n        if (slotBind) {\\n            !me.givenSlotInited && me.givenNamedSlotBinds.push(slotBind);\\n\\n            var slotName = evalExpr(slotBind.expr, me.scope, me.owner);\\n            target = me.givenSlots.named[slotName];\\n            if (!target) {\\n                target = me.givenSlots.named[slotName] = [];\\n            }\\n        }\\n        else if (!me.givenSlotInited) {\\n            target = me.givenSlots.noname;\\n            if (!target) {\\n                target = me.givenSlots.noname = [];\\n            }\\n        }\\n\\n        target && target.push(child);\\n    });\\n\\n    me.givenSlotInited = true;\\n};\\n\\n/**\\n * 类型标识\\n *\\n * @type {string}\\n */\\nComponent.prototype.nodeType = NodeType.CMPT;\\n\\n/**\\n * 在下一个更新周期运行函数\\n *\\n * @param {Function} fn 要运行的函数\\n */\\nComponent.prototype.nextTick = nextTick;\\n\\n/* eslint-disable operator-linebreak */\\n/**\\n * 使节点到达相应的生命周期\\n *\\n * @protected\\n * @param {string} name 生命周期名称\\n */\\nComponent.prototype._callHook =\\nComponent.prototype._toPhase = function (name) {\\n    if (!this.lifeCycle[name]) {\\n        this.lifeCycle = LifeCycle[name] || this.lifeCycle;\\n        if (typeof this[name] === 'function') {\\n            this[name]();\\n        }\\n\\n        // 通知devtool\\n        // #[begin] devtool\\n        emitDevtool('comp-' + name, this);\\n        // #[end]\\n    }\\n};\\n/* eslint-enable operator-linebreak */\\n\\n\\n/**\\n * 添加事件监听器\\n *\\n * @param {string} name 事件名\\n * @param {Function} listener 监听器\\n * @param {string?} declaration 声明式\\n */\\nComponent.prototype.on = function (name, listener, declaration) {\\n    if (typeof listener === 'function') {\\n        if (!this.listeners[name]) {\\n            this.listeners[name] = [];\\n        }\\n        this.listeners[name].push({fn: listener, declaration: declaration});\\n    }\\n};\\n\\n/**\\n * 移除事件监听器\\n *\\n * @param {string} name 事件名\\n * @param {Function=} listener 监听器\\n */\\nComponent.prototype.un = function (name, listener) {\\n    var nameListeners = this.listeners[name];\\n    var len = nameListeners && nameListeners.length;\\n\\n    while (len--) {\\n        if (!listener || listener === nameListeners[len].fn) {\\n            nameListeners.splice(len, 1);\\n        }\\n    }\\n};\\n\\n\\n/**\\n * 派发事件\\n *\\n * @param {string} name 事件名\\n * @param {Object} event 事件对象\\n */\\nComponent.prototype.fire = function (name, event) {\\n    var me = this;\\n    each(this.listeners[name], function (listener) {\\n        listener.fn.call(me, event);\\n    });\\n};\\n\\n/**\\n * 计算 computed 属性的值\\n *\\n * @private\\n * @param {string} computedExpr computed表达式串\\n */\\nComponent.prototype._calcComputed = function (computedExpr) {\\n    var computedDeps = this.computedDeps[computedExpr];\\n    if (!computedDeps) {\\n        computedDeps = this.computedDeps[computedExpr] = {};\\n    }\\n\\n    this.data.set(computedExpr, this.computed[computedExpr].call({\\n        data: {\\n            get: bind(function (expr) {\\n                // #[begin] error\\n                if (!expr) {\\n                    throw new Error('[SAN ERROR] call get method in computed need argument');\\n                }\\n                // #[end]\\n\\n                if (!computedDeps[expr]) {\\n                    computedDeps[expr] = 1;\\n\\n                    if (this.computed[expr]) {\\n                        this._calcComputed(expr);\\n                    }\\n\\n                    this.watch(expr, function () {\\n                        this._calcComputed(computedExpr);\\n                    });\\n                }\\n\\n                return this.data.get(expr);\\n            }, this)\\n        }\\n    }));\\n};\\n\\n/**\\n * 派发消息\\n * 组件可以派发消息，消息将沿着组件树向上传递，直到遇上第一个处理消息的组件\\n *\\n * @param {string} name 消息名称\\n * @param {*?} value 消息值\\n */\\nComponent.prototype.dispatch = function (name, value) {\\n    var parentComponent = this.parentComponent;\\n\\n    while (parentComponent) {\\n        var receiver = parentComponent.messages[name] || parentComponent.messages['*'];\\n        if (typeof receiver === 'function') {\\n            receiver.call(\\n                parentComponent,\\n                {target: this, value: value, name: name}\\n            );\\n            break;\\n        }\\n\\n        parentComponent = parentComponent.parentComponent;\\n    }\\n};\\n\\n/**\\n * 获取组件内部的 slot\\n *\\n * @param {string=} name slot名称，空为default slot\\n * @return {Array}\\n */\\nComponent.prototype.slot = function (name) {\\n    var result = [];\\n    var me = this;\\n\\n    function childrenTraversal(children) {\\n        each(children, function (child) {\\n            if (child.nodeType === NodeType.SLOT && child.owner === me) {\\n                if (child.isNamed && child.name === name\\n                    || !child.isNamed && !name\\n                ) {\\n                    result.push(child);\\n                }\\n            }\\n            else {\\n                childrenTraversal(child.children);\\n            }\\n        });\\n    }\\n\\n    childrenTraversal(this.children);\\n    return result;\\n};\\n\\n/**\\n * 获取带有 san-ref 指令的子组件引用\\n *\\n * @param {string} name 子组件的引用名\\n * @return {Component}\\n */\\nComponent.prototype.ref = function (name) {\\n    var refTarget;\\n    var owner = this;\\n\\n    function childrenTraversal(children) {\\n        each(children, function (child) {\\n            elementTraversal(child);\\n            return !refTarget;\\n        });\\n    }\\n\\n    function elementTraversal(element) {\\n        var nodeType = element.nodeType;\\n        if (nodeType === NodeType.TEXT) {\\n            return;\\n        }\\n\\n        if (element.owner === owner) {\\n            var ref;\\n            switch (element.nodeType) {\\n                case NodeType.ELEM:\\n                    ref = element.aNode.directives.ref;\\n                    if (ref && evalExpr(ref.value, element.scope, owner) === name) {\\n                        refTarget = element.el;\\n                    }\\n                    break;\\n\\n                case NodeType.CMPT:\\n                    ref = element.givenANode.directives.ref;\\n                    if (ref && evalExpr(ref.value, element.scope, owner) === name) {\\n                        refTarget = element;\\n                    }\\n            }\\n\\n            !refTarget && childrenTraversal(element.slotChildren);\\n        }\\n\\n        !refTarget && childrenTraversal(element.children);\\n    }\\n\\n    childrenTraversal(this.children);\\n\\n    return refTarget;\\n};\\n\\n\\n/**\\n * 视图更新函数\\n *\\n * @param {Array?} changes 数据变化信息\\n */\\nComponent.prototype._update = function (changes) {\\n    if (this.lifeCycle.disposed) {\\n        return;\\n    }\\n\\n    var me = this;\\n\\n\\n    var needReloadForSlot = false;\\n    this._notifyNeedReload = function () {\\n        needReloadForSlot = true;\\n    };\\n\\n    if (changes) {\\n        each(changes, function (change) {\\n            var changeExpr = change.expr;\\n\\n            each(me.binds, function (bindItem) {\\n                var relation;\\n                var setExpr = bindItem.name;\\n                var updateExpr = bindItem.expr;\\n\\n                if (!isDataChangeByElement(change, me, setExpr)\\n                    && (relation = changeExprCompare(changeExpr, updateExpr, me.scope))\\n                ) {\\n                    if (relation > 2) {\\n                        setExpr = createAccessor(\\n                            [\\n                                {\\n                                    type: ExprType.STRING,\\n                                    value: setExpr\\n                                }\\n                            ].concat(changeExpr.paths.slice(updateExpr.paths.length))\\n                        );\\n\\n                        updateExpr = changeExpr;\\n                    }\\n\\n                    me.data.set(setExpr, evalExpr(updateExpr, me.scope, me.owner), {\\n                        target: {\\n                            id: me.owner.id\\n                        }\\n                    });\\n                }\\n            });\\n\\n            each(me.givenNamedSlotBinds, function (bindItem) {\\n                needReloadForSlot = needReloadForSlot || changeExprCompare(changeExpr, bindItem.expr, me.scope);\\n                return !needReloadForSlot;\\n            });\\n        });\\n\\n        if (needReloadForSlot) {\\n            this._createGivenSlots();\\n            this._repaintChildren();\\n        }\\n        else {\\n            var slotChildrenLen = this.slotChildren.length;\\n            while (slotChildrenLen--) {\\n                var slotChild = this.slotChildren[slotChildrenLen];\\n\\n                if (slotChild.lifeCycle.disposed) {\\n                    this.slotChildren.splice(slotChildrenLen, 1);\\n                }\\n                else if (slotChild.isInserted) {\\n                    slotChild._update(changes, 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    var dataChanges = this.dataChanges;\\n    if (dataChanges) {\\n        this.dataChanges = null;\\n        each(this.aNode.hotspot.dynamicProps, function (prop) {\\n            each(dataChanges, function (change) {\\n                if (changeExprCompare(change.expr, prop.expr, me.data)\\n                    || prop.hintExpr && changeExprCompare(change.expr, prop.hintExpr, me.data)\\n                ) {\\n                    handleProp(me, evalExpr(prop.expr, me.data, me), prop);\\n                    return false;\\n                }\\n            });\\n        });\\n\\n        elementUpdateChildren(this, dataChanges);\\n        if (needReloadForSlot) {\\n            this._createGivenSlots();\\n            this._repaintChildren();\\n        }\\n\\n        this._toPhase('updated');\\n\\n        if (this.owner) {\\n            this._updateBindxOwner(dataChanges);\\n            this.owner._update();\\n        }\\n    }\\n\\n    this._notifyNeedReload = null;\\n};\\n\\nComponent.prototype._updateBindxOwner = function (dataChanges) {\\n    var me = this;\\n\\n    if (this.owner) {\\n        each(dataChanges, function (change) {\\n            each(me.binds, function (bindItem) {\\n                var changeExpr = change.expr;\\n                if (bindItem.x\\n                    && !isDataChangeByElement(change, me.owner)\\n                    && changeExprCompare(changeExpr, parseExpr(bindItem.name), me.data)\\n                ) {\\n                    var updateScopeExpr = bindItem.expr;\\n                    if (changeExpr.paths.length > 1) {\\n                        updateScopeExpr = createAccessor(\\n                            bindItem.expr.paths.concat(changeExpr.paths.slice(1))\\n                        );\\n                    }\\n\\n                    me.scope.set(\\n                        updateScopeExpr,\\n                        evalExpr(changeExpr, me.data, me),\\n                        {\\n                            target: {\\n                                id: me.id,\\n                                prop: bindItem.name\\n                            }\\n                        }\\n                    );\\n                }\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * 重新绘制组件的内容\\n * 当 dynamic slot name 发生变更或 slot 匹配发生变化时，重新绘制\\n * 在组件级别重绘有点粗暴，但是能保证视图结果正确性\\n */\\nComponent.prototype._repaintChildren = function () {\\n    elementDisposeChildren(this, 0, 1);\\n    this.children = [];\\n\\n    this._contentReady = 0;\\n    this.slotChildren = [];\\n    elementAttach(this);\\n};\\n\\n\\n/**\\n * 组件内部监听数据变化的函数\\n *\\n * @private\\n * @param {Object} change 数据变化信息\\n */\\nComponent.prototype._dataChanger = function (change) {\\n    if (this.lifeCycle.painting || this.lifeCycle.created) {\\n        if (!this.dataChanges) {\\n            nextTick(this._update, this);\\n            this.dataChanges = [];\\n        }\\n\\n        this.dataChanges.push(change);\\n    }\\n    else if (this.lifeCycle.inited && this.owner) {\\n        this._updateBindxOwner([change]);\\n    }\\n};\\n\\n\\n/**\\n * 监听组件的数据变化\\n *\\n * @param {string} dataName 变化的数据项\\n * @param {Function} listener 监听函数\\n */\\nComponent.prototype.watch = function (dataName, listener) {\\n    var dataExpr = parseExpr(dataName);\\n\\n    this.data.listen(bind(function (change) {\\n        if (changeExprCompare(change.expr, dataExpr, this.data)) {\\n            listener.call(this, evalExpr(dataExpr, this.data, this), change);\\n        }\\n    }, this));\\n};\\n\\n/**\\n * 组件销毁的行为\\n *\\n * @param {Object} options 销毁行为的参数\\n */\\nComponent.prototype.dispose = elementOwnDispose;\\n\\nComponent.prototype._doneLeave = function () {\\n    if (this.leaveDispose) {\\n        if (!this.lifeCycle.disposed) {\\n            // 这里不用挨个调用 dispose 了，因为 children 释放链会调用的\\n            this.slotChildren = null;\\n\\n            this.data.unlisten();\\n            this.dataChanger = null;\\n            this.dataChanges = null;\\n\\n            elementDispose(\\n                this,\\n                this.disposeNoDetach,\\n                this.disposeNoTransition\\n            );\\n            this.listeners = null;\\n\\n            this.givenANode = null;\\n            this.givenSlots = null;\\n            this.givenNamedSlotBinds = null;\\n        }\\n    }\\n    else if (this.lifeCycle.attached) {\\n        removeEl(this.el);\\n        this._toPhase('detached');\\n    }\\n};\\n\\n/**\\n * 完成组件 attached 后的行为\\n *\\n * @param {Object} element 元素节点\\n */\\nComponent.prototype._attached = elementOwnAttached;\\n\\nComponent.prototype.attach = elementOwnAttach;\\nComponent.prototype.detach = elementOwnDetach;\\nComponent.prototype._create = elementOwnCreate;\\nComponent.prototype._onEl = elementOwnOnEl;\\n\\n\\n// exports = module.exports = Component;\\n\\n\\n/**\\n * @file 创建组件类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var Component = require('./component');\\n// var inherits = require('../util/inherits');\\n\\n/**\\n * 创建组件类\\n *\\n * @param {Object} proto 组件类的方法表\\n * @return {Function}\\n */\\nfunction defineComponent(proto) {\\n    // 如果传入一个不是 san component 的 constructor，直接返回不是组件构造函数\\n    // 这种场景导致的错误 san 不予考虑\\n    if (typeof proto === 'function') {\\n        return proto;\\n    }\\n\\n    // #[begin] error\\n    if (typeof proto !== 'object') {\\n        throw new Error('[SAN FATAL] param must be a plain object.');\\n    }\\n    // #[end]\\n\\n    function ComponentClass(option) { // eslint-disable-line\\n        Component.call(this, option);\\n    }\\n\\n    ComponentClass.prototype = proto;\\n    inherits(ComponentClass, Component);\\n\\n    return ComponentClass;\\n}\\n\\n// exports = module.exports = defineComponent;\\n\\n\\n/**\\n * @file 编译组件类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var createANode = require('../parser/create-a-node');\\n// var parseTemplate = require('../parser/parse-template');\\n// var parseText = require('../parser/parse-text');\\n// var defineComponent = require('./define-component');\\n\\n\\n/**\\n * 编译组件类。预解析template和components\\n *\\n * @param {Function} ComponentClass 组件类\\n */\\nfunction compileComponent(ComponentClass) {\\n    var proto = ComponentClass.prototype;\\n\\n    // pre define components class\\n    if (!proto.hasOwnProperty('_cmptReady')) {\\n        proto.components = ComponentClass.components || proto.components || {};\\n        var components = proto.components;\\n\\n        for (var key in components) { // eslint-disable-line\\n            var componentClass = components[key];\\n\\n            if (typeof componentClass === 'object') {\\n                components[key] = defineComponent(componentClass);\\n            }\\n            else if (componentClass === 'self') {\\n                components[key] = ComponentClass;\\n            }\\n        }\\n\\n        proto._cmptReady = 1;\\n    }\\n\\n\\n    // pre compile template\\n    if (!proto.hasOwnProperty('aNode')) {\\n        proto.aNode = createANode();\\n\\n        var tpl = ComponentClass.template || proto.template;\\n        if (tpl) {\\n            var aNode = parseTemplate(tpl, {\\n                trimWhitespace: proto.trimWhitespace || ComponentClass.trimWhitespace,\\n                delimiters: proto.delimiters || ComponentClass.delimiters\\n            });\\n            var firstChild = aNode.children[0];\\n\\n            // #[begin] error\\n            if (aNode.children.length !== 1 || firstChild.textExpr) {\\n                throw new Error('[SAN FATAL] template must have a root element.');\\n            }\\n            // #[end]\\n\\n            proto.aNode = firstChild;\\n            if (firstChild.tagName === 'template') {\\n                firstChild.tagName = null;\\n            }\\n\\n            var componentPropExtra = {\\n                'class': {name: 'class', expr: parseText('{{class | _class | _sep(\\\" \\\")}}')},\\n                'style': {name: 'style', expr: parseText('{{style | _style | _sep(\\\";\\\")}}')},\\n                'id': {name: 'id', expr: parseText('{{id}}')}\\n            };\\n\\n            var len = firstChild.props.length;\\n            while (len--) {\\n                var prop = firstChild.props[len];\\n                var extra = componentPropExtra[prop.name];\\n\\n                if (extra) {\\n                    firstChild.props.splice(len, 1);\\n                    componentPropExtra[prop.name] = prop;\\n\\n                    if (prop.name !== 'id') {\\n                        prop.expr.segs.push(extra.expr.segs[0]);\\n                        prop.expr.value = null;\\n                    }\\n                }\\n            }\\n\\n            firstChild.props.push(\\n                componentPropExtra['class'], // eslint-disable-line dot-notation\\n                componentPropExtra.style,\\n                componentPropExtra.id\\n            );\\n        }\\n    }\\n}\\n\\n// exports = module.exports = compileComponent;\\n\\n\\n/**\\n * @file 组件预热\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var ExprType = require('../parser/expr-type');\\n// var each = require('../util/each');\\n// var createEl = require('../browser/create-el');\\n// var getPropHandler = require('./get-prop-handler');\\n// var getANodeProp = require('./get-a-node-prop');\\n// var isBrowser = require('../browser/is-browser');\\n\\n/**\\n * 组件预热，分析组件aNode的数据引用等信息\\n *\\n * @param {Function} ComponentClass 组件类\\n */\\nfunction componentPreheat(ComponentClass) {\\n    var stack = [];\\n\\n    function recordHotspotData(refs, notContentData) {\\n        var len = stack.length;\\n        each(stack, function (aNode, index) {\\n            if (!notContentData || index !== len - 1) {\\n                each(refs, function (ref) {\\n                    aNode.hotspot.data[ref] = 1;\\n                });\\n            }\\n        });\\n    }\\n\\n\\n    function analyseANodeHotspot(aNode) {\\n        if (!aNode.hotspot) {\\n            stack.push(aNode);\\n\\n\\n            if (aNode.textExpr) {\\n                aNode.hotspot = {data: {}};\\n                recordHotspotData(analyseExprDataHotspot(aNode.textExpr));\\n            }\\n            else {\\n                var sourceNode;\\n                if (isBrowser && aNode.tagName && !/^(template|slot|select|input|option)$/i.test(aNode.tagName)) {\\n                    sourceNode = createEl(aNode.tagName);\\n                }\\n\\n                aNode.hotspot = {\\n                    data: {},\\n                    dynamicProps: [],\\n                    xProps: [],\\n                    props: {},\\n                    sourceNode: sourceNode\\n                };\\n\\n\\n                // === analyse hotspot data: start\\n                each(aNode.vars, function (varItem) {\\n                    recordHotspotData(analyseExprDataHotspot(varItem.expr));\\n                });\\n\\n                each(aNode.props, function (prop) {\\n                    recordHotspotData(analyseExprDataHotspot(prop.expr));\\n                });\\n\\n                /* eslint-disable guard-for-in */\\n                for (var key in aNode.directives) {\\n                    var directive = aNode.directives[key];\\n                    recordHotspotData(analyseExprDataHotspot(directive.value), key !== 'html');\\n                }\\n                /* eslint-enable guard-for-in */\\n\\n                each(aNode.elses, function (child) {\\n                    analyseANodeHotspot(child);\\n                });\\n\\n                each(aNode.children, function (child) {\\n                    analyseANodeHotspot(child);\\n                });\\n                // === analyse hotspot data: end\\n\\n\\n                // === analyse hotspot props: start\\n                each(aNode.props, function (prop, index) {\\n                    aNode.hotspot.props[prop.name] = index;\\n\\n                    if (prop.name === 'id') {\\n                        prop.id = true;\\n                        aNode.hotspot.idProp = prop;\\n                        aNode.hotspot.dynamicProps.push(prop);\\n                    }\\n                    else if (prop.expr.value != null) {\\n                        if (sourceNode) {\\n                            getPropHandler(aNode.tagName, prop.name)\\n                                .prop(sourceNode, prop.expr.value, prop.name, aNode);\\n                        }\\n                    }\\n                    else {\\n                        if (prop.x) {\\n                            aNode.hotspot.xProps.push(prop);\\n                        }\\n                        aNode.hotspot.dynamicProps.push(prop);\\n                    }\\n                });\\n\\n                // ie 下，如果 option 没有 value 属性，select.value = xx 操作不会选中 option\\n                // 所以没有设置 value 时，默认把 option 的内容作为 value\\n                if (aNode.tagName === 'option'\\n                    && !getANodeProp(aNode, 'value')\\n                    && aNode.children[0]\\n                ) {\\n                    var valueProp = {\\n                        name: 'value',\\n                        expr: aNode.children[0].textExpr\\n                    };\\n                    aNode.props.push(valueProp);\\n                    aNode.hotspot.dynamicProps.push(valueProp);\\n                    aNode.hotspot.props.value = aNode.props.length - 1;\\n                }\\n                // === analyse hotspot props: end\\n            }\\n\\n            stack.pop();\\n        }\\n    }\\n\\n    analyseANodeHotspot(ComponentClass.prototype.aNode);\\n}\\n\\n/**\\n * 分析表达式的数据引用\\n *\\n * @param {Object} expr 要分析的表达式\\n * @return {Array}\\n */\\nfunction analyseExprDataHotspot(expr) {\\n    var refs = [];\\n\\n    function analyseExprs(exprs) {\\n        each(exprs, function (expr) {\\n            refs = refs.concat(analyseExprDataHotspot(expr));\\n        });\\n    }\\n\\n    switch (expr.type) {\\n        case ExprType.ACCESSOR:\\n            var paths = expr.paths;\\n            refs.push(paths[0].value);\\n\\n            if (paths.length > 1) {\\n                refs.push(paths[0].value + '.' + (paths[1].value || '*'));\\n            }\\n\\n            analyseExprs(paths.slice(1));\\n            break;\\n\\n        case ExprType.UNARY:\\n            return analyseExprDataHotspot(expr.expr);\\n\\n        case ExprType.TEXT:\\n        case ExprType.BINARY:\\n        case ExprType.TERTIARY:\\n            analyseExprs(expr.segs);\\n            break;\\n\\n        case ExprType.INTERP:\\n            refs = analyseExprDataHotspot(expr.expr);\\n\\n            each(expr.filters, function (filter) {\\n                analyseExprs(filter.name.paths);\\n                analyseExprs(filter.args);\\n            });\\n\\n            break;\\n\\n    }\\n\\n    return refs;\\n}\\n\\n// exports = module.exports = componentPreheat;\\n\\n\\n/**\\n * @file 将 binds 的 name 从 kebabcase 转换成 camelcase\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var kebab2camel = require('../util/kebab2camel');\\n// var each = require('../util/each');\\n\\n/**\\n * 将 binds 的 name 从 kebabcase 转换成 camelcase\\n *\\n * @param {Array} binds binds集合\\n * @return {Array}\\n */\\nfunction camelComponentBinds(binds) {\\n    var result = [];\\n    each(binds, function (bind) {\\n        result.push({\\n            name: kebab2camel(bind.name),\\n            expr: bind.expr,\\n            x: bind.x,\\n            raw: bind.raw\\n        });\\n    });\\n\\n    return result;\\n}\\n\\n// exports = module.exports = camelComponentBinds;\\n\\n\\n/**\\n * @file 编译源码的 helper 方法集合\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var ExprType = require('../parser/expr-type');\\n\\n// #[begin] ssr\\n// \\n// /**\\n//  * 编译源码的 helper 方法集合对象\\n//  */\\n// var compileExprSource = {\\n// \\n//     /**\\n//      * 字符串字面化\\n//      *\\n//      * @param {string} source 需要字面化的字符串\\n//      * @return {string} 字符串字面化结果\\n//      */\\n//     stringLiteralize: function (source) {\\n//         return '\\\"'\\n//             + source\\n//                 .replace(/\\\\x5C/g, '\\\\\\\\\\\\\\\\')\\n//                 .replace(/\\\"/g, '\\\\\\\\\\\"')\\n//                 .replace(/\\\\x0A/g, '\\\\\\\\n')\\n//                 .replace(/\\\\x09/g, '\\\\\\\\t')\\n//                 .replace(/\\\\x0D/g, '\\\\\\\\r')\\n//                 // .replace( /\\\\x08/g, '\\\\\\\\b' )\\n//                 // .replace( /\\\\x0C/g, '\\\\\\\\f' )\\n//             + '\\\"';\\n//     },\\n// \\n//     /**\\n//      * 生成数据访问表达式代码\\n//      *\\n//      * @param {Object?} accessorExpr accessor表达式对象\\n//      * @return {string}\\n//      */\\n//     dataAccess: function (accessorExpr) {\\n//         var code = 'componentCtx.data';\\n//         if (accessorExpr) {\\n//             each(accessorExpr.paths, function (path) {\\n//                 if (path.type === ExprType.ACCESSOR) {\\n//                     code += '[' + compileExprSource.dataAccess(path) + ']';\\n//                     return;\\n//                 }\\n// \\n//                 switch (typeof path.value) {\\n//                     case 'string':\\n//                         code += '.' + path.value;\\n//                         break;\\n// \\n//                     case 'number':\\n//                         code += '[' + path.value + ']';\\n//                         break;\\n//                 }\\n//             });\\n//         }\\n// \\n//         return code;\\n//     },\\n// \\n//     /**\\n//      * 生成插值代码\\n//      *\\n//      * @param {Object} interpExpr 插值表达式对象\\n//      * @return {string}\\n//      */\\n//     interp: function (interpExpr) {\\n//         var code = compileExprSource.expr(interpExpr.expr);\\n// \\n// \\n//         each(interpExpr.filters, function (filter) {\\n//             code = 'componentCtx.callFilter(\\\"' + filter.name.paths[0].value + '\\\", [' + code;\\n//             each(filter.args, function (arg) {\\n//                 code += ', ' + compileExprSource.expr(arg);\\n//             });\\n//             code += '])';\\n//         });\\n// \\n//         if (!interpExpr.original) {\\n//             return 'escapeHTML(' + code + ')';\\n//         }\\n// \\n//         return code;\\n//     },\\n// \\n//     /**\\n//      * 生成文本片段代码\\n//      *\\n//      * @param {Object} textExpr 文本片段表达式对象\\n//      * @return {string}\\n//      */\\n//     text: function (textExpr) {\\n//         if (textExpr.segs.length === 0) {\\n//             return '\\\"\\\"';\\n//         }\\n// \\n//         var code = '';\\n// \\n//         each(textExpr.segs, function (seg) {\\n//             var segCode = compileExprSource.expr(seg);\\n//             code += code ? ' + ' + segCode : segCode;\\n//         });\\n// \\n//         return code;\\n//     },\\n// \\n//     /**\\n//      * 二元表达式操作符映射表\\n//      *\\n//      * @type {Object}\\n//      */\\n//     binaryOp: {\\n//         /* eslint-disable */\\n//         43: '+',\\n//         45: '-',\\n//         42: '*',\\n//         47: '/',\\n//         60: '<',\\n//         62: '>',\\n//         76: '&&',\\n//         94: '!=',\\n//         121: '<=',\\n//         122: '==',\\n//         123: '>=',\\n//         155: '!==',\\n//         183: '===',\\n//         248: '||'\\n//         /* eslint-enable */\\n//     },\\n// \\n//     /**\\n//      * 生成表达式代码\\n//      *\\n//      * @param {Object} expr 表达式对象\\n//      * @return {string}\\n//      */\\n//     expr: function (expr) {\\n//         switch (expr.type) {\\n//             case ExprType.UNARY:\\n//                 return '!' + compileExprSource.expr(expr.expr);\\n// \\n//             case ExprType.BINARY:\\n//                 return compileExprSource.expr(expr.segs[0])\\n//                     + compileExprSource.binaryOp[expr.operator]\\n//                     + compileExprSource.expr(expr.segs[1]);\\n// \\n//             case ExprType.TERTIARY:\\n//                 return compileExprSource.expr(expr.segs[0])\\n//                     + '?' + compileExprSource.expr(expr.segs[1])\\n//                     + ':' + compileExprSource.expr(expr.segs[2]);\\n// \\n//             case ExprType.STRING:\\n//                 return compileExprSource.stringLiteralize(expr.literal || expr.value);\\n// \\n//             case ExprType.NUMBER:\\n//                 return expr.value;\\n// \\n//             case ExprType.BOOL:\\n//                 return expr.value ? 'true' : 'false';\\n// \\n//             case ExprType.ACCESSOR:\\n//                 return compileExprSource.dataAccess(expr);\\n// \\n//             case ExprType.INTERP:\\n//                 return compileExprSource.interp(expr);\\n// \\n//             case ExprType.TEXT:\\n//                 return compileExprSource.text(expr);\\n//         }\\n//     }\\n// };\\n// #[end]\\n\\n// exports = module.exports = compileExprSource;\\n\\n\\n/**\\n * @file 编译源码的中间buffer类\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n// var each = require('../util/each');\\n// var compileExprSource = require('./compile-expr-source');\\n\\n\\n// #[begin] ssr\\n// /**\\n//  * 编译源码的中间buffer类\\n//  *\\n//  * @class\\n//  */\\n// function CompileSourceBuffer() {\\n//     this.segs = [];\\n// }\\n// \\n// /**\\n//  * 添加原始代码，将原封不动输出\\n//  *\\n//  * @param {string} code 原始代码\\n//  */\\n// CompileSourceBuffer.prototype.addRaw = function (code) {\\n//     this.segs.push({\\n//         type: 'RAW',\\n//         code: code\\n//     });\\n// };\\n// \\n// /**\\n//  * 添加被拼接为html的原始代码\\n//  *\\n//  * @param {string} code 原始代码\\n//  */\\n// CompileSourceBuffer.prototype.joinRaw = function (code) {\\n//     this.segs.push({\\n//         type: 'JOIN_RAW',\\n//         code: code\\n//     });\\n// };\\n// \\n// /**\\n//  * 添加renderer方法的起始源码\\n//  */\\n// CompileSourceBuffer.prototype.addRendererStart = function () {\\n//     this.addRaw('function (data, parentCtx, givenSlots) {');\\n//     this.addRaw('var html = \\\"\\\";');\\n// };\\n// \\n// /**\\n//  * 添加renderer方法的结束源码\\n//  */\\n// CompileSourceBuffer.prototype.addRendererEnd = function () {\\n//     this.addRaw('return html;');\\n//     this.addRaw('}');\\n// };\\n// \\n// /**\\n//  * 添加被拼接为html的静态字符串\\n//  *\\n//  * @param {string} str 被拼接的字符串\\n//  */\\n// CompileSourceBuffer.prototype.joinString = function (str) {\\n//     this.segs.push({\\n//         str: str,\\n//         type: 'JOIN_STRING'\\n//     });\\n// };\\n// \\n// /**\\n//  * 添加被拼接为html的数据访问\\n//  *\\n//  * @param {Object?} accessor 数据访问表达式对象\\n//  */\\n// CompileSourceBuffer.prototype.joinDataStringify = function () {\\n//     this.segs.push({\\n//         type: 'JOIN_DATA_STRINGIFY'\\n//     });\\n// };\\n// \\n// /**\\n//  * 添加被拼接为html的表达式\\n//  *\\n//  * @param {Object} expr 表达式对象\\n//  */\\n// CompileSourceBuffer.prototype.joinExpr = function (expr) {\\n//     this.segs.push({\\n//         expr: expr,\\n//         type: 'JOIN_EXPR'\\n//     });\\n// };\\n// \\n// /**\\n//  * 生成编译后代码\\n//  *\\n//  * @return {string}\\n//  */\\n// CompileSourceBuffer.prototype.toCode = function () {\\n//     var code = [];\\n//     var temp = '';\\n// \\n//     function genStrLiteral() {\\n//         if (temp) {\\n//             code.push('html += ' + compileExprSource.stringLiteralize(temp) + ';');\\n//         }\\n// \\n//         temp = '';\\n//     }\\n// \\n//     each(this.segs, function (seg) {\\n//         if (seg.type === 'JOIN_STRING') {\\n//             temp += seg.str;\\n//             return;\\n//         }\\n// \\n//         genStrLiteral();\\n//         switch (seg.type) {\\n//             case 'JOIN_DATA_STRINGIFY':\\n//                 code.push('html += stringifier.any(' + compileExprSource.dataAccess() + ');');\\n//                 break;\\n// \\n//             case 'JOIN_EXPR':\\n//                 code.push('html += ' + compileExprSource.expr(seg.expr) + ';');\\n//                 break;\\n// \\n//             case 'JOIN_RAW':\\n//                 code.push('html += ' + seg.code + ';');\\n//                 break;\\n// \\n//             case 'RAW':\\n//                 code.push(seg.code);\\n//                 break;\\n// \\n//         }\\n//     });\\n// \\n//     genStrLiteral();\\n// \\n//     return code.join('\\\\n');\\n// };\\n// \\n// #[end]\\n\\n// exports = module.exports = CompileSourceBuffer;\\n\\n\\n/**\\n * @file 将组件编译成 render 方法的 js 源码\\n * @author errorrik(errorrik@gmail.com)\\n */\\n\\n\\n// var each = require('../util/each');\\n// var guid = require('../util/guid');\\n// var parseExpr = require('../parser/parse-expr');\\n// var createANode = require('../parser/create-a-node');\\n// var cloneDirectives = require('../parser/clone-directives');\\n// var autoCloseTags = require('../browser/auto-close-tags');\\n// var CompileSourceBuffer = require('./compile-source-buffer');\\n// var compileExprSource = require('./compile-expr-source');\\n// var rinseCondANode = require('./rinse-cond-anode');\\n// var getANodeProp = require('./get-a-node-prop');\\n\\n// #[begin] ssr\\n// \\n// /**\\n//  * 生成序列化时起始桩的html\\n//  *\\n//  * @param {string} type 桩类型标识\\n//  * @param {string?} content 桩内的内容\\n//  * @return {string}\\n//  */\\n// function serializeStump(type, content) {\\n//     return '\\x3c!--s-' + type + (content ? ':' + content : '') + '--\\x3e';\\n// }\\n// \\n// /**\\n//  * 生成序列化时结束桩的html\\n//  *\\n//  * @param {string} type 桩类型标识\\n//  * @return {string}\\n//  */\\n// function serializeStumpEnd(type) {\\n//     return '\\x3c!--/s-' + type + '--\\x3e';\\n// }\\n// \\n// /**\\n//  * element 的编译方法集合对象\\n//  *\\n//  * @inner\\n//  */\\n// var elementSourceCompiler = {\\n// \\n//     /* eslint-disable max-params */\\n//     /**\\n//      * 编译元素标签头\\n//      *\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {string} tagName 标签名\\n//      * @param {Array} props 属性列表\\n//      * @param {string?} extraProp 额外的属性串\\n//      * @param {boolean?} isClose 是否闭合\\n//      */\\n//     tagStart: function (sourceBuffer, tagName, props, extraProp, isClose) {\\n//         sourceBuffer.joinString('<' + tagName);\\n//         sourceBuffer.joinString(extraProp || '');\\n// \\n//         // index list\\n//         var propsIndex = {};\\n//         each(props, function (prop) {\\n//             propsIndex[prop.name] = prop;\\n//         });\\n// \\n//         each(props, function (prop) {\\n//             if (prop.name === 'slot') {\\n//                 return;\\n//             }\\n// \\n//             if (prop.name === 'value') {\\n//                 switch (tagName) {\\n//                     case 'textarea':\\n//                         return;\\n// \\n//                     case 'select':\\n//                         sourceBuffer.addRaw('$selectValue = '\\n//                             + compileExprSource.expr(prop.expr)\\n//                             + ' || \\\"\\\";'\\n//                         );\\n//                         return;\\n// \\n//                     case 'option':\\n//                         sourceBuffer.addRaw('$optionValue = '\\n//                             + compileExprSource.expr(prop.expr)\\n//                             + ';'\\n//                         );\\n//                         // value\\n//                         sourceBuffer.addRaw('if ($optionValue != null) {');\\n//                         sourceBuffer.joinRaw('\\\" value=\\\\\\\\\\\"\\\" + $optionValue + \\\"\\\\\\\\\\\"\\\"');\\n//                         sourceBuffer.addRaw('}');\\n// \\n//                         // selected\\n//                         sourceBuffer.addRaw('if ($optionValue === $selectValue) {');\\n//                         sourceBuffer.joinString(' selected');\\n//                         sourceBuffer.addRaw('}');\\n//                         return;\\n//                 }\\n//             }\\n// \\n//             switch (prop.name) {\\n//                 case 'readonly':\\n//                 case 'disabled':\\n//                 case 'multiple':\\n//                     if (prop.raw === '') {\\n//                         sourceBuffer.joinString(' ' + prop.name);\\n//                     }\\n//                     else {\\n//                         sourceBuffer.joinRaw('boolAttrFilter(\\\"' + prop.name + '\\\", '\\n//                             + compileExprSource.expr(prop.expr)\\n//                             + ')'\\n//                         );\\n//                     }\\n//                     break;\\n// \\n//                 case 'checked':\\n//                     if (tagName === 'input') {\\n//                         var valueProp = propsIndex.value;\\n//                         var valueCode = compileExprSource.expr(valueProp.expr);\\n// \\n//                         if (valueProp) {\\n//                             switch (propsIndex.type.raw) {\\n//                                 case 'checkbox':\\n//                                     sourceBuffer.addRaw('if (contains('\\n//                                         + compileExprSource.expr(prop.expr)\\n//                                         + ', '\\n//                                         + valueCode\\n//                                         + ')) {'\\n//                                     );\\n//                                     sourceBuffer.joinString(' checked');\\n//                                     sourceBuffer.addRaw('}');\\n//                                     break;\\n// \\n//                                 case 'radio':\\n//                                     sourceBuffer.addRaw('if ('\\n//                                         + compileExprSource.expr(prop.expr)\\n//                                         + ' === '\\n//                                         + valueCode\\n//                                         + ') {'\\n//                                     );\\n//                                     sourceBuffer.joinString(' checked');\\n//                                     sourceBuffer.addRaw('}');\\n//                                     break;\\n//                             }\\n//                         }\\n//                     }\\n//                     break;\\n// \\n//                 default:\\n//                     if (prop.attr) {\\n//                         sourceBuffer.joinString(' ' + prop.attr);\\n//                     }\\n//                     else {\\n//                         sourceBuffer.joinRaw('attrFilter(\\\"' + prop.name + '\\\", '\\n//                             + (prop.x ? 'escapeHTML(' : '')\\n//                             + compileExprSource.expr(prop.expr)\\n//                             + (prop.x ? ')' : '')\\n//                             + ')'\\n//                         );\\n//                     }\\n//                     break;\\n//             }\\n//         });\\n// \\n//         sourceBuffer.joinString(isClose ? '/>' : '>');\\n//     },\\n//     /* eslint-enable max-params */\\n// \\n//     /**\\n//      * 编译元素闭合\\n//      *\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {string} tagName 标签名\\n//      */\\n//     tagEnd: function (sourceBuffer, tagName) {\\n//         if (!autoCloseTags[tagName]) {\\n//             sourceBuffer.joinString('</' + tagName + '>');\\n//         }\\n// \\n//         if (tagName === 'select') {\\n//             sourceBuffer.addRaw('$selectValue = null;');\\n//         }\\n// \\n//         if (tagName === 'option') {\\n//             sourceBuffer.addRaw('$optionValue = null;');\\n//         }\\n//     },\\n// \\n//     /**\\n//      * 编译元素内容\\n//      *\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {ANode} aNode 元素的抽象节点信息\\n//      * @param {Component} owner 所属组件实例环境\\n//      */\\n//     inner: function (sourceBuffer, aNode, owner) {\\n//         // inner content\\n//         if (aNode.tagName === 'textarea') {\\n//             var valueProp = getANodeProp(aNode, 'value');\\n//             if (valueProp) {\\n//                 sourceBuffer.joinRaw('escapeHTML('\\n//                     + compileExprSource.expr(valueProp.expr)\\n//                     + ')'\\n//                 );\\n//             }\\n// \\n//             return;\\n//         }\\n// \\n//         var htmlDirective = aNode.directives.html;\\n//         if (htmlDirective) {\\n//             sourceBuffer.joinExpr(htmlDirective.value);\\n//         }\\n//         else {\\n//             /* eslint-disable no-use-before-define */\\n//             each(aNode.children, function (aNodeChild) {\\n//                 sourceBuffer.addRaw(aNodeCompiler.compile(aNodeChild, sourceBuffer, owner));\\n//             });\\n//             /* eslint-enable no-use-before-define */\\n//         }\\n//     }\\n// };\\n// \\n// /**\\n//  * ANode 的编译方法集合对象\\n//  *\\n//  * @inner\\n//  */\\n// var aNodeCompiler = {\\n// \\n//     /**\\n//      * 编译节点\\n//      *\\n//      * @param {ANode} aNode 抽象节点\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      * @param {Object} extra 编译所需的一些额外信息\\n//      */\\n//     compile: function (aNode, sourceBuffer, owner, extra) {\\n//         extra = extra || {};\\n//         var compileMethod = 'compileElement';\\n// \\n//         if (aNode.textExpr) {\\n//             compileMethod = 'compileText';\\n//         }\\n//         else if (aNode.directives['if']) { // eslint-disable-line dot-notation\\n//             compileMethod = 'compileIf';\\n//         }\\n//         else if (aNode.directives['for']) { // eslint-disable-line dot-notation\\n//             compileMethod = 'compileFor';\\n//         }\\n//         else if (aNode.tagName === 'slot') {\\n//             compileMethod = 'compileSlot';\\n//         }\\n//         else if (aNode.tagName === 'template') {\\n//             compileMethod = 'compileTemplate';\\n//         }\\n//         else {\\n//             var ComponentType = owner.getComponentType(aNode);\\n//             if (ComponentType) {\\n//                 compileMethod = 'compileComponent';\\n//                 extra.ComponentClass = ComponentType;\\n//             }\\n//         }\\n// \\n//         aNodeCompiler[compileMethod](aNode, sourceBuffer, owner, extra);\\n//     },\\n// \\n//     /**\\n//      * 编译文本节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      */\\n//     compileText: function (aNode, sourceBuffer) {\\n//         if (aNode.textExpr.original) {\\n//             sourceBuffer.joinString(serializeStump('text'));\\n//         }\\n// \\n//         sourceBuffer.joinExpr(aNode.textExpr);\\n// \\n//         if (aNode.textExpr.original) {\\n//             sourceBuffer.joinString(serializeStumpEnd('text'));\\n//         }\\n//     },\\n// \\n//     /**\\n//      * 编译template节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      */\\n//     compileTemplate: function (aNode, sourceBuffer, owner) {\\n//         elementSourceCompiler.inner(sourceBuffer, aNode, owner);\\n//     },\\n// \\n//     /**\\n//      * 编译 if 节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      */\\n//     compileIf: function (aNode, sourceBuffer, owner) {\\n//         sourceBuffer.addRaw('(function () {');\\n// \\n//         sourceBuffer.addRaw('var ifIndex = null;');\\n// \\n//         // output main if\\n//         var ifDirective = aNode.directives['if']; // eslint-disable-line dot-notation\\n//         sourceBuffer.addRaw('if (' + compileExprSource.expr(ifDirective.value) + ') {');\\n//         sourceBuffer.addRaw(\\n//             aNodeCompiler.compile(\\n//                 rinseCondANode(aNode),\\n//                 sourceBuffer,\\n//                 owner\\n//             )\\n//         );\\n//         sourceBuffer.addRaw('}');\\n// \\n//         // output elif and else\\n//         each(aNode.elses, function (elseANode, index) {\\n//             var elifDirective = elseANode.directives.elif;\\n//             if (elifDirective) {\\n//                 sourceBuffer.addRaw('else if (' + compileExprSource.expr(elifDirective.value) + ') {');\\n//             }\\n//             else {\\n//                 sourceBuffer.addRaw('else {');\\n//             }\\n// \\n//             sourceBuffer.addRaw(\\n//                 aNodeCompiler.compile(\\n//                     rinseCondANode(elseANode),\\n//                     sourceBuffer,\\n//                     owner\\n//                 )\\n//             );\\n//             sourceBuffer.addRaw('}');\\n//         });\\n// \\n//         sourceBuffer.addRaw('})();');\\n//     },\\n// \\n//     /**\\n//      * 编译 for 节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      */\\n//     compileFor: function (aNode, sourceBuffer, owner) {\\n//         var forElementANode = createANode({\\n//             children: aNode.children,\\n//             props: aNode.props,\\n//             events: aNode.events,\\n//             tagName: aNode.tagName,\\n//             directives: cloneDirectives(aNode.directives, {\\n//                 'for': 1\\n//             }),\\n//             hotspot: aNode.hotspot\\n//         });\\n// \\n//         var forDirective = aNode.directives['for']; // eslint-disable-line dot-notation\\n//         var itemName = forDirective.item.raw;\\n//         var indexName = forDirective.index.raw;\\n//         var listName = compileExprSource.dataAccess(forDirective.value);\\n// \\n//         if (indexName === '$index') {\\n//             indexName = guid();\\n//         }\\n// \\n//         sourceBuffer.addRaw('for ('\\n//             + 'var ' + indexName + ' = 0; '\\n//             + indexName + ' < ' + listName + '.length; '\\n//             + indexName + '++) {'\\n//         );\\n//         sourceBuffer.addRaw('componentCtx.data.' + indexName + '=' + indexName + ';');\\n//         sourceBuffer.addRaw('componentCtx.data.' + itemName + '= ' + listName + '[' + indexName + '];');\\n//         sourceBuffer.addRaw(\\n//             aNodeCompiler.compile(\\n//                 forElementANode,\\n//                 sourceBuffer,\\n//                 owner\\n//             )\\n//         );\\n//         sourceBuffer.addRaw('}');\\n//     },\\n// \\n//     /**\\n//      * 编译 slot 节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      */\\n//     compileSlot: function (aNode, sourceBuffer, owner) {\\n//         sourceBuffer.addRaw('(function () {');\\n// \\n//         sourceBuffer.addRaw('function $defaultSlotRender(componentCtx) {');\\n//         sourceBuffer.addRaw('  var html = \\\"\\\";');\\n//         each(aNode.children, function (aNodeChild) {\\n//             sourceBuffer.addRaw(aNodeCompiler.compile(aNodeChild, sourceBuffer, owner));\\n//         });\\n//         sourceBuffer.addRaw('  return html;');\\n//         sourceBuffer.addRaw('}');\\n// \\n//         sourceBuffer.addRaw('  var $givenSlot = [];');\\n// \\n//         var nameProp = getANodeProp(aNode, 'name');\\n//         if (nameProp) {\\n//             sourceBuffer.addRaw('var $slotName = ' + compileExprSource.expr(nameProp.expr) + ';');\\n//         }\\n//         else {\\n//             sourceBuffer.addRaw('var $slotName = null;');\\n//         }\\n// \\n//         sourceBuffer.addRaw('var $ctxGivenSlots = componentCtx.givenSlots;');\\n//         sourceBuffer.addRaw('for (var $i = 0; $i < $ctxGivenSlots.length; $i++) {');\\n//         sourceBuffer.addRaw('  if ($ctxGivenSlots[$i][1] == $slotName) {');\\n//         sourceBuffer.addRaw('    $givenSlot.push($ctxGivenSlots[$i][0]);');\\n//         sourceBuffer.addRaw('  }');\\n//         sourceBuffer.addRaw('}');\\n// \\n// \\n//         sourceBuffer.addRaw('var $isInserted = $givenSlot.length > 0;');\\n//         sourceBuffer.addRaw('if (!$isInserted) { $givenSlot.push($defaultSlotRender); }');\\n// \\n//         sourceBuffer.addRaw('var $slotCtx = $isInserted ? componentCtx.owner : componentCtx;');\\n//         if (aNode.vars) {\\n//             sourceBuffer.addRaw('$slotCtx = {data: extend({}, $slotCtx.data), filters: $slotCtx.filters, callFilter: $slotCtx.callFilter};'); // eslint-disable-line\\n//             each(aNode.vars, function (varItem) {\\n//                 sourceBuffer.addRaw(\\n//                     '$slotCtx.data[\\\"' + varItem.name + '\\\"] = '\\n//                     + compileExprSource.expr(varItem.expr)\\n//                     + ';'\\n//                 );\\n//             });\\n//         }\\n// \\n//         sourceBuffer.addRaw('for (var $renderIndex = 0; $renderIndex < $givenSlot.length; $renderIndex++) {');\\n//         sourceBuffer.addRaw('  html += $givenSlot[$renderIndex]($slotCtx);');\\n//         sourceBuffer.addRaw('}');\\n// \\n//         sourceBuffer.addRaw('})();');\\n//     },\\n// \\n//     /**\\n//      * 编译普通节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      * @param {Object} extra 编译所需的一些额外信息\\n//      */\\n//     compileElement: function (aNode, sourceBuffer, owner, extra) {\\n//         extra = extra || {};\\n//         // if (aNode.tagName === 'option'\\n//         //     && !getANodeProp(aNode, 'value')\\n//         //     && aNode.children[0]\\n//         // ) {\\n//         //     aNode.props.push({\\n//         //         name: 'value',\\n//         //         expr: aNode.children[0].textExpr\\n//         //     });\\n//         // }\\n// \\n//         elementSourceCompiler.tagStart(\\n//             sourceBuffer,\\n//             aNode.tagName,\\n//             aNode.props,\\n//             extra.prop\\n//         );\\n// \\n//         elementSourceCompiler.inner(sourceBuffer, aNode, owner);\\n//         elementSourceCompiler.tagEnd(sourceBuffer, aNode.tagName);\\n//     },\\n// \\n//     /**\\n//      * 编译组件节点\\n//      *\\n//      * @param {ANode} aNode 节点对象\\n//      * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//      * @param {Component} owner 所属组件实例环境\\n//      * @param {Object} extra 编译所需的一些额外信息\\n//      * @param {Function} extra.ComponentClass 对应组件类\\n//      */\\n//     compileComponent: function (aNode, sourceBuffer, owner, extra) {\\n//         if (aNode) {\\n//             sourceBuffer.addRaw('var $slotName = null;');\\n//             sourceBuffer.addRaw('var $givenSlots = [];');\\n//             each(aNode.children, function (child) {\\n//                 var slotBind = !child.textExpr && getANodeProp(child, 'slot');\\n//                 if (slotBind) {\\n//                     sourceBuffer.addRaw('$slotName = ' + compileExprSource.expr(slotBind.expr) + ';');\\n//                     sourceBuffer.addRaw('$givenSlots.push([function (componentCtx) {');\\n//                     sourceBuffer.addRaw('  var html = \\\"\\\";');\\n//                     sourceBuffer.addRaw(aNodeCompiler.compile(child, sourceBuffer, owner));\\n//                     sourceBuffer.addRaw('  return html;');\\n//                     sourceBuffer.addRaw('}, $slotName]);');\\n//                 }\\n//                 else {\\n//                     sourceBuffer.addRaw('$givenSlots.push([function (componentCtx) {');\\n//                     sourceBuffer.addRaw('  var html = \\\"\\\";');\\n//                     sourceBuffer.addRaw(aNodeCompiler.compile(child, sourceBuffer, owner));\\n//                     sourceBuffer.addRaw('  return html;');\\n//                     sourceBuffer.addRaw('}]);');\\n//                 }\\n//             });\\n//         }\\n// \\n//         var ComponentClass = extra.ComponentClass;\\n//         var component = new ComponentClass({\\n//             aNode: aNode,\\n//             owner: owner,\\n//             subTag: aNode.tagName\\n//         });\\n// \\n//         var givenData = [];\\n// \\n//         each(component.binds, function (prop) {\\n//             givenData.push(\\n//                 compileExprSource.stringLiteralize(prop.name)\\n//                 + ':'\\n//                 + compileExprSource.expr(prop.expr)\\n//             );\\n//         });\\n// \\n//         sourceBuffer.addRaw('html += (');\\n//         sourceBuffer.addRendererStart();\\n//         compileComponentSource(sourceBuffer, component, extra && extra.prop);\\n//         sourceBuffer.addRendererEnd();\\n//         sourceBuffer.addRaw(')({' + givenData.join(',\\\\n') + '}, componentCtx, $givenSlots);');\\n//         sourceBuffer.addRaw('$givenSlots = null;');\\n//     }\\n// };\\n// /* eslint-disable guard-for-in */\\n// \\n// /**\\n//  * 生成组件 renderer 时 ctx 对象构建的代码\\n//  *\\n//  * @inner\\n//  * @param {CompileSourceBuffer} sourceBuffer 编译源码的中间buffer\\n//  * @param {Object} component 组件实例\\n//  * @param {string?} extraProp 额外的属性串\\n//  */\\n// function compileComponentSource(sourceBuffer, component, extraProp) {\\n//     sourceBuffer.addRaw(genComponentContextCode(component));\\n//     sourceBuffer.addRaw('componentCtx.owner = parentCtx;');\\n//     sourceBuffer.addRaw('componentCtx.givenSlots = givenSlots;');\\n// \\n// \\n//     sourceBuffer.addRaw('data = extend(componentCtx.data, data);');\\n//     sourceBuffer.addRaw('for (var $i = 0; $i < componentCtx.computedNames.length; $i++) {');\\n//     sourceBuffer.addRaw('  var $computedName = componentCtx.computedNames[$i];');\\n//     sourceBuffer.addRaw('  data[$computedName] = componentCtx.computed[$computedName]();');\\n//     sourceBuffer.addRaw('}');\\n// \\n//     extraProp = extraProp || '';\\n// \\n//     var eventDeclarations = [];\\n//     for (var key in component.listeners) {\\n//         each(component.listeners[key], function (listener) {\\n//             if (listener.declaration) {\\n//                 eventDeclarations.push(listener.declaration);\\n//             }\\n//         });\\n//     }\\n// \\n//     elementSourceCompiler.tagStart(\\n//         sourceBuffer,\\n//         component.tagName,\\n//         component.aNode.props,\\n//         extraProp\\n//     );\\n// \\n//     if (!component.owner) {\\n//         sourceBuffer.joinString('\\x3c!--s-data:');\\n//         sourceBuffer.joinDataStringify();\\n//         sourceBuffer.joinString('--\\x3e');\\n//     }\\n// \\n// \\n// \\n//     elementSourceCompiler.inner(sourceBuffer, component.aNode, component);\\n//     elementSourceCompiler.tagEnd(sourceBuffer, component.tagName);\\n// }\\n// \\n// var stringifier = {\\n//     obj: function (source) {\\n//         var prefixComma;\\n//         var result = '{';\\n// \\n//         for (var key in source) {\\n//             if (typeof source[key] === 'undefined') {\\n//                 continue;\\n//             }\\n// \\n//             if (prefixComma) {\\n//                 result += ',';\\n//             }\\n//             prefixComma = 1;\\n// \\n//             result += compileExprSource.stringLiteralize(key) + ':' + stringifier.any(source[key]);\\n//         }\\n// \\n//         return result + '}';\\n//     },\\n// \\n//     arr: function (source) {\\n//         var prefixComma;\\n//         var result = '[';\\n// \\n//         each(source, function (value) {\\n//             if (prefixComma) {\\n//                 result += ',';\\n//             }\\n//             prefixComma = 1;\\n// \\n//             result += stringifier.any(value);\\n//         });\\n// \\n//         return result + ']';\\n//     },\\n// \\n//     str: function (source) {\\n//         return compileExprSource.stringLiteralize(source);\\n//     },\\n// \\n//     date: function (source) {\\n//         return 'new Date(' + source.getTime() + ')';\\n//     },\\n// \\n//     any: function (source) {\\n//         switch (typeof source) {\\n//             case 'string':\\n//                 return stringifier.str(source);\\n// \\n//             case 'number':\\n//                 return '' + source;\\n// \\n//             case 'boolean':\\n//                 return source ? 'true' : 'false';\\n// \\n//             case 'object':\\n//                 if (!source) {\\n//                     return null;\\n//                 }\\n// \\n//                 if (source instanceof Array) {\\n//                     return stringifier.arr(source);\\n//                 }\\n// \\n//                 if (source instanceof Date) {\\n//                     return stringifier.date(source);\\n//                 }\\n// \\n//                 return stringifier.obj(source);\\n//         }\\n// \\n//         throw new Error('Cannot Stringify:' + source);\\n//     }\\n// };\\n// \\n// /**\\n//  * 生成组件 renderer 时 ctx 对象构建的代码\\n//  *\\n//  * @inner\\n//  * @param {Object} component 组件实例\\n//  * @return {string}\\n//  */\\n// function genComponentContextCode(component) {\\n//     var code = ['var componentCtx = {'];\\n// \\n//     // given anode\\n//     code.push('givenSlots: [],');\\n// \\n//     // filters\\n//     code.push('filters: {');\\n//     var filterCode = [];\\n//     for (var key in component.filters) {\\n//         var filter = component.filters[key];\\n// \\n//         if (typeof filter === 'function') {\\n//             filterCode.push(key + ': ' + filter.toString());\\n//         }\\n//     }\\n//     code.push(filterCode.join(','));\\n//     code.push('},');\\n// \\n//     code.push(\\n//         'callFilter: function (name, args) {',\\n//         '    var filter = this.filters[name] || DEFAULT_FILTERS[name];',\\n//         '    if (typeof filter === \\\"function\\\") {',\\n//         '        return filter.apply(this, args);',\\n//         '    }',\\n//         '},'\\n//     );\\n// \\n//     /* eslint-disable no-redeclare */\\n//     // computed obj\\n//     code.push('computed: {');\\n//     var computedCode = [];\\n//     for (var key in component.computed) {\\n//         var computed = component.computed[key];\\n// \\n//         if (typeof computed === 'function') {\\n//             computedCode.push(key + ': '\\n//                 + computed.toString().replace(\\n//                     /this.data.get\\\\(([^\\\\)]+)\\\\)/g,\\n//                     function (match, exprLiteral) {\\n//                         var exprStr = (new Function('return ' + exprLiteral))();\\n//                         var expr = parseExpr(exprStr);\\n// \\n//                         return compileExprSource.expr(expr);\\n//                     })\\n//             );\\n//         }\\n//     }\\n//     code.push(computedCode.join(','));\\n//     code.push('},');\\n// \\n//     // computed names\\n//     code.push('computedNames: [');\\n//     computedCode = [];\\n//     for (var key in component.computed) {\\n//         var computed = component.computed[key];\\n// \\n//         if (typeof computed === 'function') {\\n//             computedCode.push('\\\"' + key + '\\\"');\\n//         }\\n//     }\\n//     code.push(computedCode.join(','));\\n//     code.push('],');\\n//     /* eslint-enable no-redeclare */\\n// \\n//     // data\\n//     code.push('data: ' + stringifier.any(component.data.get()) + ',');\\n// \\n//     // tagName\\n//     code.push('tagName: \\\"' + component.tagName + '\\\"');\\n//     code.push('};');\\n// \\n//     return code.join('\\\\n');\\n// }\\n// \\n// /* eslint-enable guard-for-in */\\n// \\n// /* eslint-disable no-unused-vars */\\n// /* eslint-disable fecs-camelcase */\\n// \\n// /**\\n//  * 组件编译的模板函数\\n//  *\\n//  * @inner\\n//  */\\n// function componentCompilePreCode() {\\n//     var $version = '3.5.7';\\n// \\n//     function extend(target, source) {\\n//         if (source) {\\n//             Object.keys(source).forEach(function (key) {\\n//                 let value = source[key];\\n//                 if (typeof value !== 'undefined') {\\n//                     target[key] = value;\\n//                 }\\n//             });\\n//         }\\n// \\n//         return target;\\n//     }\\n// \\n//     function each(array, iterator) {\\n//         if (array && array.length > 0) {\\n//             for (var i = 0, l = array.length; i < l; i++) {\\n//                 if (iterator(array[i], i) === false) {\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//     }\\n// \\n//     function contains(array, value) {\\n//         var result;\\n//         each(array, function (item) {\\n//             result = item === value;\\n//             return !result;\\n//         });\\n// \\n//         return result;\\n//     }\\n// \\n//     var HTML_ENTITY = {\\n//         /* jshint ignore:start */\\n//         '&': '&amp;',\\n//         '<': '&lt;',\\n//         '>': '&gt;',\\n//         '\\\"': '&quot;',\\n//         /* eslint-disable quotes */\\n//         \\\"'\\\": '&#39;'\\n//         /* eslint-enable quotes */\\n//         /* jshint ignore:end */\\n//     };\\n// \\n//     function htmlFilterReplacer(c) {\\n//         return HTML_ENTITY[c];\\n//     }\\n// \\n//     function escapeHTML(source) {\\n//         if (source == null) {\\n//             return '';\\n//         }\\n// \\n//         return String(source).replace(/[&<>\\\"']/g, htmlFilterReplacer);\\n//     }\\n// \\n//     var DEFAULT_FILTERS = {\\n//         url: encodeURIComponent,\\n//         _class: function (source) {\\n//             if (source instanceof Array) {\\n//                 return source.join(' ');\\n//             }\\n// \\n//             return source;\\n//         },\\n//         _style: function (source) {\\n//             if (typeof source === 'object') {\\n//                 var result = '';\\n//                 if (source) {\\n//                     Object.keys(source).forEach(function (key) {\\n//                         result += key + ':' + source[key] + ';';\\n//                     });\\n//                 }\\n// \\n//                 return result;\\n//             }\\n// \\n//             return source || '';\\n//         },\\n//         _sep: function (source, sep) {\\n//             return source ? sep + source : '';\\n//         }\\n//     };\\n// \\n//     function attrFilter(name, value) {\\n//         if (value) {\\n//             return ' ' + name + '=\\\"' + value + '\\\"';\\n//         }\\n// \\n//         return '';\\n//     }\\n// \\n//     function boolAttrFilter(name, value) {\\n//         if (value && value !== 'false' && value !== '0') {\\n//             return ' ' + name;\\n//         }\\n// \\n//         return '';\\n//     }\\n// \\n//     function stringLiteralize(source) {\\n//         return '\\\"'\\n//             + source\\n//                 .replace(/\\\\x5C/g, '\\\\\\\\\\\\\\\\')\\n//                 .replace(/\\\"/g, '\\\\\\\\\\\"')\\n//                 .replace(/\\\\x0A/g, '\\\\\\\\n')\\n//                 .replace(/\\\\x09/g, '\\\\\\\\t')\\n//                 .replace(/\\\\x0D/g, '\\\\\\\\r')\\n//             + '\\\"';\\n//     }\\n// \\n//     var stringifier = {\\n//         obj: function (source) {\\n//             var prefixComma;\\n//             var result = '{';\\n// \\n//             Object.keys(source).forEach(function (key) {\\n//                 if (typeof source[key] === 'undefined') {\\n//                     return;\\n//                 }\\n// \\n//                 if (prefixComma) {\\n//                     result += ',';\\n//                 }\\n//                 prefixComma = 1;\\n// \\n//                 result += stringLiteralize(key) + ':' + stringifier.any(source[key]);\\n//             });\\n// \\n//             return result + '}';\\n//         },\\n// \\n//         arr: function (source) {\\n//             var prefixComma;\\n//             var result = '[';\\n// \\n//             each(source, function (value) {\\n//                 if (prefixComma) {\\n//                     result += ',';\\n//                 }\\n//                 prefixComma = 1;\\n// \\n//                 result += stringifier.any(value);\\n//             });\\n// \\n//             return result + ']';\\n//         },\\n// \\n//         str: function (source) {\\n//             return stringLiteralize(source);\\n//         },\\n// \\n//         date: function (source) {\\n//             return 'new Date(' + source.getTime() + ')';\\n//         },\\n// \\n//         any: function (source) {\\n//             switch (typeof source) {\\n//                 case 'string':\\n//                     return stringifier.str(source);\\n// \\n//                 case 'number':\\n//                     return '' + source;\\n// \\n//                 case 'boolean':\\n//                     return source ? 'true' : 'false';\\n// \\n//                 case 'object':\\n//                     if (!source) {\\n//                         return null;\\n//                     }\\n// \\n//                     if (source instanceof Array) {\\n//                         return stringifier.arr(source);\\n//                     }\\n// \\n//                     if (source instanceof Date) {\\n//                         return stringifier.date(source);\\n//                     }\\n// \\n//                     return stringifier.obj(source);\\n//             }\\n// \\n//             throw new Error('Cannot Stringify:' + source);\\n//         }\\n//     };\\n// }\\n// /* eslint-enable no-unused-vars */\\n// /* eslint-enable fecs-camelcase */\\n// \\n// /**\\n//  * 将组件编译成 render 方法的 js 源码\\n//  *\\n//  * @param {Function} ComponentClass 组件类\\n//  * @return {string}\\n//  */\\n// function compileJSSource(ComponentClass) {\\n//     var sourceBuffer = new CompileSourceBuffer();\\n// \\n//     sourceBuffer.addRendererStart();\\n//     sourceBuffer.addRaw(\\n//         componentCompilePreCode.toString()\\n//             .split('\\\\n')\\n//             .slice(1)\\n//             .join('\\\\n')\\n//             .replace(/\\\\}\\\\s*$/, '')\\n//     );\\n// \\n//     // 先初始化个实例，让模板编译成 ANode，并且能获得初始化数据\\n//     var component = new ComponentClass();\\n// \\n//     compileComponentSource(sourceBuffer, component);\\n//     sourceBuffer.addRendererEnd();\\n//     return sourceBuffer.toCode();\\n// }\\n// #[end]\\n\\n// exports = module.exports = compileJSSource;\\n\\n    /* eslint-disable no-unused-vars */\\n//     var nextTick = require('./util/next-tick');\\n//     var inherits = require('./util/inherits');\\n//     var parseTemplate = require('./parser/parse-template');\\n//     var parseExpr = require('./parser/parse-expr');\\n//     var ExprType = require('./parser/expr-type');\\n//     var LifeCycle = require('./view/life-cycle');\\n//     var NodeType = require('./view/node-type');\\n//     var Component = require('./view/component');\\n//     var compileComponent = require('./view/compile-component');\\n//     var defineComponent = require('./view/define-component');\\n//     var emitDevtool = require('./util/emit-devtool');\\n//     var compileJSSource = require('./view/compile-js-source');\\n//     var Data = require('./runtime/data');\\n//     var evalExpr = require('./runtime/eval-expr');\\n//     var DataTypes = require('./util/data-types');\\n\\n\\n    var san = {\\n        /**\\n         * san版本号\\n         *\\n         * @type {string}\\n         */\\n        version: '3.5.7',\\n\\n        // #[begin] devtool\\n        /**\\n         * 是否开启调试。开启调试时 devtool 会工作\\n         *\\n         * @type {boolean}\\n         */\\n        debug: true,\\n        // #[end]\\n\\n        // #[begin] ssr\\n//         /**\\n//          * 将组件类编译成 renderer 方法\\n//          *\\n//          * @param {Function} ComponentClass 组件类\\n//          * @return {function(Object):string}\\n//          */\\n//         compileToRenderer: function (ComponentClass) {\\n//             var renderer = ComponentClass.__ssrRenderer;\\n// \\n//             if (!renderer) {\\n//                 var code = compileJSSource(ComponentClass);\\n//                 renderer = (new Function('return ' + code))();\\n//                 ComponentClass.__ssrRenderer = renderer;\\n//             }\\n// \\n//             return renderer;\\n//         },\\n// \\n//         /**\\n//          * 将组件类编译成 renderer 方法的源文件\\n//          *\\n//          * @param {Function} ComponentClass 组件类\\n//          * @return {string}\\n//          */\\n//         compileToSource: compileJSSource,\\n        // #[end]\\n\\n        /**\\n         * 组件基类\\n         *\\n         * @type {Function}\\n         */\\n        Component: Component,\\n\\n        /**\\n         * 创建组件类\\n         *\\n         * @param {Object} proto 组件类的方法表\\n         * @return {Function}\\n         */\\n        defineComponent: defineComponent,\\n\\n        /**\\n         * 编译组件类。预解析template和components\\n         *\\n         * @param {Function} ComponentClass 组件类\\n         */\\n        compileComponent: compileComponent,\\n\\n        /**\\n         * 解析 template\\n         *\\n         * @inner\\n         * @param {string} source template 源码\\n         * @return {ANode}\\n         */\\n        parseTemplate: parseTemplate,\\n\\n        /**\\n         * 解析表达式\\n         *\\n         * @param {string} source 源码\\n         * @return {Object}\\n         */\\n        parseExpr: parseExpr,\\n\\n        /**\\n         * 表达式类型枚举\\n         *\\n         * @const\\n         * @type {Object}\\n         */\\n        ExprType: ExprType,\\n\\n        /**\\n         * 生命周期\\n         */\\n        LifeCycle: LifeCycle,\\n\\n        /**\\n         * 节点类型\\n         *\\n         * @const\\n         * @type {Object}\\n         */\\n        NodeType: NodeType,\\n\\n        /**\\n         * 在下一个更新周期运行函数\\n         *\\n         * @param {Function} fn 要运行的函数\\n         */\\n        nextTick: nextTick,\\n\\n        /**\\n         * 数据类\\n         *\\n         * @class\\n         * @param {Object?} data 初始数据\\n         * @param {Data?} parent 父级数据对象\\n         */\\n        Data: Data,\\n\\n        /**\\n         * 计算表达式的值\\n         *\\n         * @param {Object} expr 表达式对象\\n         * @param {Data} data 数据对象\\n         * @param {Component=} owner 组件对象，用于表达式中filter的执行\\n         * @return {*}\\n         */\\n        evalExpr: evalExpr,\\n\\n        /**\\n         * 构建类之间的继承关系\\n         *\\n         * @param {Function} subClass 子类函数\\n         * @param {Function} superClass 父类函数\\n         */\\n        inherits: inherits,\\n\\n        /**\\n         * DataTypes\\n         *\\n         * @type {Object}\\n         */\\n        DataTypes: DataTypes\\n    };\\n\\n    // export\\n    if (true) {\\n        // For CommonJS\\n        exports = module.exports = san;\\n    }\\n    else {}\\n\\n    // #[begin] devtool\\n    emitDevtool.start(san);\\n    // #[end]\\n})(this);\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14).setImmediate))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuL2Rpc3Qvc2FuLmRldi5qcz8zYTA1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsNkJBQTZCO0FBQ3hDO0FB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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQsaUNBQWlDLGVBQWU7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVB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OztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7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QSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLFdBQVc7QUFDOUIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2FuXG4gKiBDb3B5cmlnaHQgMjAxNiBCYWlkdSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQGZpbGUg5Li75paH5Lu2XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgb3Rha3VzdGF5KG90YWt1c3RheUBnbWFpbC5jb20pXG4gKiAgICAgICAgIGp1bm1lcihqdW5tZXJAZm94bWFpbC5jb20pXG4gKi9cblxuKGZ1bmN0aW9uIChyb290KSB7XG4gICAgLy8g5Lq65bel6LCD5pW05omT5YyF5Luj56CB6aG65bqP77yM6YCa6L+H5rOo6YeK5omL5bel5YaZ5LiA5Lqb5L6d6LWWXG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2d1aWQnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3V0aWwvZW1wdHknKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3V0aWwvZXh0ZW5kJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2VhY2gnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3V0aWwvY29udGFpbnMnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3V0aWwvYmluZCcpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9vbicpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci91bicpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9zdmctdGFncycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9jcmVhdGUtZWwnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvcmVtb3ZlLWVsJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL25leHQtdGljaycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9pZScpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vYnJvd3Nlci9pZS1vbGQtdGhhbi05Jyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9icm93c2VyL2lucHV0LWV2ZW50LWNvbXBhdGlibGUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL2Jyb3dzZXIvYXV0by1jbG9zZS10YWdzJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi91dGlsL2RhdGEtdHlwZXMuanMnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3V0aWwvY3JlYXRlLWRhdGEtdHlwZXMtY2hlY2tlci5qcycpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vcGFyc2VyL3dhbGtlcicpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vcGFyc2VyL2NyZWF0ZS1hLW5vZGUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3BhcnNlci9wYXJzZS10ZW1wbGF0ZScpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vcnVudGltZS9jaGFuZ2UtZXhwci1jb21wYXJlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi9ydW50aW1lL2RhdGEtY2hhbmdlLXR5cGUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3J1bnRpbWUvZGVmYXVsdC1maWx0ZXJzJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi92aWV3L2xpZmUtY3ljbGUnKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3ZpZXcvbm9kZS10eXBlJyk7XG4vLyAgICAgLy8gcmVxdWlyZSgnLi92aWV3L2dldC1wcm9wLWhhbmRsZXInKTtcbi8vICAgICAvLyByZXF1aXJlKCcuL3ZpZXcvaXMtZGF0YS1jaGFuZ2UtYnktZWxlbWVudCcpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdmlldy9ldmVudC1kZWNsYXJhdGlvbi1saXN0ZW5lcicpO1xuLy8gICAgIC8vIHJlcXVpcmUoJy4vdmlldy9jcmVhdGUtbm9kZScpO1xuXG5cbiAgICAvKipcbiAqIEBmaWxlIOeUn+aIkOWUr+S4gGlkXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8qKlxuICog5ZSv5LiAaWTnmoTotbflp4vlgLxcbiAqXG4gKiBAaW5uZXJcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBndWlkSW5kZXggPSAxO1xuXG4vKipcbiAqIOWUr+S4gGlk55qE5YmN57yAXG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgZ3VpZFByZWZpeCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkudG9TdHJpbmcoMTYpLnNsaWNlKDgpO1xuXG4vKipcbiAqIOiOt+WPluWUr+S4gGlkXG4gKlxuICogQGlubmVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IOWUr+S4gGlkXG4gKi9cbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgcmV0dXJuICdfJyArIGd1aWRQcmVmaXggKyAoZ3VpZEluZGV4KyspO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBndWlkO1xuXG5cbi8qKlxuICogQGZpbGUg56m65Ye95pWwXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8qKlxuICog5ZWl6YO95LiN5bmyXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZW1wdHk7XG5cblxuLyoqXG4gKiBAZmlsZSDlsZ7mgKfmi7fotJ1cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5a+56LGh5bGe5oCn5ou36LSdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCDnm67moIflr7nosaFcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ug5rqQ5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuebruagh+WvueixoVxuICovXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cblxuLyoqXG4gKiBAZmlsZSDmnoTlu7rnsbvkuYvpl7TnmoTnu6fmib/lhbPns7tcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG4vKipcbiAqIOaehOW7uuexu+S5i+mXtOeahOe7p+aJv+WFs+ezu1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YkNsYXNzIOWtkOexu+WHveaVsFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyDniLbnsbvlh73mlbBcbiAqL1xuZnVuY3Rpb24gaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAvKiBqc2hpbnQgLVcwNTQgKi9cbiAgICB2YXIgc3ViQ2xhc3NQcm90byA9IHN1YkNsYXNzLnByb3RvdHlwZTtcbiAgICB2YXIgRiA9IG5ldyBGdW5jdGlvbigpO1xuICAgIEYucHJvdG90eXBlID0gc3VwZXJDbGFzcy5wcm90b3R5cGU7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBleHRlbmQoc3ViQ2xhc3MucHJvdG90eXBlLCBzdWJDbGFzc1Byb3RvKTtcbiAgICAvKiBqc2hpbnQgK1cwNTQgKi9cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW5oZXJpdHM7XG5cblxuLyoqXG4gKiBAZmlsZSDpgY3ljobmlbDnu4RcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDpgY3ljobmlbDnu4Tpm4blkIhcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSDmlbDnu4TmupBcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQW55LG51bWJlcik6Ym9vbGVhbn0gaXRlcmF0b3Ig6YGN5Y6G5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIGVhY2goYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgaWYgKGFycmF5ICYmIGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcihhcnJheVtpXSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDliKTmlq3mlbDnu4TkuK3mmK/lkKbljIXlkKvmn5DpoblcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi9lYWNoJyk7XG5cbi8qKlxuICog5Yik5pat5pWw57uE5Lit5piv5ZCm5YyF5ZCr5p+Q6aG5XG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkg5pWw57uEXG4gKiBAcGFyYW0geyp9IHZhbHVlIOWMheWQq+eahOmhuVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGVhY2goYXJyYXksIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJlc3VsdCA9IGl0ZW0gPT09IHZhbHVlO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuXG5cbi8qKlxuICogQGZpbGUgYmluZOWHveaVsFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCDmlrnms5XnmoTlhbzlrrnmgKflsIHoo4VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIOimgWJpbmTnmoTlh73mlbBcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIHRoaXPmjIflkJHlr7nosaFcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyDpooTorr7nmoTliJ3lp4vlj4LmlbBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICB2YXIgbmF0aXZlQmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICAvLyAjW2JlZ2luXSBhbGx1YVxuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkge1xuICAgIC8vICNbZW5kXVxuICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICAvLyAjW2VuZF1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gYmluZDtcblxuXG4vKipcbiAqIEBmaWxlIERPTSDkuovku7bmjILovb1cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogRE9NIOS6i+S7tuaMgui9vVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRE9N5YWD57SgXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5Ye95pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5piv5o2V6I636Zi25q61XG4gKi9cbmZ1bmN0aW9uIG9uKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgLy8gI1tiZWdpbl0gYWxsdWFcbiAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vICNbZW5kXVxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuXG4vKipcbiAqIEBmaWxlIERPTSDkuovku7bljbjovb1cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogRE9NIOS6i+S7tuWNuOi9vVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRE9N5YWD57SgXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5Ye95pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5piv5o2V6I636Zi25q61XG4gKi9cbmZ1bmN0aW9uIHVuKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgLy8gI1tiZWdpbl0gYWxsdWFcbiAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vICNbZW5kXVxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIC8vICNbYmVnaW5dIGFsbHVhXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB1bjtcblxuXG4vKipcbiAqIEBmaWxlIOWwhuWtl+espuS4sumAl+WPt+WIh+WIhui/lOWbnuWvueixoVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcblxuLyoqXG4gKiDlsIblrZfnrKbkuLLpgJflj7fliIfliIbov5Tlm57lr7nosaFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOWtl+espuS4slxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBzcGxpdFN0cjJPYmooc291cmNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGVhY2goXG4gICAgICAgIHNvdXJjZS5zcGxpdCgnLCcpLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IDE7XG4gICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNwbGl0U3RyMk9iajtcblxuXG4vKipcbiAqIEBmaWxlIFNWR+agh+etvuihqFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHNwbGl0U3RyMk9iaiA9IHJlcXVpcmUoJy4uL3V0aWwvc3BsaXQtc3RyLTItb2JqJyk7XG5cbi8qKlxuICogc3ZnVGFnc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9zdmdkdGQuaHRtbCDlj6rlj5bluLjnlKhcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzdmdUYWdzID0gc3BsaXRTdHIyT2JqKCcnXG4gICAgLy8gc3RydWN0dXJlXG4gICAgKyAnc3ZnLGcsZGVmcyxkZXNjLG1ldGFkYXRhLHN5bWJvbCx1c2UsJ1xuICAgIC8vIGltYWdlICYgc2hhcGVcbiAgICArICdpbWFnZSxwYXRoLHJlY3QsY2lyY2xlLGxpbmUsZWxsaXBzZSxwb2x5bGluZSxwb2x5Z29uLCdcbiAgICAvLyB0ZXh0XG4gICAgKyAndGV4dCx0c3Bhbix0cmVmLHRleHRwYXRoLCdcbiAgICAvLyBvdGhlclxuICAgICsgJ21hcmtlcixwYXR0ZXJuLGNsaXBwYXRoLG1hc2ssZmlsdGVyLGN1cnNvcix2aWV3LGFuaW1hdGUsJ1xuICAgIC8vIGZvbnRcbiAgICArICdmb250LGZvbnQtZmFjZSxnbHlwaCxtaXNzaW5nLWdseXBoJyk7XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN2Z1RhZ3M7XG5cblxuLyoqXG4gKiBAZmlsZSBET03liJvlu7pcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBzdmdUYWdzID0gcmVxdWlyZSgnLi9zdmctdGFncycpO1xuXG4vKipcbiAqIOWIm+W7uiBET00g5YWD57SgXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lIHRhZ05hbWVcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbCh0YWdOYW1lKSB7XG4gICAgaWYgKHN2Z1RhZ3NbdGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWdOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRWw7XG5cblxuLyoqXG4gKiBAZmlsZSDnp7vpmaRET01cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5bCGIERPTSDku47pobXpnaLkuK3np7vpmaRcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBET03lhYPntKBcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRWwoZWwpIHtcbiAgICBpZiAoZWwgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZUVsO1xuXG5cbi8qKlxuICogQGZpbGUg5Zyo5LiL5LiA5Liq5pe26Ze05ZGo5pyf6L+Q6KGM5Lu75YqhXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyDor6Xmlrnms5Xlj4LnhafkuoZ2dWUyLjUuMOeahOWunueOsO+8jOaEn+iwonZ1ZeWboumYn1xuLy8gU0VFOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvMDk0OGQ5OTlmMmZkZGY5ZjkwOTkxOTU2NDkzZjk3NjI3M2M1ZGExZi9zcmMvY29yZS91dGlsL2Vudi5qcyNMNjhcblxuXG4vLyB2YXIgYmluZCA9IHJlcXVpcmUoJy4vYmluZCcpO1xuXG4vKipcbiAqIOS4i+S4gOS4quWRqOacn+imgeaJp+ihjOeahOS7u+WKoeWIl+ihqFxuICpcbiAqIEBpbm5lclxuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgbmV4dFRhc2tzID0gW107XG5cbi8qKlxuICog5omn6KGM5LiL5LiA5Liq5ZGo5pyf5Lu75Yqh55qE5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciBuZXh0SGFuZGxlcjtcblxuLyoqXG4gKiDmtY/op4jlmajmmK/lkKbmlK/mjIHljp/nlJ9Qcm9taXNlXG4gKiDlr7lQcm9taXNl5YGa5Yik5pat77yM5piv5Li65LqG56aB55So5LiA5Lqb5LiN5Lil6LCo55qEUHJvbWlzZeeahHBvbHlmaWxsXG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzTmF0aXZlUHJvbWlzZSA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChQcm9taXNlKTtcblxuLyoqXG4gKiDlnKjkuIvkuIDkuKrml7bpl7TlkajmnJ/ov5DooYzku7vliqFcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgei/kOihjOeahOS7u+WKoeWHveaVsFxuICogQHBhcmFtIHtPYmplY3Q9fSB0aGlzQXJnIHRoaXPmjIflkJHlr7nosaFcbiAqL1xuZnVuY3Rpb24gbmV4dFRpY2soZm4sIHRoaXNBcmcpIHtcbiAgICBpZiAodGhpc0FyZykge1xuICAgICAgICBmbiA9IGJpbmQoZm4sIHRoaXNBcmcpO1xuICAgIH1cbiAgICBuZXh0VGFza3MucHVzaChmbik7XG5cbiAgICBpZiAobmV4dEhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFza3MgPSBuZXh0VGFza3Muc2xpY2UoMCk7XG4gICAgICAgIG5leHRUYXNrcyA9IFtdO1xuICAgICAgICBuZXh0SGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRhc2tzW2ldKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8g6Z2e5qCH5YeG5pa55rOV77yM5L2G5piv5q2k5pa55rOV6Z2e5bi45ZC75ZCI6KaB5rGC44CCXG4gICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKG5leHRIYW5kbGVyKTtcbiAgICB9XG4gICAgLy8g55SoTWVzc2FnZUNoYW5uZWzljrvlgZpzZXRJbW1lZGlhdGXnmoRwb2x5ZmlsbFxuICAgIC8vIOWOn+eQhuaYr+WwhuaWsOeahG1lc3NhZ2Xkuovku7bliqDlhaXliLDljp/mnInnmoRkb20gZXZlbnRz5LmL5ZCOXG4gICAgZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0SGFuZGxlcjtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgICB9XG4gICAgLy8gZm9yIG5hdGl2ZSBhcHBcbiAgICBlbHNlIGlmIChpc05hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0SGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KG5leHRIYW5kbGVyLCAwKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xuXG5cbi8qKlxuICogQGZpbGUgaWXniYjmnKzlj7dcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5LuOdXNlckFnZW505LitaWXniYjmnKzlj7fnmoTljLnphY3kv6Hmga9cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBpZVZlcnNpb25NYXRjaCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZVxccyooWzAtOV0rKS9pKTtcblxuLyoqXG4gKiBpZeeJiOacrOWPt++8jOmdnmll5pe25Li6MFxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBpZSA9IGllVmVyc2lvbk1hdGNoID8gaWVWZXJzaW9uTWF0Y2hbMV0gLSAwIDogMDtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaWU7XG5cblxuLyoqXG4gKiBAZmlsZSDmmK/lkKYgSUUg5bm25LiU5bCP5LqOIDlcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBpZSA9IHJlcXVpcmUoJy4vaWUnKTtcblxuLy8gSEFDSzpcbi8vIDEuIElFOOS4i++8jOiuvue9rmlubmVySFRNTOaXtuWmguaenOS7pWh0bWwgY29tbWVudOW8gOWktO+8jGNvbW1lbnTkvJrooqvoh6rliqjmu6Tmjolcbi8vICAgIOS4uuS6huS/neivgXN0dW1w5a2Y5Zyo77yM6ZyA6KaB6K6+572u5a6MaHRtbOWQju+8jGNyZWF0ZUNvbW1lbnTlubZhcHBlbmRDaGlsZC9pbnNlcnRCZWZvcmVcbi8vIDIuIElFOOS4i++8jGlubmVySFRNTOi/mOS4jeaUr+aMgWN1c3RvbSBlbGVtZW5077yM5omA5Lul6ZyA6KaB55SoZGl25pu/5Luj77yM5LiN55SoY3JlYXRlRWxlbWVudFxuLy8gMy4g6Jm954S2SUU45bey57uP5LyY5YyW5LqG5a2X56ym5LiyK+i/nuaOpe+8jOeijueJh+WMlui/nuaOpeaAp+iDveS4jeWGjemAgOWMllxuLy8gICAg5L2G5piv55Sx5LqO5LiK6Z2i5aSa5Liq5YW85a655Zy65pmv6YO955SoIDwgOSDliKTmlq3vvIzmiYDku6XlrZfnrKbkuLLov57mjqXkuZ/msr/nlKhcbi8vICAgIOaJgOS7pee7k+aenOaYr0lFOOS4i+Wtl+espuS4sui/nuaOpeeUqOeahOaYr+aVsOe7hGpvaW7nmoTmlrnlvI9cblxuLy8gI1tiZWdpbl0gYWxsdWFcbi8qKlxuICog5piv5ZCmIElFIOW5tuS4lOWwj+S6jiA5XG4gKi9cbnZhciBpZU9sZFRoYW45ID0gaWUgJiYgaWUgPCA5O1xuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGllT2xkVGhhbjk7XG5cblxuLyoqXG4gKiBAZmlsZSBET00g5LqL5Lu25oyC6L29XG4gKiBAYXV0aG9yIGRhZnJvayhvLm9AbXVnLmRvZylcbiAqL1xuXG4vKipcbiAqIERPTSDkuovku7bmjILovb1cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIERPTeWFg+e0oFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI1cbiAqL1xuZnVuY3Rpb24gdHJpZ2dlcihlbCwgZXZlbnROYW1lKSB7XG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpZ2dlcjtcblxuXG4vKipcbiAqIEBmaWxlIOino+WGsyBJRTkg5Zyo6KGo5Y2V5YWD57Sg5Lit5Yig6Zmk5a2X56ym5pe25LiN6Kem5Y+R5LqL5Lu255qE6Zeu6aKYXG4gKiBAYXV0aG9yIGRhZnJvayhvLm9AbXVnLmRvZylcbiAqL1xuXG4vLyB2YXIgaWUgPSByZXF1aXJlKCcuL2llJyk7XG4vLyB2YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG4vLyB2YXIgdHJpZ2dlciA9IHJlcXVpcmUoJy4vdHJpZ2dlcicpO1xuXG4vLyAjW2JlZ2luXSBhbGx1YVxuaWYgKGllID09PSA5KSB7XG4gICAgb24oZG9jdW1lbnQsICdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnIHx8IGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyAjW2VuZF1cblxuXG4vKipcbiAqIEBmaWxlIOiHqumXreWQiOagh+etvuihqFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHNwbGl0U3RyMk9iaiA9IHJlcXVpcmUoJy4uL3V0aWwvc3BsaXQtc3RyLTItb2JqJyk7XG5cbi8qKlxuICog6Ieq6Zet5ZCI5qCH562+5YiX6KGoXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGF1dG9DbG9zZVRhZ3MgPSBzcGxpdFN0cjJPYmooJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGtleWdlbixwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJyk7XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGF1dG9DbG9zZVRhZ3M7XG5cblxuLyoqXG4gKiBAZmlsZSBkYXRhIHR5cGVzXG4gKiBAYXV0aG9yIGxlb24gPGx1ZGFmYUBvdXRsb29rLmNvbT5cbiAqL1xuXG4vLyB2YXIgYmluZCA9IHJlcXVpcmUoJy4vYmluZCcpO1xuLy8gdmFyIGVtcHR5ID0gcmVxdWlyZSgnLi9lbXB0eScpO1xuLy8gdmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5cbi8vICNbYmVnaW5dIGVycm9yXG52YXIgQU5PTllNT1VTX0NMQVNTX05BTUUgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbi8qKlxuICog6I635Y+W57K+56Gu55qE57G75Z6LXG4gKlxuICogQE5PVEUg5aaC5p6cIG9iaiDmmK/kuIDkuKogRE9NRWxlbWVudO+8jOaIkeS7rOS8mui/lOWbniBgZWxlbWVudGDvvJtcbiAqXG4gKiBAcGFyYW0gIHsqfSBvYmog55uu5qCHXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFUeXBlKG9iaikge1xuXG4gICAgaWYgKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50JztcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmopXG4gICAgICAgIC5zbGljZSg4LCAtMSlcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG59XG4vLyAjW2VuZF1cblxuLyoqXG4gKiDliJvlu7rpk77lvI/nmoTmlbDmja7nsbvlnovmoKHpqozlmahcbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gdmFsaWRhdGUg55yf5q2j55qE5qCh6aqM5ZmoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIHZhciBjaGFpbmVkQ2hlY2tlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNoYWluZWRDaGVja2VyLmlzUmVxdWlyZWQgPSBlbXB0eTtcblxuICAgIC8vIOWPquWcqCBlcnJvciDlip/og73lkK/nlKjml7bmiY3mnInlrp7pmYXkuIrnmoQgZGF0YVR5cGVzIOajgOa1i1xuICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgdmFyIGNoZWNrVHlwZSA9IGZ1bmN0aW9uIChpc1JlcXVpcmVkLCBkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBnZXREYXRhVHlwZShkYXRhVmFsdWUpO1xuXG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VU19DTEFTU19OQU1FO1xuXG4gICAgICAgIC8vIOWmguaenOaYryBudWxsIOaIliB1bmRlZmluZWTvvIzpgqPkuYjopoHmj5DliY3ov5Tlm57llaZcbiAgICAgICAgaWYgKGRhdGFWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyDmmK8gcmVxdWlyZWQg5bCx5oql6ZSZXG4gICAgICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuICAgICAgICAgICAgICAgICAgICArICdUaGUgYCcgKyBkYXRhTmFtZSArICdgICdcbiAgICAgICAgICAgICAgICAgICAgKyAnaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluIGAnICsgY29tcG9uZW50TmFtZSArICdgLCAnXG4gICAgICAgICAgICAgICAgICAgICsgJ2J1dCBpdHMgdmFsdWUgaXMgJyArIGRhdGFUeXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOS4jeaYryByZXF1aXJlZO+8jOmCo+WwseaYryBvayDnmoRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpO1xuXG4gICAgfTtcblxuICAgIGNoYWluZWRDaGVja2VyID0gYmluZChjaGVja1R5cGUsIG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tlci5pc1JlcXVpcmVkID0gYmluZChjaGVja1R5cGUsIG51bGwsIHRydWUpO1xuICAgIC8vICNbZW5kXVxuXG5cblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tlcjtcblxufVxuXG4vLyAjW2JlZ2luXSBlcnJvclxuLyoqXG4gKiDnlJ/miJDkuLvopoHnsbvlnovmlbDmja7moKHpqozlmahcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUg5Li757G75Z6LXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJpbWFyeVR5cGVDaGVja2VyKHR5cGUpIHtcblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBnZXREYXRhVHlwZShkYXRhVmFsdWUpO1xuXG4gICAgICAgIGlmIChkYXRhVHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4gICAgICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIHR5cGUnXG4gICAgICAgICAgICAgICAgKyAnKCcgKyBkYXRhVHlwZSArICcgc3VwcGxpZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnLCAnXG4gICAgICAgICAgICAgICAgKyAnZXhwZWN0ZWQgJyArIHR5cGUgKyAnKSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59XG5cblxuXG4vKipcbiAqIOeUn+aIkCBhcnJheU9mIOagoemqjOWZqFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBhcnJheUl0ZW1DaGVja2VyIOaVsOe7hOS4reavj+mhueaVsOaNrueahOagoemqjOWZqFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZDaGVja2VyKGFycmF5SXRlbUNoZWNrZXIpIHtcblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheUl0ZW1DaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdEYXRhIGAnICsgZGF0YU5hbWUgKyAnYCBvZiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCAnXG4gICAgICAgICAgICAgICAgKyAnRGF0YVR5cGUgbm90YXRpb24gaW5zaWRlIGBhcnJheU9mYCwgZXhwZWN0ZWQgYGZ1bmN0aW9uYCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtkYXRhTmFtZV07XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGdldERhdGFUeXBlKGRhdGFWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdJbnZhbGlkICcgKyBjb21wb25lbnROYW1lICsgJyBkYXRhIGAnICsgZnVsbERhdGFOYW1lICsgJ2Agb2YgdHlwZSdcbiAgICAgICAgICAgICAgICArICcoJyArIGRhdGFUeXBlICsgJyBzdXBwbGllZCB0byAnICsgY29tcG9uZW50TmFtZSArICcsICdcbiAgICAgICAgICAgICAgICArICdleHBlY3RlZCBhcnJheSknXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGFWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyYXlJdGVtQ2hlY2tlcihkYXRhVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxufVxuXG4vKipcbiAqIOeUn+aIkCBpbnN0YW5jZU9mIOajgOa1i+WZqFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufENsYXNzfSBleHBlY3RlZENsYXNzIOacn+W+heeahOexu1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlT2ZDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGZ1bmN0aW9uIChkYXRhLCBkYXRhTmFtZSwgY29tcG9uZW50TmFtZSwgZnVsbERhdGFOYW1lKSB7XG5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuXG4gICAgICAgIGlmIChkYXRhVmFsdWUgaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVZhbHVlQ2xhc3NOYW1lID0gZGF0YVZhbHVlLmNvbnN0cnVjdG9yICYmIGRhdGFWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICA/IGRhdGFWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICA6IEFOT05ZTU9VU19DTEFTU19OQU1FO1xuXG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVNfQ0xBU1NfTkFNRTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICsgJ0ludmFsaWQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBvZiB0eXBlJ1xuICAgICAgICAgICAgKyAnKCcgKyBkYXRhVmFsdWVDbGFzc05hbWUgKyAnIHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgJ1xuICAgICAgICAgICAgKyAnZXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJyknXG4gICAgICAgICk7XG5cblxuICAgIH0pO1xuXG59XG5cbi8qKlxuICog55Sf5oiQIHNoYXBlIOagoemqjOWZqFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc2hhcGVUeXBlcyBzaGFwZSDmoKHpqozop4TliJlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVTaGFwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpIHtcblxuICAgICAgICBpZiAoZ2V0RGF0YVR5cGUoc2hhcGVUeXBlcykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdEYXRhIGAnICsgZnVsbERhdGFOYW1lICsgJ2Agb2YgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgJ1xuICAgICAgICAgICAgICAgICsgJ0RhdGFUeXBlIG5vdGF0aW9uIGluc2lkZSBgc2hhcGVgLCBleHBlY3RlZCBgb2JqZWN0YCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtkYXRhTmFtZV07XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGdldERhdGFUeXBlKGRhdGFWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4gICAgICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIHR5cGUnXG4gICAgICAgICAgICAgICAgKyAnKCcgKyBkYXRhVHlwZSArICcgc3VwcGxpZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnLCAnXG4gICAgICAgICAgICAgICAgKyAnZXhwZWN0ZWQgb2JqZWN0KSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBzaGFwZUtleU5hbWUgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICAgICAgaWYgKHNoYXBlVHlwZXMuaGFzT3duUHJvcGVydHkoc2hhcGVLZXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1tzaGFwZUtleU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VyKGRhdGFWYWx1ZSwgc2hhcGVLZXlOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUgKyAnLicgKyBzaGFwZUtleU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbn1cblxuLyoqXG4gKiDnlJ/miJAgb25lT2Yg5qCh6aqM5ZmoXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGV4cGVjdGVkRW51bVZhbHVlcyDmnJ/lvoXnmoTmnprkuL7lgLxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVPbmVPZkNoZWNrZXIoZXhwZWN0ZWRFbnVtVmFsdWVzKSB7XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihmdW5jdGlvbiAoZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSkge1xuXG4gICAgICAgIGlmIChnZXREYXRhVHlwZShleHBlY3RlZEVudW1WYWx1ZXMpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdEYXRhIGAnICsgZnVsbERhdGFOYW1lICsgJ2Agb2YgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgJ1xuICAgICAgICAgICAgICAgICsgJ0RhdGFUeXBlIG5vdGF0aW9uIGluc2lkZSBgb25lT2ZgLCBhcnJheSBpcyBleHBlY3RlZC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZEVudW1WYWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhVmFsdWUgPT09IGV4cGVjdGVkRW51bVZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIHZhbHVlJ1xuICAgICAgICAgICAgKyAnKGAnICsgZGF0YVZhbHVlICsgJ2Agc3VwcGxpZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnLCAnXG4gICAgICAgICAgICArICdleHBlY3RlZCBvbmUgb2YgJyArIGV4cGVjdGVkRW51bVZhbHVlcy5qb2luKCcsJykgKyAnKSdcbiAgICAgICAgKTtcblxuICAgIH0pO1xuXG59XG5cbi8qKlxuICog55Sf5oiQIG9uZU9mVHlwZSDmoKHpqozlmahcbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxGdW5jdGlvbj59IGV4cGVjdGVkRW51bU9mVHlwZVZhbHVlcyDmnJ/lvoXnmoTmnprkuL7nsbvlnotcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVPbmVPZlR5cGVDaGVja2VyKGV4cGVjdGVkRW51bU9mVHlwZVZhbHVlcykge1xuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpIHtcblxuICAgICAgICBpZiAoZ2V0RGF0YVR5cGUoZXhwZWN0ZWRFbnVtT2ZUeXBlVmFsdWVzKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4gICAgICAgICAgICAgICAgKyAnRGF0YSBgJyArIGRhdGFOYW1lICsgJ2Agb2YgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgJ1xuICAgICAgICAgICAgICAgICsgJ0RhdGFUeXBlIG5vdGF0aW9uIGluc2lkZSBgb25lT2ZgLCBhcnJheSBpcyBleHBlY3RlZC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IGRhdGFbZGF0YU5hbWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZEVudW1PZlR5cGVWYWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGNoZWNrZXIgPSBleHBlY3RlZEVudW1PZlR5cGVWYWx1ZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoZWNrZXIoZGF0YSwgZGF0YU5hbWUsIGNvbXBvbmVudE5hbWUsIGZ1bGxEYXRhTmFtZSk7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6cIGNoZWNrZXIg5a6M5oiQ5qCh6aqM5rKh5oql6ZSZ77yM6YKj5bCx6L+U5Zue5LqGXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmnInplJnor6/vvIzpgqPkuYjlupTor6XmiorplJnor6/lkJ7mjolcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5omA5pyJ55qE5Y+v5o6l5Y+XIHR5cGUg6YO95aSx6LSl5LqG77yM5omN5Lii5LiA5Liq5byC5bi4XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuICAgICAgICAgICAgKyAnSW52YWxpZCAnICsgY29tcG9uZW50TmFtZSArICcgZGF0YSBgJyArIGRhdGFOYW1lICsgJ2Agb2YgdmFsdWUnXG4gICAgICAgICAgICArICcoYCcgKyBkYXRhVmFsdWUgKyAnYCBzdXBwbGllZCB0byAnICsgY29tcG9uZW50TmFtZSArICcpJ1xuICAgICAgICApO1xuXG4gICAgfSk7XG5cbn1cblxuLyoqXG4gKiDnlJ/miJAgb2JqZWN0T2Yg5qCh6aqM5ZmoXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHR5cGVDaGVja2VyIOWvueixoeWxnuaAp+WAvOagoemqjOWZqFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdEYXRhIGAnICsgZGF0YU5hbWUgKyAnYCBvZiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCAnXG4gICAgICAgICAgICAgICAgKyAnRGF0YVR5cGUgbm90YXRpb24gaW5zaWRlIGBvYmplY3RPZmAsIGV4cGVjdGVkIGZ1bmN0aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW2RhdGFOYW1lXTtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZ2V0RGF0YVR5cGUoZGF0YVZhbHVlKTtcblxuICAgICAgICBpZiAoZGF0YVR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICArICdJbnZhbGlkICcgKyBjb21wb25lbnROYW1lICsgJyBkYXRhIGAnICsgZGF0YU5hbWUgKyAnYCBvZiB0eXBlJ1xuICAgICAgICAgICAgICAgICsgJygnICsgZGF0YVR5cGUgKyAnIHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgJ1xuICAgICAgICAgICAgICAgICsgJ2V4cGVjdGVkIG9iamVjdCknXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgZGF0YUtleU5hbWUgaW4gZGF0YVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVZhbHVlLmhhc093blByb3BlcnR5KGRhdGFLZXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVDaGVja2VyKFxuICAgICAgICAgICAgICAgICAgICBkYXRhVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFLZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdWxsRGF0YU5hbWUgKyAnLicgKyBkYXRhS2V5TmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfSk7XG5cbn1cblxuLyoqXG4gKiDnlJ/miJAgZXhhY3Qg5qCh6aqM5ZmoXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzaGFwZVR5cGVzIG9iamVjdCDlvaLmgIHlrprkuYlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVFeGFjdENoZWNrZXIoc2hhcGVUeXBlcykge1xuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZnVuY3Rpb24gKGRhdGEsIGRhdGFOYW1lLCBjb21wb25lbnROYW1lLCBmdWxsRGF0YU5hbWUsIHNlY3JldCkge1xuXG4gICAgICAgIGlmIChnZXREYXRhVHlwZShzaGFwZVR5cGVzKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuICAgICAgICAgICAgICAgICsgJ0RhdGEgYCcgKyBkYXRhTmFtZSArICdgIG9mIGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkICdcbiAgICAgICAgICAgICAgICArICdEYXRhVHlwZSBub3RhdGlvbiBpbnNpZGUgYGV4YWN0YCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtkYXRhTmFtZV07XG4gICAgICAgIHZhciBkYXRhVmFsdWVUeXBlID0gZ2V0RGF0YVR5cGUoZGF0YVZhbHVlKTtcblxuICAgICAgICBpZiAoZGF0YVZhbHVlVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJ1xuICAgICAgICAgICAgICAgICsgJ0ludmFsaWQgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIG9mIHR5cGUgYCcgKyBkYXRhVmFsdWVUeXBlICsgJ2AnXG4gICAgICAgICAgICAgICAgKyAnKHN1cHBsaWVkIHRvICcgKyBjb21wb25lbnROYW1lICsgJywgZXhwZWN0ZWQgYG9iamVjdGApJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGxLZXlzID0ge307XG5cbiAgICAgICAgLy8g5YWI5ZCI5YWlIHNoYXBlVHlwZXNcbiAgICAgICAgZXh0ZW5kKGFsbEtleXMsIHNoYXBlVHlwZXMpO1xuICAgICAgICAvLyDlho3lkIjlhaUgZGF0YVZhbHVlXG4gICAgICAgIGV4dGVuZChhbGxLZXlzLCBkYXRhVmFsdWUpO1xuICAgICAgICAvLyDkv53or4EgYWxsS2V5cyDnmoTnsbvlnovmraPnoa5cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICAgICAgaWYgKGFsbEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuXG4gICAgICAgICAgICAgICAgLy8gZGF0YVZhbHVlIOS4reacieS4gOS4quWkmuS9meeahOaVsOaNrumhuVxuICAgICAgICAgICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ0ludmFsaWQgZGF0YSBgJyArIGZ1bGxEYXRhTmFtZSArICdgIGtleSBgJyArIGtleSArICdgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLiAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICcoYCcgKyBrZXkgKyAnYCBpcyBub3QgZGVmaW5lZCBpbiBgRGF0YVR5cGVzLmV4YWN0YCknXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGRhdGFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdJbnZhbGlkIGRhdGEgYCcgKyBmdWxsRGF0YU5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnKGAnICsga2V5ICsgJ2AgaXMgbWFya2VkIGByZXF1aXJlZGAgaW4gYERhdGFUeXBlcy5leGFjdGApJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoZWNrZXIoXG4gICAgICAgICAgICAgICAgICAgIGRhdGFWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdWxsRGF0YU5hbWUgKyAnLicgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbn1cbi8vICNbZW5kXVxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgZmVjcy12YWxpZC12YXItanNkb2MgKi9cbnZhciBEYXRhVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIG9iamVjdDogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihlbXB0eSksXG4gICAgZnVuYzogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihlbXB0eSksXG4gICAgc3RyaW5nOiBjcmVhdGVDaGFpbmFibGVDaGVja2VyKGVtcHR5KSxcbiAgICBudW1iZXI6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIGJvb2w6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuICAgIHN5bWJvbDogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcihlbXB0eSksXG4gICAgYW55OiBjcmVhdGVDaGFpbmFibGVDaGVja2VyLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlQ2hhaW5hYmxlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXJcbn07XG5cbi8vICNbYmVnaW5dIGVycm9yXG5EYXRhVHlwZXMgPSB7XG5cbiAgICBhbnk6IGNyZWF0ZUNoYWluYWJsZUNoZWNrZXIoZW1wdHkpLFxuXG4gICAgLy8g57G75Z6L5qOA5rWLXG4gICAgYXJyYXk6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWFyeVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWFyeVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1hcnlUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWFyeVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltYXJ5VHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgLy8g5aSN5ZCI57G75Z6L5qOA5rWLXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZkNoZWNrZXIsXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VPZkNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlT25lT2ZDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlT25lT2ZUeXBlQ2hlY2tlcixcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVFeGFjdENoZWNrZXJcblxufTtcbi8qIGVzbGludC1lbmFibGUgZmVjcy12YWxpZC12YXItanNkb2MgKi9cbi8vICNbZW5kXVxuXG5cbi8vIG1vZHVsZS5leHBvcnRzID0gRGF0YVR5cGVzO1xuXG5cbi8qKlxuICogQGZpbGUg5Yib5bu65pWw5o2u5qOA5rWL5Ye95pWwXG4gKiBAYXV0aG9yIGxlb248bHVkYWZhQG91dGxvb2suY29tPlxuICovXG5cblxuLy8gI1tiZWdpbl0gZXJyb3JcblxuLyoqXG4gKiDliJvlu7rmlbDmja7mo4DmtYvlh73mlbBcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFUeXBlcyAgICAg5pWw5o2u5qC85byPXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUg57uE5Lu25ZCNXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVR5cGVzQ2hlY2tlcihkYXRhVHlwZXMsIGNvbXBvbmVudE5hbWUpIHtcblxuICAgIC8qKlxuICAgICAqIOagoemqjCBkYXRhIOaYr+WQpua7oei2syBkYXRhIHR5cGVzIOeahOagvOW8j1xuICAgICAqXG4gICAgICogQHBhcmFtICB7Kn0gZGF0YSDmlbDmja5cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICBmb3IgKHZhciBkYXRhVHlwZU5hbWUgaW4gZGF0YVR5cGVzKSB7XG5cbiAgICAgICAgICAgIGlmIChkYXRhVHlwZXMuaGFzT3duUHJvcGVydHkoZGF0YVR5cGVOYW1lKSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlQ2hlY2tlciA9IGRhdGFUeXBlc1tkYXRhVHlwZU5hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNvbXBvbmVudE5hbWUgKyAnOicgKyBkYXRhVHlwZU5hbWUgKyAnIGlzIGludmFsaWQ7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHNhbi5EYXRhVHlwZXMnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVDaGVja2VyKFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlTmFtZVxuICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG59XG5cbi8vICNbZW5kXVxuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURhdGFUeXBlc0NoZWNrZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDlrZfnrKbkuLLmupDnoIHor7vlj5bnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDlrZfnrKbkuLLmupDnoIHor7vlj5bnsbvvvIznlKjkuo7mqKHmnb/lrZfnrKbkuLLop6PmnpDov4fnqItcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug6KaB6K+75Y+W55qE5a2X56ym5LiyXG4gKi9cbmZ1bmN0aW9uIFdhbGtlcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmxlbiA9IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbn1cblxuLyoqXG4gKiDojrflj5blvZPliY3lrZfnrKbnoIFcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbldhbGtlci5wcm90b3R5cGUuY3VycmVudENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhckNvZGUodGhpcy5pbmRleCk7XG59O1xuXG4vKipcbiAqIOaIquWPluWtl+espuS4sueJh+autVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCDotbflp4vkvY3nva5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQg57uT5p2f5L2N572uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbldhbGtlci5wcm90b3R5cGUuY3V0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIOWQkeWJjeivu+WPluWtl+esplxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSDor7vlj5blrZfnrKbmlbBcbiAqL1xuV2Fsa2VyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgIHRoaXMuaW5kZXggKz0gZGlzdGFuY2U7XG59O1xuXG4vKipcbiAqIOivu+WPluS4i+S4gOS4quWtl+espu+8jOi/lOWbnuS4i+S4gOS4quWtl+espueahCBjb2RlXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5XYWxrZXIucHJvdG90eXBlLm5leHRDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ28oMSk7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvZGUoKTtcbn07XG5cbi8qKlxuICog6I635Y+W55u45bqU5L2N572u5a2X56ym55qEIGNvZGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg5a2X56ym5L2N572uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbldhbGtlci5wcm90b3R5cGUuY2hhckNvZGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG59O1xuXG4vKipcbiAqIOWQkeWJjeivu+WPluWtl+espu+8jOebtOWIsOmBh+WIsOaMh+WumuWtl+espuWGjeWBnOatolxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2hhckNvZGUg5oyH5a6a5a2X56ym55qEY29kZVxuICogQHJldHVybiB7Ym9vbGVhbn0g5b2T5oyH5a6a5a2X56ym5pe277yM6L+U5Zue5piv5ZCm56Kw5Yiw5oyH5a6a55qE5a2X56ymXG4gKi9cbldhbGtlci5wcm90b3R5cGUuZ29VbnRpbCA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW4gJiYgKGNvZGUgPSB0aGlzLmN1cnJlbnRDb2RlKCkpKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIOWQkeWJjeivu+WPluespuWQiOinhOWImeeahOWtl+espueJh+aute+8jOW5tui/lOWbnuinhOWImeWMuemFjee7k+aenFxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWcg5a2X56ym54mH5q6155qE5q2j5YiZ6KGo6L6+5byPXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuV2Fsa2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyZWcpIHtcbiAgICByZWcubGFzdEluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIHZhciBtYXRjaCA9IHJlZy5leGVjKHRoaXMuc291cmNlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHJlZy5sYXN0SW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gV2Fsa2VyO1xuXG5cblxuLyoqXG4gKiBAZmlsZSDmqKHmnb/op6PmnpDnlJ/miJDnmoTmir3osaHoioLngrlcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5Yib5bu65qih5p2/6Kej5p6Q55Sf5oiQ55qE5oq96LGh6IqC54K5XG4gKlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIOiKgueCueWPguaVsFxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnRhZ05hbWUg5qCH562+5ZCNXG4gKiBAcGFyYW0ge0FOb2RlPX0gb3B0aW9ucy5wYXJlbnQg54i26IqC54K5XG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25zLnRleHRFeHByIOaWh+acrOiKgueCueihqOi+vuW8j+WvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBTm9kZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMudGV4dEV4cHIpIHtcbiAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnByb3BzID0gb3B0aW9ucy5wcm9wcyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucy5jaGlsZHJlbiA9IG9wdGlvbnMuY2hpbGRyZW4gfHwgW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFOb2RlO1xuXG5cbi8qKlxuICogQGZpbGUg5oqKIGtlYmFiIGNhc2Ug5a2X56ym5Liy6L2s5o2i5oiQIGNhbWVsIGNhc2VcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5oqKIGtlYmFiIGNhc2Ug5a2X56ym5Liy6L2s5o2i5oiQIGNhbWVsIGNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOWtl+espuS4slxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBrZWJhYjJjYW1lbChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChtYXRjaCwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIGFscGhhLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGtlYmFiMmNhbWVsO1xuXG5cbi8qKlxuICogQGZpbGUg6KGo6L6+5byP57G75Z6LXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOihqOi+vuW8j+exu+Wei1xuICpcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEV4cHJUeXBlID0ge1xuICAgIFNUUklORzogMSxcbiAgICBOVU1CRVI6IDIsXG4gICAgQk9PTDogMyxcbiAgICBBQ0NFU1NPUjogNCxcbiAgICBJTlRFUlA6IDUsXG4gICAgQ0FMTDogNixcbiAgICBURVhUOiA3LFxuICAgIEJJTkFSWTogOCxcbiAgICBVTkFSWTogOSxcbiAgICBURVJUSUFSWTogMTBcbn07XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEV4cHJUeXBlO1xuXG5cbi8qKlxuICogQGZpbGUg5Yib5bu66K6/6Zeu6KGo6L6+5byP5a+56LGhXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuXG4vKipcbiAqIOWIm+W7uuiuv+mXruihqOi+vuW8j+WvueixoVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhzIOiuv+mXrui3r+W+hFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcihwYXRocykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEV4cHJUeXBlLkFDQ0VTU09SLFxuICAgICAgICBwYXRoczogcGF0aHNcbiAgICB9O1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBY2Nlc3NvcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluWtl+espuS4slxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuXG4vKipcbiAqIOivu+WPluWtl+espuS4slxuICpcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWRTdHJpbmcod2Fsa2VyKSB7XG4gICAgdmFyIHN0YXJ0Q29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuICAgIHZhciBzdGFydEluZGV4ID0gd2Fsa2VyLmluZGV4O1xuICAgIHZhciBjaGFyQ29kZTtcblxuICAgIHdhbGtMb29wOiB3aGlsZSAoKGNoYXJDb2RlID0gd2Fsa2VyLm5leHRDb2RlKCkpKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgOTI6IC8vIFxcXG4gICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdGFydENvZGU6XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrIHdhbGtMb29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpdGVyYWwgPSB3YWxrZXIuY3V0KHN0YXJ0SW5kZXgsIHdhbGtlci5pbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICB2YWx1ZTogKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBsaXRlcmFsKSkoKVxuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRTdHJpbmc7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bmlbDlrZdcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcblxuLyoqXG4gKiDor7vlj5bmlbDlrZdcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWROdW1iZXIod2Fsa2VyKSB7XG4gICAgdmFyIG1hdGNoID0gd2Fsa2VyLm1hdGNoKC9cXHMqKC0/WzAtOV0rKFxcLlswLTldKyk/KS9nKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEV4cHJUeXBlLk5VTUJFUixcbiAgICAgICAgdmFsdWU6IG1hdGNoWzFdIC0gMFxuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWROdW1iZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5ZpZGVudFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDor7vlj5ZpZGVudFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVhZElkZW50KHdhbGtlcikge1xuICAgIHZhciBtYXRjaCA9IHdhbGtlci5tYXRjaCgvXFxzKihbXFwkMC05YS16X10rKS9pZyk7XG4gICAgcmV0dXJuIG1hdGNoWzFdO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZWFkSWRlbnQ7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bkuInlhYPooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZExvZ2ljYWxPUkV4cHIgPSByZXF1aXJlKCcuL3JlYWQtbG9naWNhbC1vci1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W5LiJ5YWD6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpIHtcbiAgICB2YXIgY29uZGl0aW9uYWwgPSByZWFkTG9naWNhbE9SRXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDYzKSB7IC8vID9cbiAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICB2YXIgeWVzRXhwciA9IHJlYWRUZXJ0aWFyeUV4cHIod2Fsa2VyKTtcbiAgICAgICAgd2Fsa2VyLmdvVW50aWwoKTtcblxuICAgICAgICBpZiAod2Fsa2VyLmN1cnJlbnRDb2RlKCkgPT09IDU4KSB7IC8vIDpcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuVEVSVElBUlksXG4gICAgICAgICAgICAgICAgc2VnczogW1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgeWVzRXhwcixcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25kaXRpb25hbDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFRlcnRpYXJ5RXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluiuv+mXruihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4vY3JlYXRlLWFjY2Vzc29yJyk7XG4vLyB2YXIgcmVhZElkZW50ID0gcmVxdWlyZSgnLi9yZWFkLWlkZW50Jyk7XG4vLyB2YXIgcmVhZFRlcnRpYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC10ZXJ0aWFyeS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W6K6/6Zeu6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZEFjY2Vzc29yKHdhbGtlcikge1xuICAgIHZhciBmaXJzdFNlZyA9IHJlYWRJZGVudCh3YWxrZXIpO1xuICAgIHN3aXRjaCAoZmlyc3RTZWcpIHtcbiAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQk9PTCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmlyc3RTZWcgPT09ICd0cnVlJ1xuICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQWNjZXNzb3IoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICB2YWx1ZTogZmlyc3RTZWdcbiAgICAgICAgfVxuICAgIF0pO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gICAgYWNjZXNzb3JMb29wOiB3aGlsZSAoMSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG5cbiAgICAgICAgc3dpdGNoICh3YWxrZXIuY3VycmVudENvZGUoKSkge1xuICAgICAgICAgICAgY2FzZSA0NjogLy8gLlxuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcblxuICAgICAgICAgICAgICAgIC8vIGlkZW50IGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVhZElkZW50KHdhbGtlcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MTogLy8gW1xuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aHMucHVzaChyZWFkVGVydGlhcnlFeHByKHdhbGtlcikpO1xuICAgICAgICAgICAgICAgIHdhbGtlci5nb1VudGlsKDkzKTsgLy8gXVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrIGFjY2Vzc29yTG9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRBY2Nlc3NvcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluaLrOWPt+ihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHJlYWRUZXJ0aWFyeUV4cHIgPSByZXF1aXJlKCcuL3JlYWQtdGVydGlhcnktZXhwcicpO1xuXG4vKipcbiAqIOivu+WPluaLrOWPt+ihqOi+vuW8j1xuICpcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWRQYXJlbnRoZXNpemVkRXhwcih3YWxrZXIpIHtcbiAgICB3YWxrZXIuZ28oMSk7XG4gICAgdmFyIGV4cHIgPSByZWFkVGVydGlhcnlFeHByKHdhbGtlcik7XG4gICAgd2Fsa2VyLmdvVW50aWwoNDEpOyAvLyApXG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZFBhcmVudGhlc2l6ZWRFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W5LiA5YWD6KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRTdHJpbmcgPSByZXF1aXJlKCcuL3JlYWQtc3RyaW5nJyk7XG4vLyB2YXIgcmVhZE51bWJlciA9IHJlcXVpcmUoJy4vcmVhZC1udW1iZXInKTtcbi8vIHZhciByZWFkQWNjZXNzb3IgPSByZXF1aXJlKCcuL3JlYWQtYWNjZXNzb3InKTtcbi8vIHZhciByZWFkUGFyZW50aGVzaXplZEV4cHIgPSByZXF1aXJlKCcuL3JlYWQtcGFyZW50aGVzaXplZC1leHByJyk7XG5cblxuLyoqXG4gKiDor7vlj5bkuIDlhYPooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkVW5hcnlFeHByKHdhbGtlcikge1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICBzd2l0Y2ggKHdhbGtlci5jdXJyZW50Q29kZSgpKSB7XG4gICAgICAgIGNhc2UgMzM6IC8vICFcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuVU5BUlksXG4gICAgICAgICAgICAgICAgZXhwcjogcmVhZFVuYXJ5RXhwcih3YWxrZXIpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM0OiAvLyBcIlxuICAgICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZyh3YWxrZXIpO1xuICAgICAgICBjYXNlIDQ1OiAvLyBudW1iZXJcbiAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgY2FzZSA1MDpcbiAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgY2FzZSA1MjpcbiAgICAgICAgY2FzZSA1MzpcbiAgICAgICAgY2FzZSA1NDpcbiAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgY2FzZSA1NjpcbiAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgIHJldHVybiByZWFkTnVtYmVyKHdhbGtlcik7XG4gICAgICAgIGNhc2UgNDA6IC8vIChcbiAgICAgICAgICAgIHJldHVybiByZWFkUGFyZW50aGVzaXplZEV4cHIod2Fsa2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZEFjY2Vzc29yKHdhbGtlcik7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRVbmFyeUV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bkuZjms5Xooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZFVuYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC11bmFyeS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W5LmY5rOV6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZE11bHRpcGxpY2F0aXZlRXhwcih3YWxrZXIpIHtcbiAgICB2YXIgZXhwciA9IHJlYWRVbmFyeUV4cHIod2Fsa2VyKTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICAgICAgdmFyIGNvZGUgPSB3YWxrZXIuY3VycmVudENvZGUoKTtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDM3OiAvLyAlXG4gICAgICAgICAgICBjYXNlIDQyOiAvLyAqXG4gICAgICAgICAgICBjYXNlIDQ3OiAvLyAvXG4gICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkJJTkFSWSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHNlZ3M6IFtleHByLCByZWFkVW5hcnlFeHByKHdhbGtlcildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRNdWx0aXBsaWNhdGl2ZUV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bliqDms5Xooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZE11bHRpcGxpY2F0aXZlRXhwciA9IHJlcXVpcmUoJy4vcmVhZC1tdWx0aXBsaWNhdGl2ZS1leHByJyk7XG5cblxuLyoqXG4gKiDor7vlj5bliqDms5Xooajovr7lvI9cbiAqXG4gKiBAcGFyYW0ge1dhbGtlcn0gd2Fsa2VyIOa6kOeggeivu+WPluWvueixoVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiByZWFkQWRkaXRpdmVFeHByKHdhbGtlcikge1xuICAgIHZhciBleHByID0gcmVhZE11bHRpcGxpY2F0aXZlRXhwcih3YWxrZXIpO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgICAgd2Fsa2VyLmdvVW50aWwoKTtcbiAgICAgICAgdmFyIGNvZGUgPSB3YWxrZXIuY3VycmVudENvZGUoKTtcblxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgNDM6IC8vICtcbiAgICAgICAgICAgIGNhc2UgNDU6IC8vIC1cbiAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQklOQVJZLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VnczogW2V4cHIsIHJlYWRNdWx0aXBsaWNhdGl2ZUV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRBZGRpdGl2ZUV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5blhbPns7vliKTmlq3ooajovr7lvI9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZEFkZGl0aXZlRXhwciA9IHJlcXVpcmUoJy4vcmVhZC1hZGRpdGl2ZS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W5YWz57O75Yik5pat6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZFJlbGF0aW9uYWxFeHByKHdhbGtlcikge1xuICAgIHZhciBleHByID0gcmVhZEFkZGl0aXZlRXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICB2YXIgY29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgICAgIGlmICh3YWxrZXIubmV4dENvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICBjb2RlICs9IDYxO1xuICAgICAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5CSU5BUlksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvZGUsXG4gICAgICAgICAgICAgICAgc2VnczogW2V4cHIsIHJlYWRBZGRpdGl2ZUV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRSZWxhdGlvbmFsRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOivu+WPluebuOetieavlOWvueihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciByZWFkUmVsYXRpb25hbEV4cHIgPSByZXF1aXJlKCcuL3JlYWQtcmVsYXRpb25hbC1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W55u4562J5q+U5a+56KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZEVxdWFsaXR5RXhwcih3YWxrZXIpIHtcbiAgICB2YXIgZXhwciA9IHJlYWRSZWxhdGlvbmFsRXhwcih3YWxrZXIpO1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG5cbiAgICB2YXIgY29kZSA9IHdhbGtlci5jdXJyZW50Q29kZSgpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDYxOiAvLyA9XG4gICAgICAgIGNhc2UgMzM6IC8vICFcbiAgICAgICAgICAgIGlmICh3YWxrZXIubmV4dENvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICBjb2RlICs9IDYxO1xuICAgICAgICAgICAgICAgIGlmICh3YWxrZXIubmV4dENvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSA2MTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkJJTkFSWSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHNlZ3M6IFtleHByLCByZWFkUmVsYXRpb25hbEV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3YWxrZXIuZ28oLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZWFkRXF1YWxpdHlFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W6YC76L6R5LiO6KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRFcXVhbGl0eUV4cHIgPSByZXF1aXJlKCcuL3JlYWQtZXF1YWxpdHktZXhwcicpO1xuXG4vKipcbiAqIOivu+WPlumAu+i+keS4juihqOi+vuW8j1xuICpcbiAqIEBwYXJhbSB7V2Fsa2VyfSB3YWxrZXIg5rqQ56CB6K+75Y+W5a+56LGhXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlYWRMb2dpY2FsQU5ERXhwcih3YWxrZXIpIHtcbiAgICB2YXIgZXhwciA9IHJlYWRFcXVhbGl0eUV4cHIod2Fsa2VyKTtcbiAgICB3YWxrZXIuZ29VbnRpbCgpO1xuXG4gICAgaWYgKHdhbGtlci5jdXJyZW50Q29kZSgpID09PSAzOCkgeyAvLyAmXG4gICAgICAgIGlmICh3YWxrZXIubmV4dENvZGUoKSA9PT0gMzgpIHtcbiAgICAgICAgICAgIHdhbGtlci5nbygxKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQklOQVJZLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiA3NixcbiAgICAgICAgICAgICAgICBzZWdzOiBbZXhwciwgcmVhZExvZ2ljYWxBTkRFeHByKHdhbGtlcildXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Fsa2VyLmdvKC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVhZExvZ2ljYWxBTkRFeHByO1xuXG5cbi8qKlxuICogQGZpbGUg6K+75Y+W6YC76L6R5oiW6KGo6L6+5byPXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRMb2dpY2FsQU5ERXhwciA9IHJlcXVpcmUoJy4vcmVhZC1sb2dpY2FsLWFuZC1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W6YC76L6R5oiW6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZExvZ2ljYWxPUkV4cHIod2Fsa2VyKSB7XG4gICAgdmFyIGV4cHIgPSByZWFkTG9naWNhbEFOREV4cHIod2Fsa2VyKTtcbiAgICB3YWxrZXIuZ29VbnRpbCgpO1xuXG4gICAgaWYgKHdhbGtlci5jdXJyZW50Q29kZSgpID09PSAxMjQpIHsgLy8gfFxuICAgICAgICBpZiAod2Fsa2VyLm5leHRDb2RlKCkgPT09IDEyNCkge1xuICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5CSU5BUlksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IDI0OCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbZXhwciwgcmVhZExvZ2ljYWxPUkV4cHIod2Fsa2VyKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB3YWxrZXIuZ28oLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZWFkTG9naWNhbE9SRXhwcjtcblxuXG4vKipcbiAqIEBmaWxlIOino+aekOihqOi+vuW8j1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIFdhbGtlciA9IHJlcXVpcmUoJy4vd2Fsa2VyJyk7XG4vLyB2YXIgcmVhZFRlcnRpYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC10ZXJ0aWFyeS1leHByJyk7XG5cbi8qKlxuICog6Kej5p6Q6KGo6L6+5byPXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDmupDnoIFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VFeHByKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBzb3VyY2UudHlwZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIHZhciBleHByID0gcmVhZFRlcnRpYXJ5RXhwcihuZXcgV2Fsa2VyKHNvdXJjZSkpO1xuICAgIGV4cHIucmF3ID0gc291cmNlO1xuICAgIHJldHVybiBleHByO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZUV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDor7vlj5bosIPnlKhcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vZXhwci10eXBlJyk7XG4vLyB2YXIgcmVhZEFjY2Vzc29yID0gcmVxdWlyZSgnLi9yZWFkLWFjY2Vzc29yJyk7XG4vLyB2YXIgcmVhZFRlcnRpYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC10ZXJ0aWFyeS1leHByJyk7XG5cbi8qKlxuICog6K+75Y+W6LCD55SoXG4gKlxuICogQHBhcmFtIHtXYWxrZXJ9IHdhbGtlciDmupDnoIHor7vlj5blr7nosaFcbiAqIEBwYXJhbSB7QXJyYXk9fSBkZWZhdWx0QXJncyDpu5jorqTlj4LmlbBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVhZENhbGwod2Fsa2VyLCBkZWZhdWx0QXJncykge1xuICAgIHdhbGtlci5nb1VudGlsKCk7XG4gICAgdmFyIGlkZW50ID0gcmVhZEFjY2Vzc29yKHdhbGtlcik7XG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIGlmICh3YWxrZXIuZ29VbnRpbCg0MCkpIHsgLy8gKFxuICAgICAgICB3aGlsZSAoIXdhbGtlci5nb1VudGlsKDQxKSkgeyAvLyApXG4gICAgICAgICAgICBhcmdzLnB1c2gocmVhZFRlcnRpYXJ5RXhwcih3YWxrZXIpKTtcbiAgICAgICAgICAgIHdhbGtlci5nb1VudGlsKDQ0KTsgLy8gLFxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRBcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBkZWZhdWx0QXJncztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBFeHByVHlwZS5DQUxMLFxuICAgICAgICBuYW1lOiBpZGVudCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgIH07XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlYWRDYWxsO1xuXG5cbi8qKlxuICogQGZpbGUg6Kej5p6Q6LCD55SoXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBXYWxrZXIgPSByZXF1aXJlKCcuL3dhbGtlcicpO1xuLy8gdmFyIHJlYWRDYWxsID0gcmVxdWlyZSgnLi9yZWFkLWNhbGwnKTtcblxuLyoqXG4gKiDop6PmnpDosIPnlKhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOeggVxuICogQHBhcmFtIHtBcnJheT19IGRlZmF1bHRBcmdzIOm7mOiupOWPguaVsFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZUNhbGwoc291cmNlLCBkZWZhdWx0QXJncykge1xuICAgIHZhciBleHByID0gcmVhZENhbGwobmV3IFdhbGtlcihzb3VyY2UpLCBkZWZhdWx0QXJncyk7XG4gICAgZXhwci5yYXcgPSBzb3VyY2U7XG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlQ2FsbDtcblxuXG4vKipcbiAqIEBmaWxlIOino+aekOaPkuWAvOabv+aNolxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIFdhbGtlciA9IHJlcXVpcmUoJy4vd2Fsa2VyJyk7XG4vLyB2YXIgcmVhZFRlcnRpYXJ5RXhwciA9IHJlcXVpcmUoJy4vcmVhZC10ZXJ0aWFyeS1leHByJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIHJlYWRDYWxsID0gcmVxdWlyZSgnLi9yZWFkLWNhbGwnKTtcblxuLyoqXG4gKiDop6PmnpDmj5LlgLzmm7/mjaJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOa6kOeggVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZUludGVycChzb3VyY2UpIHtcbiAgICB2YXIgd2Fsa2VyID0gbmV3IFdhbGtlcihzb3VyY2UpO1xuXG4gICAgdmFyIGludGVycCA9IHtcbiAgICAgICAgdHlwZTogRXhwclR5cGUuSU5URVJQLFxuICAgICAgICBleHByOiByZWFkVGVydGlhcnlFeHByKHdhbGtlciksXG4gICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICByYXc6IHNvdXJjZVxuICAgIH07XG5cbiAgICB3aGlsZSAod2Fsa2VyLmdvVW50aWwoMTI0KSkgeyAvLyB8XG4gICAgICAgIHZhciBjYWxsRXhwciA9IHJlYWRDYWxsKHdhbGtlcik7XG4gICAgICAgIHN3aXRjaCAoY2FsbEV4cHIubmFtZS5wYXRoc1swXS52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgICAgIGludGVycC5vcmlnaW5hbCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGludGVycC5maWx0ZXJzLnB1c2goY2FsbEV4cHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycDtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcGFyc2VJbnRlcnA7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PnoIEgSFRNTCDlrZfnrKblrp7kvZNcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbnZhciBFTlRJVFlfREVDT0RFX01BUCA9IHtcbiAgICBsdDogJzwnLFxuICAgIGd0OiAnPicsXG4gICAgbmJzcDogJyAnLFxuICAgIHF1b3Q6ICdcXFwiJyxcbiAgICBlbXNwOiAnXFx1MjAwMycsXG4gICAgZW5zcDogJ1xcdTIwMDInLFxuICAgIHRoaW5zcDogJ1xcdTIwMDknLFxuICAgIGNvcHk6ICdcXHhhOScsXG4gICAgcmVnOiAnXFx4YWUnLFxuICAgIHp3bmo6ICdcXHUyMDBjJyxcbiAgICB6d2o6ICdcXHUyMDBkJyxcbiAgICBhbXA6ICcmJ1xufTtcblxuLyoqXG4gKiDop6PnoIEgSFRNTCDlrZfnrKblrp7kvZNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOimgeino+eggeeahOWtl+espuS4slxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBkZWNvZGVIVE1MRW50aXR5KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgLnJlcGxhY2UoLyYjKFswLTldKyk7L2csIGZ1bmN0aW9uIChtYXRjaCwgY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoK2NvZGUpO1xuICAgICAgICB9KVxuICAgICAgICAucmVwbGFjZSgvJiN4KFswLTlhLWZdKyk7L2lnLCBmdW5jdGlvbiAobWF0Y2gsIGNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC8mKFthLXpdKyk7L2lnLCBmdW5jdGlvbiAobWF0Y2gsIGNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBFTlRJVFlfREVDT0RFX01BUFtjb2RlXSB8fCBtYXRjaDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlY29kZUhUTUxFbnRpdHk7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PmnpDmlofmnKxcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBXYWxrZXIgPSByZXF1aXJlKCcuL3dhbGtlcicpO1xuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi9leHByLXR5cGUnKTtcbi8vIHZhciBwYXJzZUludGVycCA9IHJlcXVpcmUoJy4vcGFyc2UtaW50ZXJwJyk7XG4vLyB2YXIgZGVjb2RlSFRNTEVudGl0eSA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjb2RlLWh0bWwtZW50aXR5Jyk7XG5cbi8qKlxuICog5a+55a2X56ym5Liy6L+b6KGM5Y+v55So5LqObmV3IFJlZ0V4cOeahOWtl+mdouWMllxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDpnIDopoHlrZfpnaLljJbnmoTlrZfnrKbkuLJcbiAqIEByZXR1cm4ge3N0cmluZ30g5a2X56ym5Liy5a2X6Z2i5YyW57uT5p6cXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cExpdGVyYWwoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKC9bXFxeXFxbXFxdXFwkXFwoXFwpXFx7XFx9XFw/XFwqXFwuXFwrXFxcXF0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGM7XG4gICAgfSk7XG59XG5cbi8qKlxuICog6Kej5p6Q5paH5pysXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDmupDnoIFcbiAqIEBwYXJhbSB7QXJyYXk/fSBkZWxpbWl0ZXJzIOWIhumalOespuOAgum7mOiupOS4uiBbJ3t7JywgJ319J11cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VUZXh0KHNvdXJjZSwgZGVsaW1pdGVycykge1xuICAgIGRlbGltaXRlcnMgPSBkZWxpbWl0ZXJzIHx8IFsne3snLCAnfX0nXTtcbiAgICB2YXIgZXhwclN0YXJ0UmVnID0gbmV3IFJlZ0V4cChcbiAgICAgICAgcmVnZXhwTGl0ZXJhbChkZWxpbWl0ZXJzWzBdKSArICdcXFxccyooW1xcXFxzXFxcXFNdKz8pXFxcXHMqJyArIHJlZ2V4cExpdGVyYWwoZGVsaW1pdGVyc1sxXSksXG4gICAgICAgICdpZydcbiAgICApO1xuXG4gICAgdmFyIGV4cHJNYXRjaDtcblxuICAgIHZhciB3YWxrZXIgPSBuZXcgV2Fsa2VyKHNvdXJjZSk7XG4gICAgdmFyIGJlZm9yZUluZGV4ID0gMDtcblxuICAgIHZhciBleHByID0ge1xuICAgICAgICB0eXBlOiBFeHByVHlwZS5URVhULFxuICAgICAgICBzZWdzOiBbXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXNoU3RyaW5nVG9TZWcodGV4dCkge1xuICAgICAgICB0ZXh0ICYmIGV4cHIuc2Vncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLlNUUklORyxcbiAgICAgICAgICAgIGxpdGVyYWw6IHRleHQsXG4gICAgICAgICAgICB2YWx1ZTogZGVjb2RlSFRNTEVudGl0eSh0ZXh0KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKGV4cHJNYXRjaCA9IHdhbGtlci5tYXRjaChleHByU3RhcnRSZWcpKSAhPSBudWxsKSB7XG4gICAgICAgIHB1c2hTdHJpbmdUb1NlZyh3YWxrZXIuY3V0KFxuICAgICAgICAgICAgYmVmb3JlSW5kZXgsXG4gICAgICAgICAgICB3YWxrZXIuaW5kZXggLSBleHByTWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICkpO1xuXG4gICAgICAgIHZhciBpbnRlcnAgPSBwYXJzZUludGVycChleHByTWF0Y2hbMV0pO1xuICAgICAgICBleHByLm9yaWdpbmFsID0gZXhwci5vcmlnaW5hbCB8fCBpbnRlcnAub3JpZ2luYWw7XG5cbiAgICAgICAgZXhwci5zZWdzLnB1c2goaW50ZXJwKTtcbiAgICAgICAgYmVmb3JlSW5kZXggPSB3YWxrZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgcHVzaFN0cmluZ1RvU2VnKHdhbGtlci5jdXQoYmVmb3JlSW5kZXgpKTtcblxuXG5cbiAgICBpZiAoZXhwci5zZWdzLmxlbmd0aCA9PT0gMSAmJiBleHByLnNlZ3NbMF0udHlwZSA9PT0gRXhwclR5cGUuU1RSSU5HKSB7XG4gICAgICAgIGV4cHIudmFsdWUgPSBleHByLnNlZ3NbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlVGV4dDtcblxuXG4vKipcbiAqIEBmaWxlIOino+aekOaMh+S7pFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgV2Fsa2VyID0gcmVxdWlyZSgnLi93YWxrZXInKTtcbi8vIHZhciBwYXJzZUV4cHIgPSByZXF1aXJlKCcuL3BhcnNlLWV4cHInKTtcbi8vIHZhciBwYXJzZUNhbGwgPSByZXF1aXJlKCcuL3BhcnNlLWNhbGwnKTtcbi8vIHZhciBwYXJzZVRleHQgPSByZXF1aXJlKCcuL3BhcnNlLXRleHQnKTtcbi8vIHZhciByZWFkQWNjZXNzb3IgPSByZXF1aXJlKCcuL3JlYWQtYWNjZXNzb3InKTtcblxuLyoqXG4gKiDmjIfku6Top6PmnpDlmahcbiAqXG4gKiBAaW5uZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBkaXJlY3RpdmVQYXJzZXJzID0ge1xuICAgICdmb3InOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdhbGtlciA9IG5ldyBXYWxrZXIodmFsdWUpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB3YWxrZXIubWF0Y2goL15cXHMqKFtcXCQwLTlhLXpfXSspKFxccyosXFxzKihbXFwkMC05YS16X10rKSk/XFxzK2luXFxzKy9pZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGl0ZW06IHBhcnNlRXhwcihtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlRXhwcihtYXRjaFszXSB8fCAnJGluZGV4JyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlYWRBY2Nlc3Nvcih3YWxrZXIpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEZBVEFMXSBmb3Igc3ludGF4IGVycm9yOiAnICsgdmFsdWUpO1xuICAgICAgICAvLyAjW2VuZF1cbiAgICB9LFxuXG4gICAgJ3JlZic6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlVGV4dCh2YWx1ZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAnaWYnOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUV4cHIodmFsdWUucmVwbGFjZSgvKF5cXHtcXHt8XFx9XFx9JCkvZywgJycpKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAnZWxpZic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRXhwcih2YWx1ZS5yZXBsYWNlKC8oXlxce1xce3xcXH1cXH0kKS9nLCAnJykpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgICdlbHNlJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgJ2h0bWwnOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUV4cHIodmFsdWUucmVwbGFjZSgvKF5cXHtcXHt8XFx9XFx9JCkvZywgJycpKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAndHJhbnNpdGlvbic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlQ2FsbCh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOino+aekOaMh+S7pFxuICpcbiAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5oyH5Luk5ZCN56ewXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUg5oyH5Luk5YC8XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDop6PmnpDlj4LmlbBcbiAqIEBwYXJhbSB7QXJyYXk/fSBvcHRpb25zLmRlbGltaXRlcnMg5o+S5YC85YiG6ZqU56ym5YiX6KGoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlKGFOb2RlLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChuYW1lID09PSAnZWxzZS1pZicpIHtcbiAgICAgICAgbmFtZSA9ICdlbGlmJztcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gZGlyZWN0aXZlUGFyc2Vyc1tuYW1lXTtcbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICAgIChhTm9kZS5kaXJlY3RpdmVzW25hbWVdID0gcGFyc2VyKHZhbHVlLCBvcHRpb25zKSkucmF3ID0gdmFsdWU7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZURpcmVjdGl2ZTtcblxuXG4vKipcbiAqIEBmaWxlIOWvueWxnuaAp+S/oeaBr+i/m+ihjOWkhOeQhlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuXG4vKipcbiAqIOWvueWxnuaAp+S/oeaBr+i/m+ihjOWkhOeQhlxuICog5a+557uE5Lu255qEIGJpbmRzIOaIluiAheeJueauiueahOWxnuaAp++8iOavlOWmgiBpbnB1dCDnmoQgY2hlY2tlZO+8iemcgOimgeWkhOeQhlxuICpcbiAqIOaJgeW5s+WMlu+8mlxuICog5b2TIHRleHQg6Kej5p6Q5Y+q5pyJ5LiA6aG55pe277yM6KaB5LmI5bCx5pivIHN0cmluZ++8jOimgeS5iOWwseaYryBpbnRlcnBcbiAqIGludGVycCDmnInlj6/og73mmK/nu5HlrprliLDnu4Tku7blsZ7mgKfnmoTooajovr7lvI/vvIzkuI3luIzmnJvooqsgZXZhbCB0ZXh0IOaIkCBzdHJpbmdcbiAqIOaJgOS7pei/memHjOWBmuS4quWkhOeQhu+8jOWPquacieS4gOmhueaXtuebtOaOpeaKveWHuuadpVxuICpcbiAqIGJvb2zlsZ7mgKfvvJpcbiAqIOW9k+e7keWumumhueayoeacieWAvOaXtu+8jOm7mOiupOS4unRydWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcCDlsZ7mgKflr7nosaFcbiAqL1xuZnVuY3Rpb24gcG9zdFByb3AocHJvcCkge1xuICAgIHZhciBleHByID0gcHJvcC5leHByO1xuXG4gICAgaWYgKGV4cHIudHlwZSA9PT0gRXhwclR5cGUuVEVYVCkge1xuICAgICAgICBzd2l0Y2ggKGV4cHIuc2Vncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBwcm9wLmV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLkJPT0wsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGV4cHIgPSBwcm9wLmV4cHIgPSBleHByLnNlZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gRXhwclR5cGUuSU5URVJQICYmIGV4cHIuZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcC5leHByID0gZXhwci5leHByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcG9zdFByb3A7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PmnpDmir3osaHoioLngrnlsZ7mgKdcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIga2ViYWIyY2FtZWwgPSByZXF1aXJlKCcuLi91dGlsL2tlYmFiMmNhbWVsJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuL2V4cHItdHlwZScpO1xuLy8gdmFyIGNyZWF0ZUFjY2Vzc29yID0gcmVxdWlyZSgnLi9jcmVhdGUtYWNjZXNzb3InKTtcbi8vIHZhciBwYXJzZUV4cHIgPSByZXF1aXJlKCcuL3BhcnNlLWV4cHInKTtcbi8vIHZhciBwYXJzZUNhbGwgPSByZXF1aXJlKCcuL3BhcnNlLWNhbGwnKTtcbi8vIHZhciBwYXJzZVRleHQgPSByZXF1aXJlKCcuL3BhcnNlLXRleHQnKTtcbi8vIHZhciBwYXJzZURpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vcGFyc2UtZGlyZWN0aXZlJyk7XG4vLyB2YXIgcG9zdFByb3AgPSByZXF1aXJlKCcuL3Bvc3QtcHJvcCcpO1xuXG5cbi8qKlxuICog6Kej5p6Q5oq96LGh6IqC54K55bGe5oCnXG4gKlxuICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDlsZ7mgKflkI3np7BcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSDlsZ7mgKflgLxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOino+aekOWPguaVsFxuICogQHBhcmFtIHtBcnJheT99IG9wdGlvbnMuZGVsaW1pdGVycyDmj5LlgLzliIbpmpTnrKbliJfooahcbiAqL1xuZnVuY3Rpb24gaW50ZWdyYXRlQXR0cihhTm9kZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJlZml4SW5kZXggPSBuYW1lLmluZGV4T2YoJy0nKTtcbiAgICB2YXIgcmVhbE5hbWU7XG4gICAgdmFyIHByZWZpeDtcblxuICAgIGlmIChwcmVmaXhJbmRleCA+IDApIHtcbiAgICAgICAgcHJlZml4ID0gbmFtZS5zbGljZSgwLCBwcmVmaXhJbmRleCk7XG4gICAgICAgIHJlYWxOYW1lID0gbmFtZS5zbGljZShwcmVmaXhJbmRleCArIDEpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJlZml4KSB7XG4gICAgICAgIGNhc2UgJ29uJzpcbiAgICAgICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZWFsTmFtZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhTm9kZS5ldmVudHMucHVzaChldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvbkluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKChjb2xvbkluZGV4ID0gdmFsdWUuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSB2YWx1ZS5zbGljZSgwLCBjb2xvbkluZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIGV2ZW50SGFuZGxlcihcImRkOmFhXCIpIOi/meenjeaDheWGteS4jeiDveeul21vZGlmaWVy77yM6ZyA6KaB6L6o6K+GXG4gICAgICAgICAgICAgICAgaWYgKCEvXlthLXpdKyQvaS50ZXN0KG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBldmVudC5tb2RpZmllclttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoY29sb25JbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5leHByID0gcGFyc2VDYWxsKHZhbHVlLCBbXG4gICAgICAgICAgICAgICAgY3JlYXRlQWNjZXNzb3IoW1xuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IEV4cHJUeXBlLlNUUklORywgdmFsdWU6ICckZXZlbnQnIH1cbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzYW4nOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHBhcnNlRGlyZWN0aXZlKGFOb2RlLCByZWFsTmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncHJvcCc6XG4gICAgICAgICAgICBpbnRlZ3JhdGVQcm9wKGFOb2RlLCByZWFsTmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgIGlmICghYU5vZGUudmFycykge1xuICAgICAgICAgICAgICAgIGFOb2RlLnZhcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVhbE5hbWUgPSBrZWJhYjJjYW1lbChyZWFsTmFtZSk7XG4gICAgICAgICAgICBhTm9kZS52YXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJlYWxOYW1lLFxuICAgICAgICAgICAgICAgIGV4cHI6IHBhcnNlRXhwcih2YWx1ZS5yZXBsYWNlKC8oXlxce1xce3xcXH1cXH0kKS9nLCAnJykpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbnRlZ3JhdGVQcm9wKGFOb2RlLCBuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vKipcbiAqIOino+aekOaKveixoeiKgueCuee7keWumuWxnuaAp1xuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDlsZ7mgKflkI3np7BcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSDlsZ7mgKflgLxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOino+aekOWPguaVsFxuICogQHBhcmFtIHtBcnJheT99IG9wdGlvbnMuZGVsaW1pdGVycyDmj5LlgLzliIbpmpTnrKbliJfooahcbiAqL1xuZnVuY3Rpb24gaW50ZWdyYXRlUHJvcChhTm9kZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBwYXJzZSB0d28gd2F5IGJpbmRpbmcsIGUuZy4gdmFsdWU9XCJ7PWlkZW50PX1cIlxuICAgIHZhciB4TWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXlxcez1cXHMqKC4qPylcXHMqPVxcfSQvKTtcblxuICAgIGlmICh4TWF0Y2gpIHtcbiAgICAgICAgYU5vZGUucHJvcHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZXhwcjogcGFyc2VFeHByKHhNYXRjaFsxXSksXG4gICAgICAgICAgICB4OiAxLFxuICAgICAgICAgICAgcmF3OiB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcGFyc2Ugbm9ybWFsIHByb3BcbiAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZXhwcjogcGFyc2VUZXh0KHZhbHVlLCBvcHRpb25zLmRlbGltaXRlcnMpLFxuICAgICAgICByYXc6IHZhbHVlXG4gICAgfTtcblxuICAgIC8vIOi/memHjOS4jeiDveaKiuWPquacieS4gOS4quaPkuWAvOeahOWxnuaAp+aKveWPllxuICAgIC8vIOWboOS4uuaPkuWAvOmHjOeahOWAvOWPr+iDveaYr2h0bWzniYfmrrXvvIzlrrnmmJPooqvms6jlhaVcbiAgICAvLyDnu4Tku7bnmoTmlbDmja7nu5HlrprlnKjnu4Tku7Zpbml05pe25YGa5oq95Y+WXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgZWFjaChwcm9wLmV4cHIuc2VncywgZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgICAgIGlmIChzZWcudHlwZSA9PT0gRXhwclR5cGUuSU5URVJQKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZy5maWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuQ0FMTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNyZWF0ZUFjY2Vzc29yKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLlNUUklORyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdfJyArIHByb3AubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgIGlmIChhTm9kZS50YWdOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgcG9zdFByb3AocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhTm9kZS5wcm9wcy5wdXNoKHByb3ApO1xufVxuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVncmF0ZUF0dHI7XG5cblxuLyoqXG4gKiBAZmlsZSDop6PmnpDmqKHmnb9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGNyZWF0ZUFOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtYS1ub2RlJyk7XG4vLyB2YXIgV2Fsa2VyID0gcmVxdWlyZSgnLi93YWxrZXInKTtcbi8vIHZhciBpbnRlZ3JhdGVBdHRyID0gcmVxdWlyZSgnLi9pbnRlZ3JhdGUtYXR0cicpO1xuLy8gdmFyIHBhcnNlVGV4dCA9IHJlcXVpcmUoJy4vcGFyc2UtdGV4dCcpO1xuLy8gdmFyIGF1dG9DbG9zZVRhZ3MgPSByZXF1aXJlKCcuLi9icm93c2VyL2F1dG8tY2xvc2UtdGFncycpO1xuXG4vLyAjW2JlZ2luXSBlcnJvclxuZnVuY3Rpb24gZ2V0WFBhdGgoc3RhY2ssIGN1cnJlbnRUYWdOYW1lKSB7XG4gICAgdmFyIHBhdGggPSBbJ1JPT1QnXTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcGF0aC5wdXNoKHN0YWNrW2ldLnRhZ05hbWUpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRhZ05hbWUpIHtcbiAgICAgICAgcGF0aC5wdXNoKGN1cnJlbnRUYWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguam9pbignPicpO1xufVxuLy8gI1tlbmRdXG5cbi8qIGVzbGludC1kaXNhYmxlIGZlY3MtbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiDop6PmnpAgdGVtcGxhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIHRlbXBsYXRl5rqQ56CBXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdGlvbnMg6Kej5p6Q5Y+C5pWwXG4gKiBAcGFyYW0ge3N0cmluZz99IG9wdGlvbnMudHJpbVdoaXRlc3BhY2Ug56m655m95paH5pys55qE5aSE55CG562W55Wl44CCbm9uZXxibGFua3xhbGxcbiAqIEBwYXJhbSB7QXJyYXk/fSBvcHRpb25zLmRlbGltaXRlcnMg5o+S5YC85YiG6ZqU56ym5YiX6KGoXG4gKiBAcmV0dXJuIHtBTm9kZX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnRyaW1XaGl0ZXNwYWNlID0gb3B0aW9ucy50cmltV2hpdGVzcGFjZSB8fCAnbm9uZSc7XG5cbiAgICB2YXIgcm9vdE5vZGUgPSBjcmVhdGVBTm9kZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9tZywgJycpLnJlcGxhY2UoLyheXFxzK3xcXHMrJCkvZywgJycpO1xuICAgIHZhciB3YWxrZXIgPSBuZXcgV2Fsa2VyKHNvdXJjZSk7XG5cbiAgICB2YXIgdGFnUmVnID0gLzwoXFwvKT8oW2EtejAtOS1dKylcXHMqL2lnO1xuICAgIHZhciBhdHRyUmVnID0gLyhbLTowLTlhLXpcXChcXClcXFtcXF1dKykoXFxzKj1cXHMqKFsnXCJdKShbXlxcM10qPylcXDMpP1xccyovaWc7XG5cbiAgICB2YXIgdGFnTWF0Y2g7XG4gICAgdmFyIGN1cnJlbnROb2RlID0gcm9vdE5vZGU7XG4gICAgdmFyIHN0YWNrID0gW3Jvb3ROb2RlXTtcbiAgICB2YXIgc3RhY2tJbmRleCA9IDA7XG4gICAgdmFyIGJlZm9yZUxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHRhZ01hdGNoID0gd2Fsa2VyLm1hdGNoKHRhZ1JlZykpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHRhZ0VuZCA9IHRhZ01hdGNoWzFdO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhZ01hdGNoWzJdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcHVzaFRleHROb2RlKHNvdXJjZS5zbGljZShcbiAgICAgICAgICAgIGJlZm9yZUxhc3RJbmRleCxcbiAgICAgICAgICAgIHdhbGtlci5pbmRleCAtIHRhZ01hdGNoWzBdLmxlbmd0aFxuICAgICAgICApKTtcblxuICAgICAgICAvLyA2MjogPlxuICAgICAgICAvLyA0NzogL1xuICAgICAgICAvLyDlpITnkIYgPC94eHh4ID5cbiAgICAgICAgaWYgKHRhZ0VuZCAmJiB3YWxrZXIuY3VycmVudENvZGUoKSA9PT0gNjIpIHtcbiAgICAgICAgICAgIC8vIOa7oei2s+WFs+mXreagh+etvueahOadoeS7tuaXtu+8jOWFs+mXreagh+etvlxuICAgICAgICAgICAgLy8g5ZCR5LiK5p+l5om+5Yiw5a+55bqU5qCH562+77yM5om+5LiN5Yiw5pe25b+955Wl5YWz6ZetXG4gICAgICAgICAgICB2YXIgY2xvc2VJbmRleCA9IHN0YWNrSW5kZXg7XG5cbiAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgICAgICAgICAvLyDlpoLmnpzmraPlnKjpl63lkIjkuIDkuKroh6rpl63lkIjnmoTmoIfnrb7vvIzkvovlpoIgPC9pbnB1dD7vvIzmiqXplJlcbiAgICAgICAgICAgIGlmIChhdXRvQ2xvc2VUYWdzW3RhZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnXG4gICAgICAgICAgICAgICAgICAgICsgJ1tTQU4gRVJST1JdICcgKyBnZXRYUGF0aChzdGFjaywgdGFnTmFtZSkgKyAnIGlzIGEgYGF1dG8gY2xvc2VkYCB0YWcsICdcbiAgICAgICAgICAgICAgICAgICAgKyAnc28gaXQgY2Fubm90IGJlIGNsb3NlZCB3aXRoIDwvJyArIHRhZ05hbWUgKyAnPidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlpoLmnpzlhbPpl63nmoQgdGFnIOWSjOW9k+WJjeaJk+W8gOeahOS4jeS4gOiHtO+8jOaKpemUmVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0YWNrW2Nsb3NlSW5kZXhdLnRhZ05hbWUgIT09IHRhZ05hbWVcbiAgICAgICAgICAgICAgICAvLyDov5nph4zopoHmioogdGFibGUg6Ieq5Yqo5re75YqgIHRib2R5IOeahOaDheWGtee7meWOu+aOiVxuICAgICAgICAgICAgICAgICYmICEodGFnTmFtZSA9PT0gJ3RhYmxlJyAmJiBzdGFja1tjbG9zZUluZGV4XS50YWdOYW1lID09PSAndGJvZHknKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSAnICsgZ2V0WFBhdGgoc3RhY2spICsgJyBpcyBjbG9zZWQgd2l0aCAnICsgdGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgd2hpbGUgKGNsb3NlSW5kZXggPiAwICYmIHN0YWNrW2Nsb3NlSW5kZXhdLnRhZ05hbWUgIT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjbG9zZUluZGV4LS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbG9zZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YWNrSW5kZXggPSBjbG9zZUluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fsa2VyLmdvKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICAgICAgLy8g5aSE55CGIDwveHh4IOmdnuato+W4uOmXreWQiOagh+etvlxuICAgICAgICBlbHNlIGlmICh0YWdFbmQpIHtcblxuICAgICAgICAgICAgLy8g5aaC5p6c6Zet5ZCI5qCH562+5pe277yM5Yy56YWN5ZCO55qE5LiL5LiA5Liq5a2X56ym5pivIDzvvIzljbPkuIvkuIDkuKrmoIfnrb7nmoTlvIDlp4vvvIzpgqPkuYjlvZPliY3pl63lkIjmoIfnrb7mnKrpl63lkIhcbiAgICAgICAgICAgIGlmICh3YWxrZXIuY3VycmVudENvZGUoKSA9PT0gNjApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJydcbiAgICAgICAgICAgICAgICAgICAgKyAnW1NBTiBFUlJPUl0gJyArIGdldFhQYXRoKHN0YWNrKVxuICAgICAgICAgICAgICAgICAgICArICdcXCdzIGNsb3NlIHRhZyBub3QgY2xvc2VkJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOmXreWQiOagh+etvuacieWxnuaAp1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnXG4gICAgICAgICAgICAgICAgKyAnW1NBTiBFUlJPUl0gJyArIGdldFhQYXRoKHN0YWNrKVxuICAgICAgICAgICAgICAgICsgJ1xcJ3MgY2xvc2UgdGFnIGhhcyBhdHRyaWJ1dGVzJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG4gICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgIGVsc2UgaWYgKCF0YWdFbmQpIHtcbiAgICAgICAgICAgIHZhciBhRWxlbWVudCA9IGNyZWF0ZUFOb2RlKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0YWdDbG9zZSA9IGF1dG9DbG9zZVRhZ3NbdGFnTmFtZV07XG5cbiAgICAgICAgICAgIC8vIOino+aekCBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXJDb2RlID0gd2Fsa2VyLmN1cnJlbnRDb2RlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyDmoIfnrb7nu5PmnZ/ml7bot7Plh7ogYXR0cmlidXRlcyDor7vlj5ZcbiAgICAgICAgICAgICAgICAvLyDmoIfnrb7lj6/og73nm7TmjqXnu5PmnZ/miJbpl63lkIjnu5PmnZ9cbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuZ28oMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDpgYfliLAgLz4g5oyJ6Zet5ZCI5aSE55CGXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dENoYXJDb2RlID09PSA0N1xuICAgICAgICAgICAgICAgICAgICAmJiB3YWxrZXIuY2hhckNvZGUod2Fsa2VyLmluZGV4ICsgMSkgPT09IDYyXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5nbygyKTtcbiAgICAgICAgICAgICAgICAgICAgdGFnQ2xvc2UgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIOWcqOWkhOeQhuS4gOS4qiBvcGVuIOagh+etvuaXtu+8jOWmguaenOmBh+WIsOS6hiA877yMIOWNs+S4i+S4gOS4quagh+etvueahOW8gOWni++8jOWImeW9k+WJjeagh+etvuacquiDveato+W4uOmXreWQiO+8jOaKpemUmVxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhckNvZGUgPT09IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gJyArIGdldFhQYXRoKHN0YWNrLCB0YWdOYW1lKSArICcgaXMgbm90IGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgICAgIC8vIOivu+WPliBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck1hdGNoID0gd2Fsa2VyLm1hdGNoKGF0dHJSZWcpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyTWF0Y2gpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzlsZ7mgKfmnIkgPe+8jOS9huayoeWPluWIsCB2YWx1Ze+8jOaKpemUmVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY2hhckNvZGUoYXR0ck1hdGNoLmluZGV4ICsgYXR0ck1hdGNoWzFdLmxlbmd0aCkgPT09IDYxXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhYXR0ck1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnW1NBTiBFUlJPUl0gJyArIGdldFhQYXRoKHN0YWNrLCB0YWdOYW1lKSArICcgYXR0cmlidXRlIGAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhdHRyTWF0Y2hbMV0gKyAnYCBpcyBub3Qgd3JhcHBlZCB3aXRoIFwiXCInXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICAgICAgICAgIGludGVncmF0ZUF0dHIoXG4gICAgICAgICAgICAgICAgICAgICAgICBhRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJNYXRjaFsyXSA/IGF0dHJNYXRjaFs0XSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYXRjaCBpZiBkaXJlY3RpdmUgZm9yIGVsc2UvZWxpZiBkaXJlY3RpdmVcbiAgICAgICAgICAgIHZhciBlbHNlRGlyZWN0aXZlID0gYUVsZW1lbnQuZGlyZWN0aXZlc1snZWxzZSddIHx8IGFFbGVtZW50LmRpcmVjdGl2ZXMuZWxpZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgICAgIGlmIChlbHNlRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENoaWxkcmVuTGVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudENoaWxkcmVuTGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudENoaWxkID0gY3VycmVudE5vZGUuY2hpbGRyZW5bcGFyZW50Q2hpbGRyZW5MZW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Q2hpbGQudGV4dEV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnNwbGljZShwYXJlbnRDaGlsZHJlbkxlbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Q2hpbGQuZGlyZWN0aXZlc1snaWYnXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEZBVEVMXSBlbHNlIG5vdCBtYXRjaCBpZi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDaGlsZC5lbHNlcyA9IHBhcmVudENoaWxkLmVsc2VzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDaGlsZC5lbHNlcy5wdXNoKGFFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYUVsZW1lbnQudGFnTmFtZSA9PT0gJ3RyJyAmJiBjdXJyZW50Tm9kZS50YWdOYW1lID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0Ym9keU5vZGUgPSBjcmVhdGVBTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGJvZHknXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKHRib2R5Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGJvZHlOb2RlO1xuICAgICAgICAgICAgICAgICAgICBzdGFja1srK3N0YWNrSW5kZXhdID0gdGJvZHlOb2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2goYUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhZ0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBhRWxlbWVudDtcbiAgICAgICAgICAgICAgICBzdGFja1srK3N0YWNrSW5kZXhdID0gYUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBiZWZvcmVMYXN0SW5kZXggPSB3YWxrZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgcHVzaFRleHROb2RlKHdhbGtlci5jdXQoYmVmb3JlTGFzdEluZGV4KSk7XG5cbiAgICByZXR1cm4gcm9vdE5vZGU7XG5cbiAgICAvKipcbiAgICAgKiDlnKjor7vlj5bmoIjkuK3mt7vliqDmlofmnKzoioLngrlcbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IOaWh+acrOWGheWuuVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1c2hUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy50cmltV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgY2FzZSAnYmxhbmsnOlxuICAgICAgICAgICAgICAgIGlmICgvXlxccyskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL2csICcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKGNyZWF0ZUFOb2RlKHtcbiAgICAgICAgICAgICAgICB0ZXh0RXhwcjogcGFyc2VUZXh0KHRleHQsIG9wdGlvbnMuZGVsaW1pdGVycylcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyogZXNsaW50LWVuYWJsZSBmZWNzLW1heC1zdGF0ZW1lbnRzICovXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlVGVtcGxhdGU7XG5cblxuLyoqXG4gKiBAZmlsZSDpu5jorqRmaWx0ZXJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyogZXNsaW50LWRpc2FibGUgZmVjcy1jYW1lbGNhc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuXG4vKipcbiAqIOm7mOiupGZpbHRlclxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIERFRkFVTFRfRklMVEVSUyA9IHtcblxuICAgIC8qKlxuICAgICAqIFVSTOe8lueggWZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSDmupDkuLJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IOabv+aNoue7k+aenOS4slxuICAgICAqL1xuICAgIHVybDogZW5jb2RlVVJJQ29tcG9uZW50LFxuXG4gICAgX2NsYXNzOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH0sXG5cbiAgICBfc3R5bGU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGtleSArICc6JyArIHNvdXJjZVtrZXldICsgJzsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gICAgX3NlcDogZnVuY3Rpb24gKHNvdXJjZSwgc2VwKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UgPyBzZXAgKyBzb3VyY2UgOiBzb3VyY2U7XG4gICAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgZmVjcy1jYW1lbGNhc2UgKi9cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gREVGQVVMVF9GSUxURVJTO1xuXG5cbi8qKlxuICogQGZpbGUg6KGo6L6+5byP6K6h566XXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG4vLyB2YXIgREVGQVVMVF9GSUxURVJTID0gcmVxdWlyZSgnLi9kZWZhdWx0LWZpbHRlcnMnKTtcbi8vIHZhciBldmFsQXJncyA9IHJlcXVpcmUoJy4vZXZhbC1hcmdzJyk7XG4vLyB2YXIgZGF0YUNhY2hlID0gcmVxdWlyZSgnLi9kYXRhLWNhY2hlJyk7XG5cbi8qKlxuICog6K6h566X6KGo6L6+5byP55qE5YC8XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byP5a+56LGhXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u5a655Zmo5a+56LGhXG4gKiBAcGFyYW0ge0NvbXBvbmVudD19IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gZXZhbEV4cHIoZXhwciwgZGF0YSwgb3duZXIpIHtcbiAgICBpZiAoZXhwci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGRhdGFDYWNoZS5nZXQoZGF0YSwgZXhwcik7XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5VTkFSWTpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICFldmFsRXhwcihleHByLmV4cHIsIGRhdGEsIG93bmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5CSU5BUlk6XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSA9IGV2YWxFeHByKGV4cHIuc2Vnc1swXSwgZGF0YSwgb3duZXIpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodFZhbHVlID0gZXZhbEV4cHIoZXhwci5zZWdzWzFdLCBkYXRhLCBvd25lcik7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICUgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgKyByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSAtIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICogcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgLyByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSA8IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlID4gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgJiYgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgIT0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlIDw9IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSA9PSByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgPj0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1NTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGVmdFZhbHVlICE9PSByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTgzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0VmFsdWUgPT09IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDg6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSB8fCByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuVEVSVElBUlk6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsRXhwcihcbiAgICAgICAgICAgICAgICAgICAgZXhwci5zZWdzW2V2YWxFeHByKGV4cHIuc2Vnc1swXSwgZGF0YSwgb3duZXIpID8gMSA6IDJdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBvd25lclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuQUNDRVNTT1I6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhLmdldChleHByKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5JTlRFUlA6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsRXhwcihleHByLmV4cHIsIGRhdGEsIG93bmVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHIuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBleHByLmZpbHRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyTmFtZSA9IGZpbHRlci5uYW1lLnBhdGhzWzBdLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIuZmlsdGVyc1tmaWx0ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3duZXIuZmlsdGVyc1tmaWx0ZXJOYW1lXS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV0uY29uY2F0KGV2YWxBcmdzKGZpbHRlci5hcmdzLCBkYXRhLCBvd25lcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKERFRkFVTFRfRklMVEVSU1tmaWx0ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gREVGQVVMVF9GSUxURVJTW2ZpbHRlck5hbWVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmFyZ3NbMF0gPyBmaWx0ZXIuYXJnc1swXS52YWx1ZSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5URVhUOlxuICAgICAgICAgICAgICAgIHZhciBidWYgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHIuc2Vncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IGV4cHIuc2Vnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnVmICs9IHNlZy52YWx1ZSB8fCBldmFsRXhwcihzZWcsIGRhdGEsIG93bmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFDYWNoZS5zZXQoZGF0YSwgZXhwciwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZXZhbEV4cHI7XG5cblxuLyoqXG4gKiBAZmlsZSDkuLrlh73mlbDosIPnlKjorqHnrpflj4LmlbDmlbDnu4TnmoTlgLxcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcblxuLyoqXG4gKiDkuLrlh73mlbDosIPnlKjorqHnrpflj4LmlbDmlbDnu4TnmoTlgLxcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIOWPguaVsOihqOi+vuW8j+WIl+ihqFxuICogQHBhcmFtIHtEYXRhfSBkYXRhIOaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOe7hOS7tueOr+Wig1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGV2YWxBcmdzKGFyZ3MsIGRhdGEsIG93bmVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChldmFsRXhwcihhcmdzW2ldLCBkYXRhLCBvd25lcikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGV2YWxBcmdzO1xuXG5cbi8qKlxuICogQGZpbGUg5pWw5o2u57yT5a2Y566h55CG5ZmoXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cblxudmFyIGRhdGFDYWNoZVNvdXJjZSA9IHt9O1xudmFyIGRhdGFDYWNoZUNsZWFybHkgPSAxO1xuXG4vKipcbiAqIOaVsOaNrue8k+WtmOeuoeeQhuWZqFxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGRhdGFDYWNoZSA9IHtcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRhdGFDYWNoZUNsZWFybHkpIHtcbiAgICAgICAgICAgIGRhdGFDYWNoZUNsZWFybHkgPSAxO1xuICAgICAgICAgICAgZGF0YUNhY2hlU291cmNlID0ge307XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0YSwgZXhwciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGV4cHIucmF3KSB7XG4gICAgICAgICAgICBkYXRhQ2FjaGVDbGVhcmx5ID0gMDtcbiAgICAgICAgICAgIChkYXRhQ2FjaGVTb3VyY2VbZGF0YS5pZF0gPSBkYXRhQ2FjaGVTb3VyY2VbZGF0YS5pZF0gfHwge30pW2V4cHIucmF3XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGRhdGEsIGV4cHIpIHtcbiAgICAgICAgaWYgKGV4cHIucmF3ICYmIGRhdGFDYWNoZVNvdXJjZVtkYXRhLmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFDYWNoZVNvdXJjZVtkYXRhLmlkXVtleHByLnJhd107XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdGFDYWNoZTtcblxuXG4vKipcbiAqIEBmaWxlIOavlOi+g+WPmOabtOihqOi+vuW8j+S4juebruagh+ihqOi+vuW8j+S5i+mXtOeahOWFs+ezu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi9ldmFsLWV4cHInKTtcbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbi8qKlxuICog5Yik5pat5Y+Y5pu06KGo6L6+5byP5LiO5aSa5Liq6KGo6L6+5byP5LmL6Ze055qE5YWz57O777yMMOS4uuWujOWFqOayoeWFs+ezu++8jDHkuLrmnInlhbPns7tcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VFeHByIOebruagh+ihqOi+vuW8j1xuICogQHBhcmFtIHtBcnJheX0gZXhwcnMg5aSa5Liq5rqQ6KGo6L6+5byPXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg6KGo6L6+5byP5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNoYW5nZUV4cHJDb21wYXJlRXhwcnMoY2hhbmdlRXhwciwgZXhwcnMsIGRhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4cHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlRXhwciwgZXhwcnNbaV0sIGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIOavlOi+g+WPmOabtOihqOi+vuW8j+S4juebruagh+ihqOi+vuW8j+S5i+mXtOeahOWFs+ezu++8jOeUqOS6juinhuWbvuabtOaWsOWIpOaWrVxuICog6KeG5Zu+5pu05paw6ZyA6KaB5qC55o2u5YW25YWz57O777yM5YGa5Ye655u45bqU55qE5pu05paw6KGM5Li6XG4gKlxuICogMDog5a6M5YWo5rKh5YWz57O7XG4gKiAxOiDlj5jmm7Tooajovr7lvI/mmK/nm67moIfooajovr7lvI/nmoTmr43pobko5aaCYeS4jmEuYikg5oiWIOihqOekuumcgOimgeWujOWFqOWPmOWMllxuICogMjog5Y+Y5pu06KGo6L6+5byP5piv55uu5qCH6KGo6L6+5byP55u4562JXG4gKiA+Mjog5Y+Y5pu06KGo6L6+5byP5piv55uu5qCH6KGo6L6+5byP55qE5a2Q6aG577yM5aaCYS5iLmPkuI5hLmJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlRXhwciDlj5jmm7Tooajovr7lvI9cbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByIOimgeavlOi+g+eahOebruagh+ihqOi+vuW8j1xuICogQHBhcmFtIHtEYXRhfSBkYXRhIOihqOi+vuW8j+aJgOWxnuaVsOaNrueOr+Wig1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBleHByLCBkYXRhKSB7XG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBFeHByVHlwZS5BQ0NFU1NPUjpcbiAgICAgICAgICAgIHZhciBwYXRocyA9IGV4cHIucGF0aHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNoYW5nZVBhdGhzID0gY2hhbmdlRXhwci5wYXRocztcbiAgICAgICAgICAgIHZhciBjaGFuZ2VMZW4gPSBjaGFuZ2VQYXRocy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRXhwciA9IHBhdGhzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhFeHByLnR5cGUgPT09IEV4cHJUeXBlLkFDQ0VTU09SXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZUV4cHIsIHBhdGhFeHByLCBkYXRhKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIGkgPCBjaGFuZ2VMZW5cbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICAgICAgICAgICAgICAgICYmIChwYXRoRXhwci52YWx1ZSB8fCBldmFsRXhwcihwYXRoRXhwciwgZGF0YSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAhPSAoY2hhbmdlUGF0aHNbaV0udmFsdWUgfHwgZXZhbEV4cHIoY2hhbmdlUGF0aHNbaV0sIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1hdGgubWF4KDEsIGNoYW5nZUxlbiAtIGxlbiArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIEV4cHJUeXBlLlVOQVJZOlxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZUV4cHIsIGV4cHIuZXhwciwgZGF0YSkgPyAxIDogMDtcblxuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuVEVYVDpcbiAgICAgICAgY2FzZSBFeHByVHlwZS5CSU5BUlk6XG4gICAgICAgIGNhc2UgRXhwclR5cGUuVEVSVElBUlk6XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlRXhwckNvbXBhcmVFeHBycyhjaGFuZ2VFeHByLCBleHByLnNlZ3MsIGRhdGEpO1xuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuSU5URVJQOlxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBleHByLmV4cHIsIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBlYWNoKGV4cHIuZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJSZXN1bHQgPSBjaGFuZ2VFeHByQ29tcGFyZUV4cHJzKGNoYW5nZUV4cHIsIGZpbHRlci5hcmdzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyUmVzdWx0ID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjaGFuZ2VFeHByQ29tcGFyZTtcblxuXG4vKipcbiAqIEBmaWxlIOaVsOaNruWPmOabtOexu+Wei+aemuS4vlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDmlbDmja7lj5jmm7TnsbvlnovmnprkuL5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBEYXRhQ2hhbmdlVHlwZSA9IHtcbiAgICBTRVQ6IDEsXG4gICAgU1BMSUNFOiAyXG59O1xuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEYXRhQ2hhbmdlVHlwZTtcblxuXG4vKipcbiAqIEBmaWxlIOeUn+WRveWRqOacn+exu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuZnVuY3Rpb24gbGlmZUN5Y2xlT3duSXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzW25hbWVdO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBmZWNzLXZhbGlkLXZhci1qc2RvYyAqL1xuLyoqXG4gKiDoioLngrnnlJ/lkb3lkajmnJ/kv6Hmga9cbiAqXG4gKiBAaW5uZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBMaWZlQ3ljbGUgPSB7XG4gICAgc3RhcnQ6IHt9LFxuXG4gICAgY29tcGlsZWQ6IHtcbiAgICAgICAgaXM6IGxpZmVDeWNsZU93bklzLFxuICAgICAgICBjb21waWxlZDogdHJ1ZVxuICAgIH0sXG5cbiAgICBpbml0ZWQ6IHtcbiAgICAgICAgaXM6IGxpZmVDeWNsZU93bklzLFxuICAgICAgICBjb21waWxlZDogdHJ1ZSxcbiAgICAgICAgaW5pdGVkOiB0cnVlXG4gICAgfSxcblxuICAgIHBhaW50aW5nOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgY29tcGlsZWQ6IHRydWUsXG4gICAgICAgIGluaXRlZDogdHJ1ZSxcbiAgICAgICAgcGFpbnRpbmc6IHRydWVcbiAgICB9LFxuXG4gICAgY3JlYXRlZDoge1xuICAgICAgICBpczogbGlmZUN5Y2xlT3duSXMsXG4gICAgICAgIGNvbXBpbGVkOiB0cnVlLFxuICAgICAgICBpbml0ZWQ6IHRydWUsXG4gICAgICAgIGNyZWF0ZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgYXR0YWNoZWQ6IHtcbiAgICAgICAgaXM6IGxpZmVDeWNsZU93bklzLFxuICAgICAgICBjb21waWxlZDogdHJ1ZSxcbiAgICAgICAgaW5pdGVkOiB0cnVlLFxuICAgICAgICBjcmVhdGVkOiB0cnVlLFxuICAgICAgICBhdHRhY2hlZDogdHJ1ZVxuICAgIH0sXG5cbiAgICBsZWF2aW5nOiB7XG4gICAgICAgIGlzOiBsaWZlQ3ljbGVPd25JcyxcbiAgICAgICAgY29tcGlsZWQ6IHRydWUsXG4gICAgICAgIGluaXRlZDogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZDogdHJ1ZSxcbiAgICAgICAgYXR0YWNoZWQ6IHRydWUsXG4gICAgICAgIGxlYXZpbmc6IHRydWVcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IHtcbiAgICAgICAgaXM6IGxpZmVDeWNsZU93bklzLFxuICAgICAgICBjb21waWxlZDogdHJ1ZSxcbiAgICAgICAgaW5pdGVkOiB0cnVlLFxuICAgICAgICBjcmVhdGVkOiB0cnVlLFxuICAgICAgICBkZXRhY2hlZDogdHJ1ZVxuICAgIH0sXG5cbiAgICBkaXNwb3NlZDoge1xuICAgICAgICBpczogbGlmZUN5Y2xlT3duSXMsXG4gICAgICAgIGRpc3Bvc2VkOiB0cnVlXG4gICAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgZmVjcy12YWxpZC12YXItanNkb2MgKi9cblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaWZlQ3ljbGU7XG5cblxuLyoqXG4gKiBAZmlsZSDoioLngrnnsbvlnotcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6IqC54K557G75Z6LXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgTm9kZVR5cGUgPSB7XG4gICAgVEVYVDogMSxcbiAgICBJRjogMixcbiAgICBGT1I6IDMsXG4gICAgRUxFTTogNCxcbiAgICBDTVBUOiA1LFxuICAgIFNMT1Q6IDYsXG4gICAgVFBMOiA3XG59O1xuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBOb2RlVHlwZTtcblxuXG4vKipcbiAqIEBmaWxlIOiOt+WPliBBTm9kZSBwcm9wcyDmlbDnu4TkuK3nm7jlupQgbmFtZSDnmoTpoblcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6I635Y+WIEFOb2RlIHByb3BzIOaVsOe7hOS4reebuOW6lCBuYW1lIOeahOmhuVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhTm9kZSBBTm9kZeWvueixoVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZeWxnuaAp+WMuemFjeS4slxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRBTm9kZVByb3AoYU5vZGUsIG5hbWUpIHtcbiAgICB2YXIgaW5kZXggPSBhTm9kZS5ob3RzcG90LnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhTm9kZS5wcm9wc1tpbmRleF07XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRBTm9kZVByb3A7XG5cblxuLyoqXG4gKiBAZmlsZSDojrflj5blsZ7mgKflpITnkIblr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBjb250YWlucyA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGFpbnMnKTtcbi8vIHZhciBlbXB0eSA9IHJlcXVpcmUoJy4uL3V0aWwvZW1wdHknKTtcbi8vIHZhciBzdmdUYWdzID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9zdmctdGFncycpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBnZXRBTm9kZVByb3AgPSByZXF1aXJlKCcuL2dldC1hLW5vZGUtcHJvcCcpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcblxuXG4vKipcbiAqIEhUTUwg5bGe5oCn5ZKMIERPTSDmk43kvZzlsZ7mgKfnmoTlr7nnhafooahcbiAqXG4gKiBAaW5uZXJcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEhUTUxfQVRUUl9QUk9QX01BUCA9IHtcbiAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICdjZWxscGFkZGluZyc6ICdjZWxsUGFkZGluZycsXG4gICAgJ2NlbGxzcGFjaW5nJzogJ2NlbGxTcGFjaW5nJyxcbiAgICAnY29sc3Bhbic6ICdjb2xTcGFuJyxcbiAgICAncm93c3Bhbic6ICdyb3dTcGFuJyxcbiAgICAndmFsaWduJzogJ3ZBbGlnbicsXG4gICAgJ3VzZW1hcCc6ICd1c2VNYXAnLFxuICAgICdmcmFtZWJvcmRlcic6ICdmcmFtZUJvcmRlcicsXG4gICAgJ2Zvcic6ICdodG1sRm9yJ1xufTtcblxuLyoqXG4gKiDpu5jorqTnmoTlhYPntKDnmoTlsZ7mgKforr7nva7nmoTlj5jmjaLmlrnms5VcbiAqXG4gKiBAaW5uZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBkZWZhdWx0RWxlbWVudFByb3BIYW5kbGVyID0ge1xuICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUsIG5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gSFRNTF9BVFRSX1BST1BfTUFQW25hbWVdIHx8IG5hbWU7XG5cbiAgICAgICAgLy8gaW5wdXQg55qEIHR5cGUg5piv5Liq54m55q6K5bGe5oCn77yM5YW25a6e5Lmf5bqU6K+l55SoIHNldEF0dHJpYnV0ZVxuICAgICAgICAvLyDkvYbmmK8gdHlwZSDkuI3lupTor6Xov5DooYzml7bliqjmgIHmlLnlj5jvvIzlkKbliJnkvJrmnInlhbzlrrnmgKfpl67pophcbiAgICAgICAgLy8g5omA5Lul6L+Z6YeM55u05o6l5bCx5LiN566h5LqGXG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBlbCkge1xuICAgICAgICAgICAgZWxbcHJvcE5hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXR0cmlidXRlIOe7keWumueahOaYryB0ZXh077yM5omA5Lul5LiN5Lya5Ye6546wIG51bGwg55qE5oOF5Ya177yM6L+Z6YeM5peg6ZyA5aSE55CGXG4gICAgICAgIC8vIOaNouWPpeivneadpeivtO+8jHNhbiDmmK/lgZrkuI3liLAgYXR0cmlidXRlIOaXtuacieaXtuaXoOeahFxuICAgICAgICAvLyBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAvLyB9XG4gICAgfSxcblxuICAgIG91dHB1dDogZnVuY3Rpb24gKGVsZW1lbnQsIGJpbmRJbmZvLCBkYXRhKSB7XG4gICAgICAgIGRhdGEuc2V0KGJpbmRJbmZvLmV4cHIsIGVsZW1lbnQuZWxbYmluZEluZm8ubmFtZV0sIHtcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgIGlkOiBlbGVtZW50LmlkLFxuICAgICAgICAgICAgICAgIHByb3A6IGJpbmRJbmZvLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxudmFyIHN2Z1Byb3BIYW5kbGVyID0ge1xuICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUsIG5hbWUpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgYm9vbFByb3BIYW5kbGVyID0ge1xuICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUsIG5hbWUsIGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gSFRNTF9BVFRSX1BST1BfTUFQW25hbWVdIHx8IG5hbWU7XG4gICAgICAgIGVsW3Byb3BOYW1lXSA9ICEhKHByb3AgJiYgcHJvcC5yYXcgPT09ICcnXG4gICAgICAgICAgICB8fCB2YWx1ZSAmJiB2YWx1ZSAhPT0gJ2ZhbHNlJyAmJiB2YWx1ZSAhPT0gJzAnKTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmZWNzLXByb3BlcnRpZXMtcXVvdGUgKi9cbi8qKlxuICog6buY6K6k55qE5bGe5oCn6K6+572u5Y+Y5o2i5pa55rOVXG4gKlxuICogQGlubmVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlcnMgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgcHJvcDogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdjbGFzcyc6IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBwcm9wOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbG90OiB7XG4gICAgICAgIHByb3A6IGVtcHR5XG4gICAgfSxcblxuICAgIHJlYWRvbmx5OiBib29sUHJvcEhhbmRsZXIsXG4gICAgZGlzYWJsZWQ6IGJvb2xQcm9wSGFuZGxlcixcbiAgICBhdXRvZm9jdXM6IGJvb2xQcm9wSGFuZGxlcixcbiAgICByZXF1aXJlZDogYm9vbFByb3BIYW5kbGVyLFxuICAgIGRyYWdnYWJsZTogYm9vbFByb3BIYW5kbGVyXG59O1xuLyogZXNsaW50LWVuYWJsZSBmZWNzLXByb3BlcnRpZXMtcXVvdGUgKi9cblxudmFyIGFuYWxJbnB1dENoZWNrZXIgPSB7XG4gICAgY2hlY2tib3g6IGNvbnRhaW5zLFxuICAgIHJhZGlvOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhbmFsSW5wdXRDaGVja2VkU3RhdGUoZWxlbWVudCwgdmFsdWUsIG9wZXIpIHtcbiAgICB2YXIgYmluZFZhbHVlID0gZ2V0QU5vZGVQcm9wKGVsZW1lbnQuYU5vZGUsICd2YWx1ZScpO1xuICAgIHZhciBiaW5kVHlwZSA9IGdldEFOb2RlUHJvcChlbGVtZW50LmFOb2RlLCAndHlwZScpO1xuXG4gICAgaWYgKGJpbmRWYWx1ZSAmJiBiaW5kVHlwZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGV2YWxFeHByKGJpbmRUeXBlLmV4cHIsIGVsZW1lbnQuc2NvcGUsIGVsZW1lbnQub3duZXIpO1xuXG4gICAgICAgIGlmIChhbmFsSW5wdXRDaGVja2VyW3R5cGVdKSB7XG4gICAgICAgICAgICB2YXIgYmluZENoZWNrZWQgPSBnZXRBTm9kZVByb3AoZWxlbWVudC5hTm9kZSwgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgIGlmICghYmluZENoZWNrZWQuaGludEV4cHIpIHtcbiAgICAgICAgICAgICAgICBiaW5kQ2hlY2tlZC5oaW50RXhwciA9IGJpbmRWYWx1ZS5leHByO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gISFhbmFsSW5wdXRDaGVja2VyW3R5cGVdKFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGV2YWxFeHByKGJpbmRWYWx1ZS5leHByLCBlbGVtZW50LnNjb3BlLCBlbGVtZW50Lm93bmVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGVsZW1lbnRQcm9wSGFuZGxlcnMgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgICAgbXVsdGlwbGU6IGJvb2xQcm9wSGFuZGxlcixcbiAgICAgICAgY2hlY2tlZDoge1xuICAgICAgICAgICAgcHJvcDogZnVuY3Rpb24gKGVsLCB2YWx1ZSwgbmFtZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGFuYWxJbnB1dENoZWNrZWRTdGF0ZShlbGVtZW50LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBib29sUHJvcEhhbmRsZXIucHJvcChcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlICE9IG51bGwgPyBzdGF0ZSA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAnY2hlY2tlZCcsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb3V0cHV0OiBmdW5jdGlvbiAoZWxlbWVudCwgYmluZEluZm8sIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBlbGVtZW50LmVsO1xuICAgICAgICAgICAgICAgIHZhciBiaW5kVmFsdWUgPSBnZXRBTm9kZVByb3AoZWxlbWVudC5hTm9kZSwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRUeXBlID0gZ2V0QU5vZGVQcm9wKGVsZW1lbnQuYU5vZGUsICd0eXBlJykgfHwge307XG5cbiAgICAgICAgICAgICAgICBpZiAoYmluZFZhbHVlICYmIGJpbmRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmluZFR5cGUucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtlbC5jaGVja2VkID8gJ3B1c2gnIDogJ3JlbW92ZSddKGJpbmRJbmZvLmV4cHIsIGVsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5jaGVja2VkICYmIGRhdGEuc2V0KGJpbmRJbmZvLmV4cHIsIGVsLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGVsZW1lbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBiaW5kSW5mby5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0RWxlbWVudFByb3BIYW5kbGVyLm91dHB1dChlbGVtZW50LCBiaW5kSW5mbywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3B0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBwcm9wOiBmdW5jdGlvbiAoZWwsIHZhbHVlLCBuYW1lLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlci5wcm9wKGVsLCB2YWx1ZSwgbmFtZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25TZWxlY3RlZChlbGVtZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3Q6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHByb3A6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb3V0cHV0OiBkZWZhdWx0RWxlbWVudFByb3BIYW5kbGVyLm91dHB1dFxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gaXNPcHRpb25TZWxlY3RlZChlbGVtZW50LCB2YWx1ZSkge1xuICAgIHZhciBwYXJlbnRTZWxlY3QgPSBlbGVtZW50LnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50U2VsZWN0KSB7XG4gICAgICAgIGlmIChwYXJlbnRTZWxlY3QudGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50U2VsZWN0ID0gcGFyZW50U2VsZWN0LnBhcmVudDtcbiAgICB9XG5cblxuICAgIGlmIChwYXJlbnRTZWxlY3QpIHtcbiAgICAgICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGlmICgocHJvcCA9IGdldEFOb2RlUHJvcChwYXJlbnRTZWxlY3QuYU5vZGUsICd2YWx1ZScpKVxuICAgICAgICAgICAgJiYgKGV4cHIgPSBwcm9wLmV4cHIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgc2VsZWN0VmFsdWUgPSBwYXJlbnRTZWxlY3Qubm9kZVR5cGUgPT09IE5vZGVUeXBlLkNNUFRcbiAgICAgICAgICAgICAgICA/IGV2YWxFeHByKGV4cHIsIHBhcmVudFNlbGVjdC5kYXRhLCBwYXJlbnRTZWxlY3QpXG4gICAgICAgICAgICAgICAgOiBldmFsRXhwcihleHByLCBwYXJlbnRTZWxlY3Quc2NvcGUsIHBhcmVudFNlbGVjdC5vd25lcilcbiAgICAgICAgICAgICAgICB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICog6I635Y+W5bGe5oCn5aSE55CG5a+56LGhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUg5YWD57SgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUg5bGe5oCn5ZCNXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFByb3BIYW5kbGVyKHRhZ05hbWUsIGF0dHJOYW1lKSB7XG4gICAgaWYgKHN2Z1RhZ3NbdGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHN2Z1Byb3BIYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciB0YWdQcm9wSGFuZGxlcnMgPSBlbGVtZW50UHJvcEhhbmRsZXJzW3RhZ05hbWVdO1xuICAgIGlmICghdGFnUHJvcEhhbmRsZXJzKSB7XG4gICAgICAgIHRhZ1Byb3BIYW5kbGVycyA9IGVsZW1lbnRQcm9wSGFuZGxlcnNbdGFnTmFtZV0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcEhhbmRsZXIgPSB0YWdQcm9wSGFuZGxlcnNbYXR0ck5hbWVdO1xuICAgIGlmICghcHJvcEhhbmRsZXIpIHtcbiAgICAgICAgcHJvcEhhbmRsZXIgPSBkZWZhdWx0RWxlbWVudFByb3BIYW5kbGVyc1thdHRyTmFtZV0gfHwgZGVmYXVsdEVsZW1lbnRQcm9wSGFuZGxlcjtcbiAgICAgICAgdGFnUHJvcEhhbmRsZXJzW2F0dHJOYW1lXSA9IHByb3BIYW5kbGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wSGFuZGxlcjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0UHJvcEhhbmRsZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDliKTmlq3lj5jmm7TmmK/lkKbmnaXmupDkuo7lhYPntKBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5Yik5pat5Y+Y5pu05piv5ZCm5p2l5rqQ5LqO5YWD57Sg77yM5p2l5rqQ5LqO5YWD57Sg5pe277yM6KeG5Zu+5pu05paw6ZyA6KaB6Zi75patXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSDlj5jmm7Tlr7nosaFcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCDlhYPntKBcbiAqIEBwYXJhbSB7c3RyaW5nP30gcHJvcE5hbWUg5bGe5oCn5ZCN77yM5Y+v6YCJ44CC6ZyA6KaB57K+56Gu5Yik5pat5piv5ZCm5p2l5rqQ5LqO5q2k5bGe5oCn5pe25Lyg5YWlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RhdGFDaGFuZ2VCeUVsZW1lbnQoY2hhbmdlLCBlbGVtZW50LCBwcm9wTmFtZSkge1xuICAgIHZhciBjaGFuZ2VUYXJnZXQgPSBjaGFuZ2Uub3B0aW9uLnRhcmdldDtcbiAgICByZXR1cm4gY2hhbmdlVGFyZ2V0ICYmIGNoYW5nZVRhcmdldC5pZCA9PT0gZWxlbWVudC5pZFxuICAgICAgICAmJiAoIXByb3BOYW1lIHx8IGNoYW5nZVRhcmdldC5wcm9wID09PSBwcm9wTmFtZSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGlzRGF0YUNoYW5nZUJ5RWxlbWVudDtcblxuXG4vKipcbiAqIEBmaWxlIOWcqOWvueixoeS4iuS9v+eUqGFjY2Vzc29y6KGo6L6+5byP5p+l5om+5pa55rOVXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuXG4vKipcbiAqIOWcqOWvueixoeS4iuS9v+eUqGFjY2Vzc29y6KGo6L6+5byP5p+l5om+5pa55rOVXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSDmupDlr7nosaFcbiAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lRXhwciDooajovr7lvI9cbiAqIEBwYXJhbSB7RGF0YX0gZGF0YSDmiYDlsZ7mlbDmja7njq/looNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBmaW5kTWV0aG9kKHNvdXJjZSwgbmFtZUV4cHIsIGRhdGEpIHtcbiAgICB2YXIgbWV0aG9kID0gc291cmNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IG1ldGhvZCAhPSBudWxsICYmIGkgPCBuYW1lRXhwci5wYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZXRob2QgPSBtZXRob2RbZXZhbEV4cHIobmFtZUV4cHIucGF0aHNbaV0sIGRhdGEpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmaW5kTWV0aG9kO1xuXG5cbi8qKlxuICogQGZpbGUg5pWw5o2u57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuL2V2YWwtZXhwcicpO1xuLy8gdmFyIERhdGFDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi9kYXRhLWNoYW5nZS10eXBlJyk7XG4vLyB2YXIgY3JlYXRlQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWFjY2Vzc29yJyk7XG4vLyB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi4vcGFyc2VyL3BhcnNlLWV4cHInKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgZGF0YUNhY2hlID0gcmVxdWlyZSgnLi9kYXRhLWNhY2hlJyk7XG5cbi8qKlxuICog5pWw5o2u57G7XG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdD99IGRhdGEg5Yid5aeL5pWw5o2uXG4gKiBAcGFyYW0ge01vZGVsP30gcGFyZW50IOeItue6p+aVsOaNruWuueWZqFxuICovXG5mdW5jdGlvbiBEYXRhKGRhdGEsIHBhcmVudCkge1xuICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5yYXcgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG59XG5cbi8vICNbYmVnaW5dIGVycm9yXG4vLyDku6XkuIvkuKTkuKrlh73mlbDlj6rlnKjlvIDlj5HmqKHlvI/kuIvlj6/nlKjvvIzlnKjnlJ/kuqfmqKHlvI/kuIvkuI3lrZjlnKhcbi8qKlxuICogRGF0YVR5cGVzIOajgOa1i1xuICovXG5EYXRhLnByb3RvdHlwZS5jaGVja0RhdGFUeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50eXBlQ2hlY2tlcikge1xuICAgICAgICB0aGlzLnR5cGVDaGVja2VyKHRoaXMucmF3KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOiuvue9riB0eXBlIGNoZWNrZXJcbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gdHlwZUNoZWNrZXIg57G75Z6L5qCh6aqM5ZmoXG4gKi9cbkRhdGEucHJvdG90eXBlLnNldFR5cGVDaGVja2VyID0gZnVuY3Rpb24gKHR5cGVDaGVja2VyKSB7XG4gICAgdGhpcy50eXBlQ2hlY2tlciA9IHR5cGVDaGVja2VyO1xufTtcblxuLy8gI1tlbmRdXG5cbi8qKlxuICog5re75Yqg5pWw5o2u5Y+Y5pu055qE5LqL5Lu255uR5ZCs5ZmoXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5Ye95pWwXG4gKi9cbkRhdGEucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiDnp7vpmaTmlbDmja7lj5jmm7TnmoTkuovku7bnm5HlkKzlmahcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciDnm5HlkKzlh73mlbBcbiAqL1xuRGF0YS5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBpZiAoIWxpc3RlbmVyIHx8IHRoaXMubGlzdGVuZXJzW2xlbl0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UobGVuLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICog6Kem5Y+R5pWw5o2u5Y+Y5pu0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSDlj5jmm7Tkv6Hmga/lr7nosaFcbiAqL1xuRGF0YS5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLm9wdGlvbi5zaWxlbnQgfHwgY2hhbmdlLm9wdGlvbi5zaWxlbmNlIHx8IGNoYW5nZS5vcHRpb24ucXVpZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBjaGFuZ2UpO1xuICAgIH1cbn07XG5cbi8qKlxuICog6I635Y+W5pWw5o2u6aG5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0P30gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7RGF0YT99IGNhbGxlZSDlvZPliY3mlbDmja7ojrflj5bnmoTosIPnlKjnjq/looNcbiAqIEByZXR1cm4geyp9XG4gKi9cbkRhdGEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChleHByLCBjYWxsZWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnJhdztcbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGV4cHIgPSBwYXJzZUV4cHIoZXhwcik7XG5cbiAgICB2YXIgcGF0aHMgPSBleHByLnBhdGhzO1xuICAgIGNhbGxlZSA9IGNhbGxlZSB8fCB0aGlzO1xuXG4gICAgdmFsdWUgPSB2YWx1ZVtwYXRoc1swXS52YWx1ZV07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMucGFyZW50LmdldChleHByLCBjYWxsZWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwYXRocy5sZW5ndGg7IHZhbHVlICE9IG51bGwgJiYgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoc1tpXS52YWx1ZSB8fCBldmFsRXhwcihwYXRoc1tpXSwgY2FsbGVlKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICog5pWw5o2u5a+56LGh5Y+Y5pu05pON5L2cXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc291cmNlIOimgeWPmOabtOeahOa6kOaVsOaNrlxuICogQHBhcmFtIHtBcnJheX0gZXhwclBhdGhzIOWxnuaAp+i3r+W+hFxuICogQHBhcmFtIHsqfSB2YWx1ZSDlj5jmm7TlsZ7mgKflgLxcbiAqIEBwYXJhbSB7RGF0YX0gZGF0YSDlr7nlupTnmoREYXRh5a+56LGhXG4gKiBAcmV0dXJuIHsqfSDlj5jmm7TlkI7nmoTmlrDmlbDmja5cbiAqL1xuZnVuY3Rpb24gaW1tdXRhYmxlU2V0KHNvdXJjZSwgZXhwclBhdGhzLCB2YWx1ZSwgZGF0YSkge1xuICAgIGlmIChleHByUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IGV2YWxFeHByKGV4cHJQYXRoc1swXSwgZGF0YSk7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgaW5kZXggPSArcHJvcDtcblxuICAgICAgICByZXN1bHQgPSBzb3VyY2Uuc2xpY2UoMCk7XG4gICAgICAgIHJlc3VsdFtpc05hTihpbmRleCkgPyBwcm9wIDogaW5kZXhdID0gaW1tdXRhYmxlU2V0KHNvdXJjZVtpbmRleF0sIGV4cHJQYXRocy5zbGljZSgxKSwgdmFsdWUsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W3Byb3BdID0gaW1tdXRhYmxlU2V0KHNvdXJjZVtwcm9wXSB8fCB7fSwgZXhwclBhdGhzLnNsaWNlKDEpLCB2YWx1ZSwgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xufVxuXG4vKipcbiAqIOiuvue9ruaVsOaNrumhuVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg5pWw5o2u5YC8XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqL1xuRGF0YS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGV4cHIsIHZhbHVlLCBvcHRpb24pIHtcbiAgICBvcHRpb24gPSBvcHRpb24gfHwge307XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgIHZhciBleHByUmF3ID0gZXhwcjtcbiAgICAvLyAjW2VuZF1cblxuICAgIGV4cHIgPSBwYXJzZUV4cHIoZXhwcik7XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgIGlmIChleHByLnR5cGUgIT09IEV4cHJUeXBlLkFDQ0VTU09SKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gSW52YWxpZCBFeHByZXNzaW9uIGluIERhdGEgc2V0OiAnICsgZXhwclJhdyk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgaWYgKHRoaXMuZ2V0KGV4cHIpID09PSB2YWx1ZSAmJiAhb3B0aW9uLmZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnJhdyA9IGltbXV0YWJsZVNldCh0aGlzLnJhdywgZXhwci5wYXRocywgdmFsdWUsIHRoaXMpO1xuICAgIHRoaXMuZmlyZSh7XG4gICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBvcHRpb246IG9wdGlvblxuICAgIH0pO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICB0aGlzLmNoZWNrRGF0YVR5cGVzKCk7XG4gICAgLy8gI1tlbmRdXG5cbn07XG5cbi8qKlxuICog5ZCI5bm25pu05paw5pWw5o2u6aG5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSDlvoXlkIjlubbnmoTmlbDmja7lgLxcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uIOiuvue9ruWPguaVsFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb24uc2lsZW50IOmdmem7mOiuvue9ru+8jOS4jeinpuWPkeWPmOabtOS6i+S7tlxuICovXG5EYXRhLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChleHByLCBzb3VyY2UsIG9wdGlvbikge1xuICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgdmFyIGV4cHJSYXcgPSBleHByO1xuICAgIC8vICNbZW5kXVxuXG4gICAgZXhwciA9IHBhcnNlRXhwcihleHByKTtcblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgaWYgKGV4cHIudHlwZSAhPT0gRXhwclR5cGUuQUNDRVNTT1IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIEVSUk9SXSBJbnZhbGlkIEV4cHJlc3Npb24gaW4gRGF0YSBtZXJnZTogJyArIGV4cHJSYXcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5nZXQoZXhwcikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gTWVyZ2UgRXhwZWN0cyBhIFRhcmdldCBvZiBUeXBlIFxcJ29iamVjdFxcJzsgZ290ICcgKyB0eXBlb2Ygb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIE1lcmdlIEV4cGVjdHMgYSBTb3VyY2Ugb2YgVHlwZSBcXCdvYmplY3RcXCc7IGdvdCAnICsgdHlwZW9mIHNvdXJjZSk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHRoaXMuc2V0KFxuICAgICAgICAgICAgY3JlYXRlQWNjZXNzb3IoXG4gICAgICAgICAgICAgICAgZXhwci5wYXRocy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgb3B0aW9uXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDln7rkuo7mm7TmlrDlh73mlbDmm7TmlrDmlbDmja7poblcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiDmlbDmja7lpITnkIblh73mlbBcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uIOiuvue9ruWPguaVsFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb24uc2lsZW50IOmdmem7mOiuvue9ru+8jOS4jeinpuWPkeWPmOabtOS6i+S7tlxuICovXG5EYXRhLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChleHByLCBmbiwgb3B0aW9uKSB7XG4gICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICB2YXIgZXhwclJhdyA9IGV4cHI7XG4gICAgLy8gI1tlbmRdXG5cbiAgICBleHByID0gcGFyc2VFeHByKGV4cHIpO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICBpZiAoZXhwci50eXBlICE9PSBFeHByVHlwZS5BQ0NFU1NPUikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIEludmFsaWQgRXhwcmVzc2lvbiBpbiBEYXRhIGFwcGx5OiAnICsgZXhwclJhdyk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXQoZXhwcik7XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1tTQU4gRVJST1JdIEludmFsaWQgQXJndW1lbnRcXCdzIFR5cGUgaW4gRGF0YSBhcHBseTogJ1xuICAgICAgICAgICAgKyAnRXhwZWN0ZWQgRnVuY3Rpb24gYnV0IGdvdCAnICsgdHlwZW9mIGZuXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgdGhpcy5zZXQoZXhwciwgZm4ob2xkVmFsdWUpLCBvcHRpb24pO1xufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7poblzcGxpY2Xmk43kvZxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHNwbGljZSDmjqXlj5fnmoTlj4LmlbDliJfooajvvIzmlbDnu4TpobnkuI5BcnJheS5wcm90b3R5cGUuc3BsaWNl55qE5Y+C5pWw5LiA6Ie0XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqIEByZXR1cm4ge0FycmF5fSDmlrDmlbDnu4RcbiAqL1xuRGF0YS5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKGV4cHIsIGFyZ3MsIG9wdGlvbikge1xuICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgIHZhciBleHByUmF3ID0gZXhwcjtcbiAgICAvLyAjW2VuZF1cblxuICAgIGV4cHIgPSBwYXJzZUV4cHIoZXhwcik7XG5cbiAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgIGlmIChleHByLnR5cGUgIT09IEV4cHJUeXBlLkFDQ0VTU09SKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBFUlJPUl0gSW52YWxpZCBFeHByZXNzaW9uIGluIERhdGEgc3BsaWNlOiAnICsgZXhwclJhdyk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0KGV4cHIpO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IFtdO1xuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3QXJyYXkgPSB0YXJnZXQuc2xpY2UoMCk7XG4gICAgICAgIHJldHVyblZhbHVlID0gbmV3QXJyYXkuc3BsaWNlLmFwcGx5KG5ld0FycmF5LCBhcmdzKTtcbiAgICAgICAgZGF0YUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmF3ID0gaW1tdXRhYmxlU2V0KHRoaXMucmF3LCBleHByLnBhdGhzLCBuZXdBcnJheSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgIGV4cHI6IGV4cHIsXG4gICAgICAgICAgICB0eXBlOiBEYXRhQ2hhbmdlVHlwZS5TUExJQ0UsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBkZWxldGVDb3VudDogcmV0dXJuVmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWU6IHJldHVyblZhbHVlLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYXJncy5zbGljZSgyKSxcbiAgICAgICAgICAgIG9wdGlvbjogb3B0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgdGhpcy5jaGVja0RhdGFUeXBlcygpO1xuICAgIC8vICNbZW5kXVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7poblwdXNo5pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHsqfSBpdGVtIOimgXB1c2jnmoTlgLxcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uIOiuvue9ruWPguaVsFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb24uc2lsZW50IOmdmem7mOiuvue9ru+8jOS4jeinpuWPkeWPmOabtOS6i+S7tlxuICogQHJldHVybiB7bnVtYmVyfSDmlrDmlbDnu4TnmoRsZW5ndGjlsZ7mgKdcbiAqL1xuRGF0YS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChleHByLCBpdGVtLCBvcHRpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXQoZXhwcik7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoZXhwciwgW3RhcmdldC5sZW5ndGgsIDAsIGl0ZW1dLCBvcHRpb24pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCArIDE7XG4gICAgfVxufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7poblwb3Dmk43kvZxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqIEByZXR1cm4geyp9XG4gKi9cbkRhdGEucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChleHByLCBvcHRpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXQoZXhwcik7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShleHByLCBbbGVuIC0gMSwgMV0sIG9wdGlvbilbMF07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIOaVsOe7hOaVsOaNrumhuXNoaWZ05pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb24g6K6+572u5Y+C5pWwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbi5zaWxlbnQg6Z2Z6buY6K6+572u77yM5LiN6Kem5Y+R5Y+Y5pu05LqL5Lu2XG4gKiBAcmV0dXJuIHsqfVxuICovXG5EYXRhLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIChleHByLCBvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoZXhwciwgWzAsIDFdLCBvcHRpb24pWzBdO1xufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7pobl1bnNoaWZ05pON5L2cXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBleHByIOaVsOaNrumhuei3r+W+hFxuICogQHBhcmFtIHsqfSBpdGVtIOimgXVuc2hpZnTnmoTlgLxcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uIOiuvue9ruWPguaVsFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb24uc2lsZW50IOmdmem7mOiuvue9ru+8jOS4jeinpuWPkeWPmOabtOS6i+S7tlxuICogQHJldHVybiB7bnVtYmVyfSDmlrDmlbDnu4TnmoRsZW5ndGjlsZ7mgKdcbiAqL1xuRGF0YS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChleHByLCBpdGVtLCBvcHRpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXQoZXhwcik7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoZXhwciwgWzAsIDAsIGl0ZW1dLCBvcHRpb24pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCArIDE7XG4gICAgfVxufTtcblxuLyoqXG4gKiDmlbDnu4TmlbDmja7pobnnp7vpmaTmk43kvZxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV4cHIg5pWw5o2u6aG56Lev5b6EXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg6KaB56e76Zmk6aG555qE57Si5byVXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqL1xuRGF0YS5wcm90b3R5cGUucmVtb3ZlQXQgPSBmdW5jdGlvbiAoZXhwciwgaW5kZXgsIG9wdGlvbikge1xuICAgIHRoaXMuc3BsaWNlKGV4cHIsIFtpbmRleCwgMV0sIG9wdGlvbik7XG59O1xuXG4vKipcbiAqIOaVsOe7hOaVsOaNrumhueenu+mZpOaTjeS9nFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXhwciDmlbDmja7pobnot6/lvoRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg6KaB56e76Zmk55qE6aG5XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbiDorr7nva7lj4LmlbBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uLnNpbGVudCDpnZnpu5jorr7nva7vvIzkuI3op6blj5Hlj5jmm7Tkuovku7ZcbiAqL1xuRGF0YS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGV4cHIsIHZhbHVlLCBvcHRpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXQoZXhwcik7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFtsZW5dID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlKGV4cHIsIFtsZW4sIDFdLCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGF0YTtcblxuXG4vKipcbiAqIEBmaWxlIOWjsOaYjuW8j+S6i+S7tueahOebkeWQrOWHveaVsFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgZXZhbEFyZ3MgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtYXJncycpO1xuLy8gdmFyIGZpbmRNZXRob2QgPSByZXF1aXJlKCcuLi9ydW50aW1lL2ZpbmQtbWV0aG9kJyk7XG4vLyB2YXIgRGF0YSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZGF0YScpO1xuXG4vKipcbiAqIOWjsOaYjuW8j+S6i+S7tueahOebkeWQrOWHveaVsFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEJpbmQg57uR5a6a5L+h5oGv5a+56LGhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29tcG9uZW50RXZlbnQg5piv5ZCm57uE5Lu26Ieq5a6a5LmJ5LqL5Lu2XG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge0V2ZW50fSBlIOS6i+S7tuWvueixoVxuICovXG5mdW5jdGlvbiBldmVudERlY2xhcmF0aW9uTGlzdGVuZXIoZXZlbnRCaW5kLCBpc0NvbXBvbmVudEV2ZW50LCBkYXRhLCBlKSB7XG4gICAgdmFyIG1ldGhvZCA9IGZpbmRNZXRob2QodGhpcywgZXZlbnRCaW5kLmV4cHIubmFtZSwgZGF0YSk7XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgc2NvcGUgPSBuZXcgRGF0YShcbiAgICAgICAgICAgIHskZXZlbnQ6IGlzQ29tcG9uZW50RXZlbnQgPyBlIDogZSB8fCB3aW5kb3cuZXZlbnR9LFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICApO1xuICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgZXZhbEFyZ3MoZXZlbnRCaW5kLmV4cHIuYXJncywgc2NvcGUsIHRoaXMpKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGV2ZW50RGVjbGFyYXRpb25MaXN0ZW5lcjtcblxuXG4vKipcbiAqIEBmaWxlIOiHqumXreWQiOagh+etvuihqFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHNwbGl0U3RyMk9iaiA9IHJlcXVpcmUoJy4uL3V0aWwvc3BsaXQtc3RyLTItb2JqJyk7XG5cbi8qKlxuICog6Ieq6Zet5ZCI5qCH562+5YiX6KGoXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGhvdFRhZ3MgPSBzcGxpdFN0cjJPYmooJ2RpdixzcGFuLGlucHV0LGJ1dHRvbix0ZXh0YXJlYSxmb3JtLGxhYmVsLGRsLGR0LGRkLHVsLG9sLGxpLGEsYix1LGgxLGgyLGgzLGg0LGg1LGg2Jyk7XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGhvdFRhZ3M7XG5cblxuLyoqXG4gKiBAZmlsZSDmmK/lkKbmtY/op4jlmajnjq/looNcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaXNCcm93c2VyO1xuXG5cbi8qKlxuICogQGZpbGUgaW5zZXJ0QmVmb3JlIOaWueazleeahOWFvOWuueaAp+WwgeijhVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBpbnNlcnRCZWZvcmUg5pa55rOV55qE5YW85a655oCn5bCB6KOFXG4gKlxuICogQHBhcmFtIHtIVE1MTm9kZX0gdGFyZ2V0RWwg6KaB5o+S5YWl55qE6IqC54K5XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDniLblhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQ/fSBiZWZvcmVFbCDlnKjmraTlhYPntKDkuYvliY3mj5LlhaVcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHRhcmdldEVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICBpZiAocGFyZW50RWwpIHtcbiAgICAgICAgaWYgKGJlZm9yZUVsKSB7XG4gICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUodGFyZ2V0RWwsIGJlZm9yZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRhcmdldEVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QmVmb3JlO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5YWD57Sg5piv5ZCm5LiN5YWB6K646K6+572uSFRNTFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gc29tZSBodG1sIGVsZW1lbnRzIGNhbm5vdCBzZXQgaW5uZXJIVE1MIGluIG9sZCBpZVxuLy8gc2VlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMzODk3KFZTLjg1KS5hc3B4XG5cbi8qKlxuICog5Yik5pat5YWD57Sg5piv5ZCm5LiN5YWB6K646K6+572uSFRNTFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIOimgeWIpOaWreeahOWFg+e0oFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbm9TZXRIVE1MKGVsKSB7XG4gICAgcmV0dXJuIC9eKGNvbHxjb2xncm91cHxmcmFtZXNldHxzdHlsZXx0YWJsZXx0Ym9keXx0Zm9vdHx0aGVhZHx0cnxzZWxlY3QpJC9pLnRlc3QoZWwudGFnTmFtZSk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5vU2V0SFRNTDtcblxuXG4vKipcbiAqIEBmaWxlICDojrflj5boioLngrkgc3R1bXAg55qEIGNvbW1lbnRcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBub1NldEhUTUwgPSByZXF1aXJlKCcuLi9icm93c2VyL25vLXNldC1odG1sJyk7XG5cbi8vICNbYmVnaW5dIGVycm9yXG4vKipcbiAqIOiOt+WPluiKgueCuSBzdHVtcCDnmoQgY29tbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEhUTUzlhYPntKBcbiAqL1xuZnVuY3Rpb24gd2FyblNldEhUTUwoZWwpIHtcbiAgICAvLyBkb250IHdhcm4gaWYgbm90IGluIGJyb3dzZXIgcnVudGltZVxuICAgIGlmICghKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNvbWUgaHRtbCBlbGVtZW50cyBjYW5ub3Qgc2V0IGlubmVySFRNTCBpbiBvbGQgaWVcbiAgICAvLyBzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzM4OTcoVlMuODUpLmFzcHhcbiAgICBpZiAobm9TZXRIVE1MKGVsKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdbU0FOIFdBUk5JTkddIHNldCBodG1sIGZvciBlbGVtZW50IFwiJyArIGVsLnRhZ05hbWVcbiAgICAgICAgICAgICsgJ1wiIG1heSBjYXVzZSBhbiBlcnJvciBpbiBvbGQgSUUnO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxufVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdhcm5TZXRIVE1MO1xuXG5cbi8qKlxuICogQGZpbGUg5Yik5pat5piv5ZCm57uT5p2f5qGpXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOWIpOaWreaYr+WQpue7k+adn+ahqVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTENvbW1lbnR9IHRhcmdldCDopoHliKTmlq3nmoTlhYPntKBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOahqeexu+Wei1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbmRTdHVtcCh0YXJnZXQsIHR5cGUpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSA4ICYmIHRhcmdldC5kYXRhID09PSAnL3MtJyArIHR5cGU7XG59XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaXNFbmRTdHVtcDtcblxuXG4vKipcbiAqIEBmaWxlIOiOt+WPluiKgueCueWcqOe7hOS7tuagkeS4reeahOi3r+W+hFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgTm9kZVR5cGUgPSByZXF1aXJlKCcuL25vZGUtdHlwZScpO1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOiOt+WPluiKgueCueWcqOe7hOS7tuagkeS4reeahOi3r+W+hFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSDoioLngrnlr7nosaFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXROb2RlUGF0aChub2RlKSB7XG4gICAgdmFyIG5vZGVQYXRocyA9IFtdO1xuICAgIHZhciBub2RlUGFyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAobm9kZVBhcmVudCkge1xuICAgICAgICBzd2l0Y2ggKG5vZGVQYXJlbnQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuRUxFTTpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdChub2RlUGFyZW50LnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLklGOlxuICAgICAgICAgICAgICAgIG5vZGVQYXRocy51bnNoaWZ0KCdpZicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkZPUjpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnZm9yWycgKyBub2RlUGFyZW50LmFub2RlLmRpcmVjdGl2ZXNbJ2ZvciddLnJhdyArICddJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuU0xPVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnc2xvdFsnICsgKG5vZGVQYXJlbnQubmFtZSB8fCAnZGVmYXVsdCcpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5UUEw6XG4gICAgICAgICAgICAgICAgbm9kZVBhdGhzLnVuc2hpZnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuQ01QVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgnY29tcG9uZW50WycgKyAobm9kZVBhcmVudC5zdWJUYWcgfHwgJ3Jvb3QnKSArICddJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuVEVYVDpcbiAgICAgICAgICAgICAgICBub2RlUGF0aHMudW5zaGlmdCgndGV4dCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVBhcmVudCA9IG5vZGVQYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBub2RlUGF0aHM7XG59XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZVBhdGg7XG5cblxuLyoqXG4gKiBAZmlsZSB0ZXh0IOiKgueCueexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGlzQnJvd3NlciA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaXMtYnJvd3NlcicpO1xuLy8gdmFyIHJlbW92ZUVsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9yZW1vdmUtZWwnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBjaGFuZ2VFeHByQ29tcGFyZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgd2FyblNldEhUTUwgPSByZXF1aXJlKCcuL3dhcm4tc2V0LWh0bWwnKTtcbi8vIHZhciBpc0VuZFN0dW1wID0gcmVxdWlyZSgnLi9pcy1lbmQtc3R1bXAnKTtcbi8vIHZhciBnZXROb2RlUGF0aCA9IHJlcXVpcmUoJy4vZ2V0LW5vZGUtcGF0aCcpO1xuXG5cbi8qKlxuICogdGV4dCDoioLngrnnsbtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu2546v5aKDXG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXI/fSByZXZlcnNlV2Fsa2VyIOWtkOWFg+e0oOmBjeWOhuWvueixoVxuICovXG5mdW5jdGlvbiBUZXh0Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Tm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmRhdGEgPT09ICdzLXRleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuZGF0YSA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gVGV4dCBlbmQgZmxhZyBub3QgZm91bmQuIFxcblBhdGhzOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGdldE5vZGVQYXRoKHRoaXMpLmpvaW4oJyA+ICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbmRTdHVtcChjdXJyZW50Tm9kZSwgJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VXYWxrZXIuZ29OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmRhdGEgPSB0aGlzLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLmdvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblRleHROb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLlRFWFQ7XG5cbi8qKlxuICog5bCGdGV4dCBhdHRhY2jliLDpobXpnaJcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDopoHmt7vliqDliLDnmoTniLblhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnTvvJ19IGJlZm9yZUVsIOimgea3u+WKoOWIsOWTquS4quWFg+e0oOS5i+WJjVxuICovXG5UZXh0Tm9kZS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBhcmVudEVsLCBiZWZvcmVFbCkge1xuICAgIHRoaXMuY29udGVudCA9IGV2YWxFeHByKHRoaXMuYU5vZGUudGV4dEV4cHIsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpO1xuXG4gICAgaWYgKHRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgdGhpcy5zZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5zZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy5pZCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuXG4gICAgICAgIHZhciB0ZW1wRmxhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUodGVtcEZsYWcsIHRoaXMuZWwpO1xuICAgICAgICB0ZW1wRmxhZy5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgdGhpcy5jb250ZW50KTtcbiAgICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEZsYWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmVsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICog6ZSA5q+BIHRleHQg6IqC54K5XG4gKi9cblRleHROb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIHRoaXMuc2VsID0gbnVsbDtcbn07XG5cbnZhciB0ZXh0VXBkYXRlUHJvcCA9IGlzQnJvd3NlclxuICAgICYmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLnRleHRDb250ZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/ICd0ZXh0Q29udGVudCdcbiAgICAgICAgOiAnZGF0YScpO1xuXG4vKipcbiAqIOabtOaWsCB0ZXh0IOiKgueCueeahOinhuWbvlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKi9cblRleHROb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAodGhpcy5hTm9kZS50ZXh0RXhwci52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGNoYW5nZXMgPyBjaGFuZ2VzLmxlbmd0aCA6IDA7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmIChjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VzW2xlbl0uZXhwciwgdGhpcy5hTm9kZS50ZXh0RXhwciwgdGhpcy5zY29wZSkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZXZhbEV4cHIodGhpcy5hTm9kZS50ZXh0RXhwciwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0ZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVtb3ZlRWwgPSB0aGlzLnNlbC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydFJlbW92ZUVsICE9PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlVGFyZ2V0ID0gc3RhcnRSZW1vdmVFbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVtb3ZlRWwgPSBzdGFydFJlbW92ZUVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWwocmVtb3ZlVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHdhcm5TZXRIVE1MKHBhcmVudEVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBGbGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZSh0ZW1wRmxhZywgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBGbGFnLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEZsYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbFt0ZXh0VXBkYXRlUHJvcF0gPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVGV4dE5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDliKTmlq3lj5jmm7TmlbDnu4TmmK/lkKblvbHlk43liLDmlbDmja7lvJXnlKjmkZjopoFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDliKTmlq3lj5jmm7TmlbDnu4TmmK/lkKblvbHlk43liLDmlbDmja7lvJXnlKjmkZjopoFcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOWPmOabtOaVsOe7hFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFSZWYg5pWw5o2u5byV55So5pGY6KaBXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjaGFuZ2VzSXNJbkRhdGFSZWYoY2hhbmdlcywgZGF0YVJlZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgICAgICBpZiAoIWNoYW5nZS5vdmVydmlldykge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gY2hhbmdlLmV4cHIucGF0aHM7XG4gICAgICAgICAgICBjaGFuZ2Uub3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuZXh0T3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZSArICcuJyArIHBhdGhzWzFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNoYW5nZS53aWxkT3ZlcnZpZXcgPSBwYXRoc1swXS52YWx1ZSArICcuKic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVJlZltjaGFuZ2Uub3ZlcnZpZXddXG4gICAgICAgICAgICB8fCBjaGFuZ2Uud2lsZE92ZXJ2aWV3ICYmIGRhdGFSZWZbY2hhbmdlLndpbGRPdmVydmlld11cbiAgICAgICAgICAgIHx8IGNoYW5nZS5leHRPdmVydmlldyAmJiBkYXRhUmVmW2NoYW5nZS5leHRPdmVydmlld11cbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY2hhbmdlc0lzSW5EYXRhUmVmO1xuXG5cbi8qKlxuICogQGZpbGUg5YWD57Sg5a2Q6IqC54K56YGN5Y6G5pON5L2c57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgcmVtb3ZlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG4vKipcbiAqIOWFg+e0oOWtkOiKgueCuemBjeWOhuaTjeS9nOexu1xuICpcbiAqIEBpbm5lclxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCDopoHpgY3ljobnmoTlhYPntKBcbiAqL1xuZnVuY3Rpb24gRE9NQ2hpbGRyZW5XYWxrZXIoZWwpIHtcbiAgICB0aGlzLnJhdyA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMudGFyZ2V0ID0gZWw7XG5cbiAgICB2YXIgY2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgIHZhciBuZXh0O1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgc3dpdGNoIChjaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICgvXlxccyokLy50ZXN0KGNoaWxkLmRhdGEgfHwgY2hpbGQudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmF3LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMucmF3LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucmF3W3RoaXMuaW5kZXhdO1xuICAgIHRoaXMubmV4dCA9IHRoaXMucmF3W3RoaXMuaW5kZXggKyAxXTtcbn1cblxuLyoqXG4gKiDlvoDkuIvotbDkuIDkuKrlhYPntKBcbiAqL1xuRE9NQ2hpbGRyZW5XYWxrZXIucHJvdG90eXBlLmdvTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJhd1srK3RoaXMuaW5kZXhdO1xuICAgIHRoaXMubmV4dCA9IHRoaXMucmF3W3RoaXMuaW5kZXggKyAxXTtcbn07XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5XYWxrZXI7XG5cblxuLyoqXG4gKiBAZmlsZSDlhYPntKDoioLngrnnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgcmVtb3ZlRWwgPSByZXF1aXJlKCcuLi9icm93c2VyL3JlbW92ZS1lbCcpO1xuLy8gdmFyIGNoYW5nZUV4cHJDb21wYXJlID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2UtZXhwci1jb21wYXJlJyk7XG4vLyB2YXIgY2hhbmdlc0lzSW5EYXRhUmVmID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2VzLWlzLWluLWRhdGEtcmVmJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcbi8vIHZhciByZXZlcnNlRWxlbWVudENoaWxkcmVuID0gcmVxdWlyZSgnLi9yZXZlcnNlLWVsZW1lbnQtY2hpbGRyZW4nKTtcbi8vIHZhciBpc0RhdGFDaGFuZ2VCeUVsZW1lbnQgPSByZXF1aXJlKCcuL2lzLWRhdGEtY2hhbmdlLWJ5LWVsZW1lbnQnKTtcbi8vIHZhciBlbGVtZW50VXBkYXRlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtdXBkYXRlLWNoaWxkcmVuJyk7XG4vLyB2YXIgZWxlbWVudE93bkNyZWF0ZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tY3JlYXRlJyk7XG4vLyB2YXIgZWxlbWVudE93bkF0dGFjaCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tYXR0YWNoJyk7XG4vLyB2YXIgZWxlbWVudE93bkRldGFjaCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tZGV0YWNoJyk7XG4vLyB2YXIgZWxlbWVudE93bkRpc3Bvc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWRpc3Bvc2UnKTtcbi8vIHZhciBlbGVtZW50T3duT25FbCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tb24tZWwnKTtcbi8vIHZhciBlbGVtZW50T3duVG9QaGFzZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tdG8tcGhhc2UnKTtcbi8vIHZhciBlbGVtZW50T3duQXR0YWNoZWQgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWF0dGFjaGVkJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZScpO1xuLy8gdmFyIGVsZW1lbnRJbml0VGFnTmFtZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1pbml0LXRhZy1uYW1lJyk7XG4vLyB2YXIgaGFuZGxlUHJvcCA9IHJlcXVpcmUoJy4vaGFuZGxlLXByb3AnKTtcbi8vIHZhciB3YXJuU2V0SFRNTCA9IHJlcXVpcmUoJy4vd2Fybi1zZXQtaHRtbCcpO1xuLy8gdmFyIGdldE5vZGVQYXRoID0gcmVxdWlyZSgnLi9nZXQtbm9kZS1wYXRoJyk7XG5cbi8qKlxuICog5YWD57Sg6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gRWxlbWVudChhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB0aGlzLmFOb2RlID0gYU5vZGU7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLnN0YXJ0O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9lbEZucyA9IFtdO1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG5cbiAgICBlbGVtZW50SW5pdFRhZ05hbWUodGhpcyk7XG5cbiAgICB0aGlzLl90b1BoYXNlKCdpbml0ZWQnKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSByZXZlcnNlV2Fsa2VyLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU0FOIFJFVkVSU0UgRVJST1JdIEVsZW1lbnQgbm90IGZvdW5kLiBcXG5QYXRoczogJ1xuICAgICAgICAgICAgICAgICsgZ2V0Tm9kZVBhdGgodGhpcykuam9pbignID4gJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gRWxlbWVudCB0eXBlIG5vdCBtYXRjaCwgZXhwZWN0IDEgYnV0ICdcbiAgICAgICAgICAgICAgICArIGN1cnJlbnROb2RlLm5vZGVUeXBlICsgJy5cXG5QYXRoczogJ1xuICAgICAgICAgICAgICAgICsgZ2V0Tm9kZVBhdGgodGhpcykuam9pbignID4gJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy50YWdOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gUkVWRVJTRSBFUlJPUl0gRWxlbWVudCB0YWdOYW1lIG5vdCBtYXRjaCwgZXhwZWN0ICdcbiAgICAgICAgICAgICAgICArIHRoaXMudGFnTmFtZSArICcgYnV0IG1lYXQgJyArIGN1cnJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICcuXFxuUGF0aHM6ICdcbiAgICAgICAgICAgICAgICArIGdldE5vZGVQYXRoKHRoaXMpLmpvaW4oJyA+ICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgcmV2ZXJzZVdhbGtlci5nb05leHQoKTtcblxuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkKCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cblxuRWxlbWVudC5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5FTEVNO1xuXG5cbkVsZW1lbnQucHJvdG90eXBlLmF0dGFjaCA9IGVsZW1lbnRPd25BdHRhY2g7XG5FbGVtZW50LnByb3RvdHlwZS5kZXRhY2ggPSBlbGVtZW50T3duRGV0YWNoO1xuRWxlbWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGVsZW1lbnRPd25EaXNwb3NlO1xuRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZSA9IGVsZW1lbnRPd25DcmVhdGU7XG5FbGVtZW50LnByb3RvdHlwZS5fdG9QaGFzZSA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuRWxlbWVudC5wcm90b3R5cGUuX29uRWwgPSBlbGVtZW50T3duT25FbDtcblxuRWxlbWVudC5wcm90b3R5cGUuX2RvbmVMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZWF2ZURpc3Bvc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpZmVDeWNsZS5kaXNwb3NlZCkge1xuICAgICAgICAgICAgZWxlbWVudERpc3Bvc2UoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOb0RldGFjaCxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOb1RyYW5zaXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5saWZlQ3ljbGUuYXR0YWNoZWQpIHtcbiAgICAgICAgcmVtb3ZlRWwodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2RldGFjaGVkJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDop4blm77mm7TmlrBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5FbGVtZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAoIWNoYW5nZXNJc0luRGF0YVJlZihjaGFuZ2VzLCB0aGlzLmFOb2RlLmhvdHNwb3QuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICB2YXIgZHluYW1pY1Byb3BzID0gdGhpcy5hTm9kZS5ob3RzcG90LmR5bmFtaWNQcm9wcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBkeW5hbWljUHJvcHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGNoYW5nZUxlbiA9IGNoYW5nZXMubGVuZ3RoOyBqIDwgY2hhbmdlTGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGF0YUNoYW5nZUJ5RWxlbWVudChjaGFuZ2UsIHRoaXMsIHByb3AubmFtZSlcbiAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZS5leHByLCBwcm9wLmV4cHIsIHRoaXMuc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IHByb3AuaGludEV4cHIgJiYgY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIHByb3AuaGludEV4cHIsIHRoaXMuc2NvcGUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUHJvcCh0aGlzLCBldmFsRXhwcihwcm9wLmV4cHIsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBodG1sRGlyZWN0aXZlID0gdGhpcy5hTm9kZS5kaXJlY3RpdmVzLmh0bWw7XG4gICAgaWYgKGh0bWxEaXJlY3RpdmUpIHtcbiAgICAgICAgZWFjaChjaGFuZ2VzLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIGh0bWxEaXJlY3RpdmUudmFsdWUsIG1lLnNjb3BlKSkge1xuICAgICAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgICAgICAgICAgICAgd2FyblNldEhUTUwobWUuZWwpO1xuICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuICAgICAgICAgICAgICAgIG1lLmVsLmlubmVySFRNTCA9IGV2YWxFeHByKGh0bWxEaXJlY3RpdmUudmFsdWUsIG1lLnNjb3BlLCBtZS5vd25lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbih0aGlzLCBjaGFuZ2VzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOaJp+ihjOWujOaIkGF0dGFjaGVk54q25oCB55qE6KGM5Li6XG4gKi9cbkVsZW1lbnQucHJvdG90eXBlLl9hdHRhY2hlZCA9IGVsZW1lbnRPd25BdHRhY2hlZDtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG4vKipcbiAqIEBmaWxlIOmUgOavgeiKgueCue+8jOa4heepuuiKgueCueS4iueahOaXoOeUqOaIkOWRmFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vKipcbiAqIOmUgOavgeiKgueCuVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOiKgueCueWvueixoVxuICovXG5mdW5jdGlvbiBub2RlRGlzcG9zZShub2RlKSB7XG4gICAgbm9kZS5lbCA9IG51bGw7XG4gICAgbm9kZS5zZWwgPSBudWxsO1xuICAgIG5vZGUub3duZXIgPSBudWxsO1xuICAgIG5vZGUuc2NvcGUgPSBudWxsO1xuICAgIG5vZGUuYU5vZGUgPSBudWxsO1xuICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICBub2RlLnBhcmVudENvbXBvbmVudCA9IG51bGw7XG4gICAgbm9kZS5jaGlsZHJlbiA9IG51bGw7XG5cbiAgICBpZiAobm9kZS5fdG9QaGFzZSkge1xuICAgICAgICBub2RlLl90b1BoYXNlKCdkaXNwb3NlZCcpO1xuICAgIH1cblxuICAgIGlmIChub2RlLl9vbmRpc3Bvc2VkKSB7XG4gICAgICAgIG5vZGUuX29uZGlzcG9zZWQoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5vZGVEaXNwb3NlO1xuXG5cbi8qKlxuICogQGZpbGUg6YCa6L+H57uE5Lu25Y+N6Kej5Yib5bu66IqC54K555qE5bel5Y6C5pa55rOVXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgaG90VGFncyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaG90LXRhZ3MnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgVGV4dE5vZGUgPSByZXF1aXJlKCcuL3RleHQtbm9kZScpO1xuLy8gdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbi8vIHZhciBTbG90Tm9kZSA9IHJlcXVpcmUoJy4vc2xvdC1ub2RlJyk7XG4vLyB2YXIgRm9yTm9kZSA9IHJlcXVpcmUoJy4vZm9yLW5vZGUnKTtcbi8vIHZhciBJZk5vZGUgPSByZXF1aXJlKCcuL2lmLW5vZGUnKTtcbi8vIHZhciBUZW1wbGF0ZU5vZGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlLW5vZGUnKTtcblxuLy8gI1tiZWdpbl0gcmV2ZXJzZVxuLyoqXG4gKiDpgJrov4fnu4Tku7blj43op6PliJvlu7roioLngrlcbiAqXG4gKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDmir3osaHoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXJ9IHJldmVyc2VXYWxrZXIg5a2Q5YWD57Sg6YGN5Y6G5a+56LGhXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7TW9kZWw9fSBzY29wZSDmiYDlsZ7mlbDmja7njq/looNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlLCByZXZlcnNlV2Fsa2VyLCBwYXJlbnQsIHNjb3BlKSB7XG4gICAgdmFyIHBhcmVudElzQ29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUO1xuICAgIHZhciBvd25lciA9IHBhcmVudElzQ29tcG9uZW50ID8gcGFyZW50IDogKHBhcmVudC5jaGlsZE93bmVyIHx8IHBhcmVudC5vd25lcik7XG4gICAgc2NvcGUgPSBzY29wZSB8fCAocGFyZW50SXNDb21wb25lbnQgPyBwYXJlbnQuZGF0YSA6IChwYXJlbnQuY2hpbGRTY29wZSB8fCBwYXJlbnQuc2NvcGUpKTtcblxuICAgIGlmIChhTm9kZS50ZXh0RXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG4gICAgfVxuXG4gICAgaWYgKGFOb2RlLmRpcmVjdGl2ZXNbJ2lmJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBJZk5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50LCByZXZlcnNlV2Fsa2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYU5vZGUuZGlyZWN0aXZlc1snZm9yJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG4gICAgfVxuXG4gICAgaWYgKGhvdFRhZ3NbYU5vZGUudGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChhTm9kZS50YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3QnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbG90Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpO1xuXG4gICAgICAgIGNhc2UgJ3RlbXBsYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcik7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBDb21wb25lbnRUeXBlID0gb3duZXIuZ2V0Q29tcG9uZW50VHlwZShhTm9kZSk7XG4gICAgICAgICAgICBpZiAoQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50VHlwZSh7XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlOiBhTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBzdWJUYWc6IGFOb2RlLnRhZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VXYWxrZXI6IHJldmVyc2VXYWxrZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50LCByZXZlcnNlV2Fsa2VyKTtcbn1cbi8vICNbZW5kXVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZXZlcnNlTm9kZTtcblxuXG4vKipcbiAqIEBmaWxlIOmUgOavgemHiuaUvuWFg+e0oOeahOWtkOWFg+e0oFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDplIDmr4Hph4rmlL7lhYPntKDnmoTlrZDlhYPntKBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKDoioLngrlcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vRGV0YWNoIOaYr+WQpuS4jeimgeaKiuiKgueCueS7jmRvbeenu+mZpFxuICogQHBhcmFtIHtib29sZWFuPX0gbm9UcmFuc2l0aW9uIOaYr+WQpuS4jeaYvuekuui/h+a4oeWKqOeUu+aViOaenFxuICovXG5mdW5jdGlvbiBlbGVtZW50RGlzcG9zZUNoaWxkcmVuKGVsZW1lbnQsIG5vRGV0YWNoLCBub1RyYW5zaXRpb24pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgIHZhciBsZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGNoaWxkcmVuW2xlbl0uZGlzcG9zZShub0RldGFjaCwgbm9UcmFuc2l0aW9uKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnREaXNwb3NlQ2hpbGRyZW47XG5cblxuLyoqXG4gKiBAZmlsZSDmm7TmlrDlhYPntKDnmoTlrZDlhYPntKDop4blm75cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLyoqXG4gKiDmm7TmlrDlhYPntKDnmoTlrZDlhYPntKDop4blm75cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDopoHmm7TmlrDnmoTlhYPntKBcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRVcGRhdGVDaGlsZHJlbihlbGVtZW50LCBjaGFuZ2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuW2ldLl91cGRhdGUoY2hhbmdlcyk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50VXBkYXRlQ2hpbGRyZW47XG5cblxuLyoqXG4gKiBAZmlsZSDkvb/lhYPntKDoioLngrnliLDovr7nm7jlupTnmoTnlJ/lkb3lkajmnJ9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuXG4vKipcbiAqIOS9v+WFg+e0oOiKgueCueWIsOi+vuebuOW6lOeahOeUn+WRveWRqOacn1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOeUn+WRveWRqOacn+WQjeensFxuICovXG5mdW5jdGlvbiBlbGVtZW50T3duVG9QaGFzZShuYW1lKSB7XG4gICAgdGhpcy5saWZlQ3ljbGUgPSBMaWZlQ3ljbGVbbmFtZV0gfHwgdGhpcy5saWZlQ3ljbGU7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuXG5cbi8qKlxuICogQGZpbGUg5Yib5bu66IqC54K555qE5bel5Y6C5pa55rOVXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgaG90VGFncyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaG90LXRhZ3MnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgVGV4dE5vZGUgPSByZXF1aXJlKCcuL3RleHQtbm9kZScpO1xuLy8gdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbi8vIHZhciBTbG90Tm9kZSA9IHJlcXVpcmUoJy4vc2xvdC1ub2RlJyk7XG4vLyB2YXIgRm9yTm9kZSA9IHJlcXVpcmUoJy4vZm9yLW5vZGUnKTtcbi8vIHZhciBJZk5vZGUgPSByZXF1aXJlKCcuL2lmLW5vZGUnKTtcbi8vIHZhciBUZW1wbGF0ZU5vZGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlLW5vZGUnKTtcblxuXG4vKipcbiAqIOWIm+W7uuiKgueCuVxuICpcbiAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGFOb2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gICAgdmFyIHBhcmVudElzQ29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUO1xuICAgIHZhciBvd25lciA9IHBhcmVudElzQ29tcG9uZW50ID8gcGFyZW50IDogKHBhcmVudC5jaGlsZE93bmVyIHx8IHBhcmVudC5vd25lcik7XG4gICAgc2NvcGUgPSBzY29wZSB8fCAocGFyZW50SXNDb21wb25lbnQgPyBwYXJlbnQuZGF0YSA6IChwYXJlbnQuY2hpbGRTY29wZSB8fCBwYXJlbnQuc2NvcGUpKTtcblxuXG4gICAgaWYgKGFOb2RlLnRleHRFeHByKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoYU5vZGUuZGlyZWN0aXZlc1snaWYnXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICByZXR1cm4gbmV3IElmTm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChhTm9kZS5kaXJlY3RpdmVzWydmb3InXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICByZXR1cm4gbmV3IEZvck5vZGUoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaG90VGFnc1thTm9kZS50YWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbiAgICB9XG5cblxuXG4gICAgc3dpdGNoIChhTm9kZS50YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3QnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbG90Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQpO1xuXG4gICAgICAgIGNhc2UgJ3RlbXBsYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBDb21wb25lbnRUeXBlID0gb3duZXIuZ2V0Q29tcG9uZW50VHlwZShhTm9kZSk7XG4gICAgICAgICAgICBpZiAoQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50VHlwZSh7XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlOiBhTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBzdWJUYWc6IGFOb2RlLnRhZ05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoYU5vZGUsIG93bmVyLCBzY29wZSwgcGFyZW50KTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZTtcblxuXG4vKipcbiAqIEBmaWxlIOeUn+aIkOWtkOWFg+e0oFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZS1ub2RlJyk7XG5cbi8qKlxuICog55Sf5oiQ5a2Q5YWD57SgXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IOWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50RWwg6KaB5re75Yqg5Yiw55qE54i25YWD57SgXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW5077ydfSBiZWZvcmVFbCDopoHmt7vliqDliLDlk6rkuKrlhYPntKDkuYvliY1cbiAqL1xuZnVuY3Rpb24gZ2VuRWxlbWVudENoaWxkcmVuKGVsZW1lbnQsIHBhcmVudEVsLCBiZWZvcmVFbCkge1xuICAgIHBhcmVudEVsID0gcGFyZW50RWwgfHwgZWxlbWVudC5lbDtcblxuICAgIHZhciBhTm9kZUNoaWxkcmVuID0gZWxlbWVudC5hTm9kZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFOb2RlQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY3JlYXRlTm9kZShhTm9kZUNoaWxkcmVuW2ldLCBlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQuYXR0YWNoKHBhcmVudEVsLCBiZWZvcmVFbCk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZW5FbGVtZW50Q2hpbGRyZW47XG5cblxuLyoqXG4gKiBAZmlsZSDlsIbmsqHmnIkgcm9vdCDlj6rmnIkgY2hpbGRyZW4g55qE5YWD57SgIGF0dGFjaCDliLDpobXpnaJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGluc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaW5zZXJ0LWJlZm9yZScpO1xuLy8gdmFyIGdlbkVsZW1lbnRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZ2VuLWVsZW1lbnQtY2hpbGRyZW4nKTtcblxuXG4vKipcbiAqIOWwhuayoeaciSByb290IOWPquaciSBjaGlsZHJlbiDnmoTlhYPntKAgYXR0YWNoIOWIsOmhtemdolxuICog5Li76KaB55So5LqOIHNsb3Qg5ZKMIHRlbXBsYXRlXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50RWwg6KaB5re75Yqg5Yiw55qE54i25YWD57SgXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW5077ydfSBiZWZvcmVFbCDopoHmt7vliqDliLDlk6rkuKrlhYPntKDkuYvliY1cbiAqL1xuZnVuY3Rpb24gbm9kZU93bk9ubHlDaGlsZHJlbkF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICB0aGlzLnNlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy5pZCk7XG4gICAgaW5zZXJ0QmVmb3JlKHRoaXMuc2VsLCBwYXJlbnRFbCwgYmVmb3JlRWwpO1xuXG4gICAgZ2VuRWxlbWVudENoaWxkcmVuKHRoaXMsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcGFyZW50RWwsIGJlZm9yZUVsKTtcblxuICAgIHRoaXMuX3RvUGhhc2UoJ2F0dGFjaGVkJyk7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5vZGVPd25Pbmx5Q2hpbGRyZW5BdHRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSBzbG90IOiKgueCueexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBndWlkID0gcmVxdWlyZSgnLi4vdXRpbC9ndWlkJyk7XG4vLyB2YXIgY3JlYXRlQU5vZGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWEtbm9kZScpO1xuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIGNyZWF0ZUFjY2Vzc29yID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hY2Nlc3NvcicpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBEYXRhID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhJyk7XG4vLyB2YXIgRGF0YUNoYW5nZVR5cGUgPSByZXF1aXJlKCcuLi9ydW50aW1lL2RhdGEtY2hhbmdlLXR5cGUnKTtcbi8vIHZhciBjaGFuZ2VFeHByQ29tcGFyZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlLWV4cHItY29tcGFyZScpO1xuLy8gdmFyIGluc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaW5zZXJ0LWJlZm9yZScpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcbi8vIHZhciBMaWZlQ3ljbGUgPSByZXF1aXJlKCcuL2xpZmUtY3ljbGUnKTtcbi8vIHZhciBnZXRBTm9kZVByb3AgPSByZXF1aXJlKCcuL2dldC1hLW5vZGUtcHJvcCcpO1xuLy8gdmFyIG5vZGVEaXNwb3NlID0gcmVxdWlyZSgnLi9ub2RlLWRpc3Bvc2UnKTtcbi8vIHZhciBjcmVhdGVSZXZlcnNlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLXJldmVyc2Utbm9kZScpO1xuLy8gdmFyIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtZGlzcG9zZS1jaGlsZHJlbicpO1xuLy8gdmFyIGVsZW1lbnRVcGRhdGVDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC11cGRhdGUtY2hpbGRyZW4nKTtcbi8vIHZhciBlbGVtZW50T3duVG9QaGFzZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tdG8tcGhhc2UnKTtcbi8vIHZhciBub2RlT3duT25seUNoaWxkcmVuQXR0YWNoID0gcmVxdWlyZSgnLi9ub2RlLW93bi1vbmx5LWNoaWxkcmVuLWF0dGFjaCcpO1xuXG5cbi8qKlxuICogc2xvdCDoioLngrnnsbtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu2546v5aKDXG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXI/fSByZXZlcnNlV2Fsa2VyIOWtkOWFg+e0oOmBjeWOhuWvueixoVxuICovXG5mdW5jdGlvbiBTbG90Tm9kZShhTm9kZSwgb3duZXIsIHNjb3BlLCBwYXJlbnQsIHJldmVyc2VXYWxrZXIpIHtcbiAgICB2YXIgcmVhbEFOb2RlID0gY3JlYXRlQU5vZGUoKTtcbiAgICB0aGlzLmFOb2RlID0gcmVhbEFOb2RlO1xuICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnRDb21wb25lbnQgPSBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGVUeXBlLkNNUFRcbiAgICAgICAgPyBwYXJlbnRcbiAgICAgICAgOiBwYXJlbnQucGFyZW50Q29tcG9uZW50O1xuXG4gICAgdGhpcy5pZCA9IGd1aWQoKTtcblxuICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLnN0YXJ0O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIGNhbGMgc2xvdCBuYW1lXG4gICAgdGhpcy5uYW1lQmluZCA9IGdldEFOb2RlUHJvcChhTm9kZSwgJ25hbWUnKTtcbiAgICBpZiAodGhpcy5uYW1lQmluZCkge1xuICAgICAgICB0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBldmFsRXhwcih0aGlzLm5hbWVCaW5kLmV4cHIsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpO1xuICAgIH1cblxuICAgIC8vIGNhbGMgYU5vZGUgY2hpbGRyZW5cbiAgICB2YXIgZ2l2ZW5TbG90cyA9IG93bmVyLmdpdmVuU2xvdHM7XG4gICAgdmFyIGdpdmVuQ2hpbGRyZW47XG4gICAgaWYgKGdpdmVuU2xvdHMpIHtcbiAgICAgICAgZ2l2ZW5DaGlsZHJlbiA9IHRoaXMuaXNOYW1lZCA/IGdpdmVuU2xvdHMubmFtZWRbdGhpcy5uYW1lXSA6IGdpdmVuU2xvdHMubm9uYW1lO1xuICAgIH1cblxuICAgIGlmIChnaXZlbkNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuaXNJbnNlcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVhbEFOb2RlLmNoaWxkcmVuID0gZ2l2ZW5DaGlsZHJlbiB8fCBhTm9kZS5jaGlsZHJlbi5zbGljZSgwKTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAvLyBjYWxjIHNjb3BlZCBzbG90IHZhcnNcbiAgICByZWFsQU5vZGUudmFycyA9IGFOb2RlLnZhcnM7XG4gICAgdmFyIGluaXREYXRhID0ge307XG4gICAgZWFjaChyZWFsQU5vZGUudmFycywgZnVuY3Rpb24gKHZhckl0ZW0pIHtcbiAgICAgICAgbWUuaXNTY29wZWQgPSB0cnVlO1xuICAgICAgICBpbml0RGF0YVt2YXJJdGVtLm5hbWVdID0gZXZhbEV4cHIodmFySXRlbS5leHByLCBzY29wZSwgb3duZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gY2hpbGQgb3duZXIgJiBjaGlsZCBzY29wZVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZE93bmVyID0gb3duZXIub3duZXI7XG4gICAgICAgIHRoaXMuY2hpbGRTY29wZSA9IG93bmVyLnNjb3BlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2NvcGVkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRTY29wZSA9IG5ldyBEYXRhKGluaXREYXRhLCB0aGlzLmNoaWxkU2NvcGUgfHwgdGhpcy5zY29wZSk7XG4gICAgfVxuXG5cbiAgICBvd25lci5zbG90Q2hpbGRyZW4ucHVzaCh0aGlzKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAocmV2ZXJzZVdhbGtlcikge1xuXG4gICAgICAgIHRoaXMuc2VsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuc2VsLCByZXZlcnNlV2Fsa2VyLnRhcmdldCwgcmV2ZXJzZVdhbGtlci5jdXJyZW50KTtcblxuICAgICAgICBlYWNoKHRoaXMuYU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChhTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICBtZS5jaGlsZHJlbi5wdXNoKGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlQ2hpbGQsIHJldmVyc2VXYWxrZXIsIG1lKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG5cbiAgICAgICAgdGhpcy5fdG9QaGFzZSgnYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblNsb3ROb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLlNMT1Q7XG5cbi8qKlxuICog6ZSA5q+B6YeK5pS+IHNsb3RcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub0RldGFjaCDmmK/lkKbkuI3opoHmioroioLngrnku45kb23np7vpmaRcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVHJhbnNpdGlvbiDmmK/lkKbkuI3mmL7npLrov4fmuKHliqjnlLvmlYjmnpxcbiAqL1xuU2xvdE5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAobm9EZXRhY2gsIG5vVHJhbnNpdGlvbikge1xuICAgIHRoaXMuY2hpbGRPd25lciA9IG51bGw7XG4gICAgdGhpcy5jaGlsZFNjb3BlID0gbnVsbDtcblxuICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4odGhpcywgbm9EZXRhY2gsIG5vVHJhbnNpdGlvbik7XG4gICAgbm9kZURpc3Bvc2UodGhpcyk7XG59O1xuXG5TbG90Tm9kZS5wcm90b3R5cGUuYXR0YWNoID0gbm9kZU93bk9ubHlDaGlsZHJlbkF0dGFjaDtcblNsb3ROb2RlLnByb3RvdHlwZS5fdG9QaGFzZSA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuXG4vKipcbiAqIOinhuWbvuabtOaWsOWHveaVsFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0Zyb21PdXRlciDlj5jljJbkv6Hmga/mmK/lkKbmnaXmupDkuo7niLbnu4Tku7bkuYvlpJbnmoTnu4Tku7ZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblNsb3ROb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMsIGlzRnJvbU91dGVyKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlmICh0aGlzLm5hbWVCaW5kICYmIGV2YWxFeHByKHRoaXMubmFtZUJpbmQuZXhwciwgdGhpcy5zY29wZSwgdGhpcy5vd25lcikgIT09IG1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5vd25lci5fbm90aWZ5TmVlZFJlbG9hZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRnJvbU91dGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRVcGRhdGVDaGlsZHJlbih0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY29wZWQpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy5hTm9kZS52YXJzLCBmdW5jdGlvbiAodmFySXRlbSkge1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkU2NvcGUuc2V0KHZhckl0ZW0ubmFtZSwgZXZhbEV4cHIodmFySXRlbS5leHByLCBtZS5zY29wZSwgbWUub3duZXIpKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHZhciBzY29wZWRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBlYWNoKGNoYW5nZXMsIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLmlzSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVkQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWFjaChtZS5hTm9kZS52YXJzLCBmdW5jdGlvbiAodmFySXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHZhckl0ZW0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIHZhckl0ZW0uZXhwciwgbWUuc2NvcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gRGF0YUNoYW5nZVR5cGUuU1BMSUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3NvcihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiBFeHByVHlwZS5TVFJJTkcsIHZhbHVlOiBuYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5jaGlsZFNjb3BlLmdldChuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IGNoYW5nZS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbGF0aW9uID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRDaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHI6IGNyZWF0ZUFjY2Vzc29yKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6IEV4cHJUeXBlLlNUUklORywgdmFsdWU6IG5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRGF0YUNoYW5nZVR5cGUuU1BMSUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjaGFuZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQ6IGNoYW5nZS5kZWxldGVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hhbmdlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnM6IGNoYW5nZS5pbnNlcnRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjogY2hhbmdlLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbGVtZW50VXBkYXRlQ2hpbGRyZW4odGhpcywgc2NvcGVkQ2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaXNJbnNlcnRlZCkge1xuICAgICAgICAgICAgZWxlbWVudFVwZGF0ZUNoaWxkcmVuKHRoaXMsIGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2xvdE5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSDlpI3liLbmjIfku6Tpm4blkIjlr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog5aSN5Yi25oyH5Luk6ZuG5ZCI5a+56LGhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSDopoHlpI3liLbnmoTmjIfku6Tpm4blkIjlr7nosaFcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZXhjbHVkZXMg6ZyA6KaB5o6S6Zmk55qEa2V56ZuG5ZCIXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNsb25lRGlyZWN0aXZlcyhzb3VyY2UsIGV4Y2x1ZGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGV4Y2x1ZGVzID0gZXhjbHVkZXMgfHwge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghZXhjbHVkZXNba2V5XSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNsb25lRGlyZWN0aXZlcztcblxuXG4vKipcbiAqIEBmaWxlIOeugOWNleaJp+ihjOmUgOavgeiKgueCueeahOihjOS4ulxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIHJlbW92ZUVsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9yZW1vdmUtZWwnKTtcbi8vIHZhciBub2RlRGlzcG9zZSA9IHJlcXVpcmUoJy4vbm9kZS1kaXNwb3NlJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2VDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlLWNoaWxkcmVuJyk7XG5cbi8qKlxuICog566A5Y2V5omn6KGM6ZSA5q+B6IqC54K555qE6KGM5Li6XG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9EZXRhY2gg5piv5ZCm5LiN6KaB5oqK6IqC54K55LuOZG9t56e76ZmkXG4gKi9cbmZ1bmN0aW9uIG5vZGVPd25TaW1wbGVEaXNwb3NlKG5vRGV0YWNoKSB7XG4gICAgZWxlbWVudERpc3Bvc2VDaGlsZHJlbih0aGlzLCBub0RldGFjaCwgMSk7XG5cbiAgICBpZiAoIW5vRGV0YWNoKSB7XG4gICAgICAgIHJlbW92ZUVsKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIG5vZGVEaXNwb3NlKHRoaXMpO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlT3duU2ltcGxlRGlzcG9zZTtcblxuXG4vKipcbiAqIEBmaWxlIOWIm+W7uuiKgueCueWvueW6lOeahCBzdHVtcCBjb21tZW50IOWFg+e0oFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG5cbi8qKlxuICog5Yib5bu66IqC54K55a+55bqU55qEIHN0dW1wIGNvbW1lbnQg5Li75YWD57SgXG4gKi9cbmZ1bmN0aW9uIG5vZGVPd25DcmVhdGVTdHVtcCgpIHtcbiAgICB0aGlzLmVsID0gdGhpcy5lbCB8fCBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBub2RlT3duQ3JlYXRlU3R1bXA7XG5cblxuLyoqXG4gKiBAZmlsZSBmb3Ig5oyH5Luk6IqC54K557G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBjcmVhdGVBTm9kZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9jcmVhdGUtYS1ub2RlJyk7XG4vLyB2YXIgRXhwclR5cGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvZXhwci10eXBlJyk7XG4vLyB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi4vcGFyc2VyL3BhcnNlLWV4cHInKTtcbi8vIHZhciBjcmVhdGVBY2Nlc3NvciA9IHJlcXVpcmUoJy4uL3BhcnNlci9jcmVhdGUtYWNjZXNzb3InKTtcbi8vIHZhciBjbG9uZURpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9wYXJzZXIvY2xvbmUtZGlyZWN0aXZlcycpO1xuLy8gdmFyIERhdGEgPSByZXF1aXJlKCcuLi9ydW50aW1lL2RhdGEnKTtcbi8vIHZhciBEYXRhQ2hhbmdlVHlwZSA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZGF0YS1jaGFuZ2UtdHlwZScpO1xuLy8gdmFyIGNoYW5nZUV4cHJDb21wYXJlID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2UtZXhwci1jb21wYXJlJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gdmFyIGNoYW5nZXNJc0luRGF0YVJlZiA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY2hhbmdlcy1pcy1pbi1kYXRhLXJlZicpO1xuLy8gdmFyIHJlbW92ZUVsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9yZW1vdmUtZWwnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBMaWZlQ3ljbGUgPSByZXF1aXJlKCcuL2xpZmUtY3ljbGUnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLW5vZGUnKTtcbi8vIHZhciBjcmVhdGVSZXZlcnNlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLXJldmVyc2Utbm9kZScpO1xuLy8gdmFyIG5vZGVPd25TaW1wbGVEaXNwb3NlID0gcmVxdWlyZSgnLi9ub2RlLW93bi1zaW1wbGUtZGlzcG9zZScpO1xuLy8gdmFyIG5vZGVPd25DcmVhdGVTdHVtcCA9IHJlcXVpcmUoJy4vbm9kZS1vd24tY3JlYXRlLXN0dW1wJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2VDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlLWNoaWxkcmVuJyk7XG4vLyB2YXIgZGF0YUNhY2hlID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhLWNhY2hlJyk7XG5cblxuLyoqXG4gKiDlvqrnjq/pobnnmoTmlbDmja7lrrnlmajnsbtcbiAqXG4gKiBAaW5uZXJcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IGZvckVsZW1lbnQgZm9y5YWD57Sg5a+56LGhXG4gKiBAcGFyYW0geyp9IGl0ZW0g5b2T5YmN6aG555qE5pWw5o2uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg5b2T5YmN6aG555qE57Si5byVXG4gKi9cbmZ1bmN0aW9uIEZvckl0ZW1EYXRhKGZvckVsZW1lbnQsIGl0ZW0sIGluZGV4KSB7XG4gICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICB0aGlzLnBhcmVudCA9IGZvckVsZW1lbnQuc2NvcGU7XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuXG4gICAgdGhpcy5kaXJlY3RpdmUgPSBmb3JFbGVtZW50LmFOb2RlLmRpcmVjdGl2ZXNbJ2ZvciddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIHRoaXMucmF3W3RoaXMuZGlyZWN0aXZlLml0ZW0ucmF3XSA9IGl0ZW07XG4gICAgdGhpcy5yYXdbdGhpcy5kaXJlY3RpdmUuaW5kZXgucmF3XSA9IGluZGV4O1xufVxuXG4vKipcbiAqIOWwhuaVsOaNruaTjeS9nOeahOihqOi+vuW8j++8jOi9rOaNouaIkOS4uuWvuXBhcmVudOaVsOaNruaTjeS9nOeahOihqOi+vuW8j1xuICog5Li76KaB5piv5a+5aXRlbeWSjGluZGV46L+b6KGM5aSE55CGXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byPXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkZvckl0ZW1EYXRhLnByb3RvdHlwZS5leHByUmVzb2x2ZSA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgdmFyIGRpcmVjdGl2ZSA9IHRoaXMuZGlyZWN0aXZlO1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlSXRlbShleHByKSB7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IEV4cHJUeXBlLkFDQ0VTU09SXG4gICAgICAgICAgICAmJiBleHByLnBhdGhzWzBdLnZhbHVlID09PSBkaXJlY3RpdmUuaXRlbS5wYXRoc1swXS52YWx1ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUudmFsdWUucGF0aHMuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5OVU1CRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuZ2V0KGRpcmVjdGl2ZS5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXhwci5wYXRocy5zbGljZSgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBleHByID0gcmVzb2x2ZUl0ZW0oZXhwcik7XG5cbiAgICB2YXIgcmVzb2x2ZWRQYXRocyA9IFtdO1xuXG4gICAgZWFjaChleHByLnBhdGhzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXNvbHZlZFBhdGhzLnB1c2goXG4gICAgICAgICAgICBpdGVtLnR5cGUgPT09IEV4cHJUeXBlLkFDQ0VTU09SXG4gICAgICAgICAgICAgICAgJiYgaXRlbS5wYXRoc1swXS52YWx1ZSA9PT0gZGlyZWN0aXZlLmluZGV4LnBhdGhzWzBdLnZhbHVlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHByVHlwZS5OVU1CRVIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLmdldChkaXJlY3RpdmUuaW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHJlc29sdmVJdGVtKGl0ZW0pXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3JlYXRlQWNjZXNzb3IocmVzb2x2ZWRQYXRocyk7XG59O1xuXG4vLyDku6PnkIbmlbDmja7mk43kvZzmlrnms5VcbmluaGVyaXRzKEZvckl0ZW1EYXRhLCBEYXRhKTtcbmVhY2goXG4gICAgWydzZXQnLCAncmVtb3ZlJywgJ3Vuc2hpZnQnLCAnc2hpZnQnLCAncHVzaCcsICdwb3AnLCAnc3BsaWNlJ10sXG4gICAgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBGb3JJdGVtRGF0YS5wcm90b3R5cGVbJ18nICsgbWV0aG9kXSA9IERhdGEucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgIEZvckl0ZW1EYXRhLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLmV4cHJSZXNvbHZlKHBhcnNlRXhwcihleHByKSk7XG4gICAgICAgICAgICBkYXRhQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50W21ldGhvZF0uYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQsXG4gICAgICAgICAgICAgICAgW2V4cHJdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG4pO1xuXG4vKipcbiAqIOWIm+W7uiBmb3Ig5oyH5Luk5YWD57Sg55qE5a2Q5YWD57SgXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge0ZvckRpcmVjdGl2ZX0gZm9yRWxlbWVudCBmb3Ig5oyH5Luk5YWD57Sg5a+56LGhXG4gKiBAcGFyYW0geyp9IGl0ZW0g5a2Q5YWD57Sg5a+55bqU5pWw5o2uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg5a2Q5YWD57Sg5a+55bqU5bqP5Y+3XG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JEaXJlY3RpdmVDaGlsZChmb3JFbGVtZW50LCBpdGVtLCBpbmRleCkge1xuICAgIHZhciBpdGVtU2NvcGUgPSBuZXcgRm9ySXRlbURhdGEoZm9yRWxlbWVudCwgaXRlbSwgaW5kZXgpO1xuICAgIHJldHVybiBjcmVhdGVOb2RlKGZvckVsZW1lbnQuaXRlbUFOb2RlLCBmb3JFbGVtZW50LCBpdGVtU2NvcGUpO1xufVxuXG4vKipcbiAqIGZvciDmjIfku6ToioLngrnnsbtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYU5vZGUg5oq96LGh6IqC54K5XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu2546v5aKDXG4gKiBAcGFyYW0ge01vZGVsPX0gc2NvcGUg5omA5bGe5pWw5o2u546v5aKDXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCDniLbkurLoioLngrlcbiAqIEBwYXJhbSB7RE9NQ2hpbGRyZW5XYWxrZXI/fSByZXZlcnNlV2Fsa2VyIOWtkOWFg+e0oOmBjeWOhuWvueixoVxuICovXG5mdW5jdGlvbiBGb3JOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcikge1xuICAgIHRoaXMuYU5vZGUgPSBhTm9kZTtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5pdGVtQU5vZGUgPSBjcmVhdGVBTm9kZSh7XG4gICAgICAgIGNoaWxkcmVuOiBhTm9kZS5jaGlsZHJlbixcbiAgICAgICAgcHJvcHM6IGFOb2RlLnByb3BzLFxuICAgICAgICBldmVudHM6IGFOb2RlLmV2ZW50cyxcbiAgICAgICAgdGFnTmFtZTogYU5vZGUudGFnTmFtZSxcbiAgICAgICAgdmFyczogYU5vZGUudmFycyxcbiAgICAgICAgaG90c3BvdDogYU5vZGUuaG90c3BvdCxcbiAgICAgICAgZGlyZWN0aXZlczogY2xvbmVEaXJlY3RpdmVzKGFOb2RlLmRpcmVjdGl2ZXMsIHtcbiAgICAgICAgICAgICdmb3InOiAxXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmFtID0gYU5vZGUuZGlyZWN0aXZlc1snZm9yJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG5cbiAgICAvLyAjW2JlZ2luXSByZXZlcnNlXG4gICAgaWYgKHJldmVyc2VXYWxrZXIpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIGV2YWxFeHByKHRoaXMucGFyYW0udmFsdWUsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbVNjb3BlID0gbmV3IEZvckl0ZW1EYXRhKG1lLCBpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjcmVhdGVSZXZlcnNlTm9kZShtZS5pdGVtQU5vZGUsIHJldmVyc2VXYWxrZXIsIG1lLCBpdGVtU2NvcGUpO1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cbkZvck5vZGUucHJvdG90eXBlLm5vZGVUeXBlID0gTm9kZVR5cGUuRk9SO1xuRm9yTm9kZS5wcm90b3R5cGUuX2NyZWF0ZSA9IG5vZGVPd25DcmVhdGVTdHVtcDtcbkZvck5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBub2RlT3duU2ltcGxlRGlzcG9zZTtcblxuLyoqXG4gKiDlsIblhYPntKBhdHRhY2jliLDpobXpnaLnmoTooYzkuLpcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRFbCDopoHmt7vliqDliLDnmoTniLblhYPntKBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnTvvJ19IGJlZm9yZUVsIOimgea3u+WKoOWIsOWTquS4quWFg+e0oOS5i+WJjVxuICovXG5Gb3JOb2RlLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocGFyZW50RWwsIGJlZm9yZUVsKSB7XG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICAvLyBwYWludCBsaXN0XG4gICAgdmFyIGVsID0gdGhpcy5lbCB8fCBwYXJlbnRFbC5maXJzdENoaWxkO1xuICAgIHZhciBkYXRhID0gZXZhbEV4cHIodGhpcy5wYXJhbS52YWx1ZSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG4gICAgdmFyIGxlbiA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZvckRpcmVjdGl2ZUNoaWxkKHRoaXMsIGRhdGFbaV0sIGkpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBjaGlsZC5hdHRhY2gocGFyZW50RWwsIGVsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOWwhuWFg+e0oOS7jumhtemdouS4iuenu+mZpOeahOihjOS4ulxuICovXG5Gb3JOb2RlLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubGlmZUN5Y2xlLmF0dGFjaGVkKSB7XG4gICAgICAgIGVsZW1lbnREaXNwb3NlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcmVtb3ZlRWwodGhpcy5lbCk7XG4gICAgICAgIHRoaXMubGlmZUN5Y2xlID0gTGlmZUN5Y2xlLmRldGFjaGVkO1xuICAgIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGZlY3MtbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiDop4blm77mm7TmlrDlh73mlbBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5Gb3JOb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgLy8g5o6n5Yi25YiX6KGo5pu05paw562W55Wl5piv5ZCm5Y6f5qC35pu05paw55qE5Y+Y6YePXG4gICAgdmFyIG9yaWdpbmFsVXBkYXRlID0gdGhpcy5hTm9kZS5kaXJlY3RpdmVzLnRyYW5zaXRpb247XG5cblxuICAgIHZhciBvbGRDaGlsZHJlbkxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBjaGlsZHJlbkNoYW5nZXMgPSBuZXcgQXJyYXkob2xkQ2hpbGRyZW5MZW4pO1xuXG4gICAgZnVuY3Rpb24gcHVzaFRvQ2hpbGRyZW5DaGFuZ2VzKGNoYW5nZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuQ2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIChjaGlsZHJlbkNoYW5nZXNbaV0gPSBjaGlsZHJlbkNoYW5nZXNbaV0gfHwgW10pLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaXNwb3NlQ2hpbGRyZW4gPSBbXTtcblxuXG4gICAgLy8g5Yik5pat5YiX6KGo5piv5ZCm54i25YWD57Sg5LiL5ZSv5LiA55qE5YWD57SgXG4gICAgLy8g5aaC5p6c5piv55qE6K+d77yM5Y+v5Lul5YGa5LiA5Lqb5pu05paw5LyY5YyWXG4gICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuICAgIHZhciBwYXJlbnRGaXJzdENoaWxkID0gcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICB2YXIgcGFyZW50TGFzdENoaWxkID0gcGFyZW50RWwubGFzdENoaWxkO1xuICAgIHZhciBpc09ubHlQYXJlbnRDaGlsZCA9IG9sZENoaWxkcmVuTGVuID4gMCAvLyDmnInlranlrZDml7ZcbiAgICAgICAgICAgICYmIHBhcmVudEZpcnN0Q2hpbGQgPT09IHRoaXMuY2hpbGRyZW5bMF0uZWxcbiAgICAgICAgICAgICYmIChwYXJlbnRMYXN0Q2hpbGQgPT09IHRoaXMuZWwgfHwgcGFyZW50TGFzdENoaWxkID09PSB0aGlzLmNoaWxkcmVuW29sZENoaWxkcmVuTGVuIC0gMV0uZWwpXG4gICAgICAgIHx8IG9sZENoaWxkcmVuTGVuID09PSAwIC8vIOaXoOWtqeWtkOaXtlxuICAgICAgICAgICAgJiYgcGFyZW50Rmlyc3RDaGlsZCA9PT0gdGhpcy5lbFxuICAgICAgICAgICAgJiYgcGFyZW50TGFzdENoaWxkID09PSB0aGlzLmVsO1xuXG4gICAgLy8g5o6n5Yi25YiX6KGo5piv5ZCm5pW05L2T5pu05paw55qE5Y+Y6YePXG4gICAgdmFyIGlzQ2hpbGRyZW5SZWJ1aWxkO1xuXG4gICAgdmFyIG5ld0xpc3QgPSBldmFsRXhwcih0aGlzLnBhcmFtLnZhbHVlLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKTtcbiAgICB2YXIgbmV3TGVuID0gbmV3TGlzdCAmJiBuZXdMaXN0Lmxlbmd0aCB8fCAwO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG4gICAgZm9yICh2YXIgY0luZGV4ID0gMCwgY0xlbiA9IGNoYW5nZXMubGVuZ3RoOyBjSW5kZXggPCBjTGVuOyBjSW5kZXgrKykge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tjSW5kZXhdO1xuICAgICAgICB2YXIgcmVsYXRpb24gPSBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2UuZXhwciwgdGhpcy5wYXJhbS52YWx1ZSwgdGhpcy5zY29wZSk7XG5cbiAgICAgICAgaWYgKCFyZWxhdGlvbikge1xuICAgICAgICAgICAgLy8g5peg5YWz5pe277yM55u05o6l5Lyg6YCS57uZ5a2Q5YWD57Sg5pu05paw77yM5YiX6KGo5pys6Lqr5LiN6ZyA6KaB5YqoXG4gICAgICAgICAgICBwdXNoVG9DaGlsZHJlbkNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWxhdGlvbiA+IDIpIHtcbiAgICAgICAgICAgIC8vIOWPmOabtOihqOi+vuW8j+aYr2xpc3Tnu5Hlrprooajovr7lvI/nmoTlrZDpoblcbiAgICAgICAgICAgIC8vIOWPqumcgOimgeWvueebuOW6lOeahOWtkOmhuei/m+ihjOabtOaWsFxuICAgICAgICAgICAgdmFyIGNoYW5nZVBhdGhzID0gY2hhbmdlLmV4cHIucGF0aHM7XG4gICAgICAgICAgICB2YXIgZm9yTGVuID0gdGhpcy5wYXJhbS52YWx1ZS5wYXRocy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY2hhbmdlSW5kZXggPSArZXZhbEV4cHIoY2hhbmdlUGF0aHNbZm9yTGVuXSwgdGhpcy5zY29wZSwgdGhpcy5vd25lcik7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjaGFuZ2VJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBwdXNoVG9DaGlsZHJlbkNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGV4cHI6IGNyZWF0ZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5pdGVtLnBhdGhzLmNvbmNhdChjaGFuZ2VQYXRocy5zbGljZShmb3JMZW4gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNoYW5nZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQ6IGNoYW5nZS5kZWxldGVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0aW9uczogY2hhbmdlLmluc2VydGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbjogY2hhbmdlLm9wdGlvblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAoY2hpbGRyZW5DaGFuZ2VzW2NoYW5nZUluZGV4XSA9IGNoaWxkcmVuQ2hhbmdlc1tjaGFuZ2VJbmRleF0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKGNoYW5nZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltjaGFuZ2VJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBEYXRhQ2hhbmdlVHlwZS5TUExJQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bY2hhbmdlSW5kZXhdLnNjb3BlLl9zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW10uY29uY2F0KGNoYW5nZS5pbmRleCwgY2hhbmdlLmRlbGV0ZUNvdW50LCBjaGFuZ2UuaW5zZXJ0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzaWxlbnQ6IDEgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bY2hhbmdlSW5kZXhdLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2lsZW50OiAxIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgIT09IERhdGFDaGFuZ2VUeXBlLlNQTElDRSkge1xuICAgICAgICAgICAgLy8g5Y+Y5pu06KGo6L6+5byP5pivbGlzdOe7keWumuihqOi+vuW8j+acrOi6q+aIluavjemhueeahOmHjeaWsOiuvuWAvFxuICAgICAgICAgICAgLy8g5q2k5pe26ZyA6KaB5pu05paw5pW05Liq5YiX6KGoXG5cblxuICAgICAgICAgICAgLy8g6ICB55qE5q+U5paw55qE5aSa55qE6YOo5YiG77yM5qCH6K6w6ZyA6KaBZGlzcG9zZVxuICAgICAgICAgICAgaWYgKG9sZENoaWxkcmVuTGVuID4gbmV3TGVuKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZUNoaWxkcmVuID0gZGlzcG9zZUNoaWxkcmVuLmNvbmNhdCh0aGlzLmNoaWxkcmVuLnNsaWNlKG5ld0xlbikpO1xuXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzID0gY2hpbGRyZW5DaGFuZ2VzLnNsaWNlKDAsIG5ld0xlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoMCwgbmV3TGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5pW06aG55Y+Y5pu0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuQ2hhbmdlc1tpXSA9IGNoaWxkcmVuQ2hhbmdlc1tpXSB8fCBbXSkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3Nvcih0aGlzLnBhcmFtLml0ZW0ucGF0aHMuc2xpY2UoMCkpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3TGlzdFtpXVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8g5a+5bGlzdOabtOS4iue6p+aVsOaNrueahOebtOaOpeiuvue9rlxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbiA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzW2ldLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0W2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAge3NpbGVudDogMX1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNDaGlsZHJlblJlYnVpbGQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbGF0aW9uID09PSAyICYmIGNoYW5nZS50eXBlID09PSBEYXRhQ2hhbmdlVHlwZS5TUExJQ0UgJiYgIWlzQ2hpbGRyZW5SZWJ1aWxkKSB7XG4gICAgICAgICAgICAvLyDlj5jmm7Tooajovr7lvI/mmK9saXN057uR5a6a6KGo6L6+5byP5pys6Lqr5pWw57uE55qEc3BsaWNl5pON5L2cXG4gICAgICAgICAgICAvLyDmraTml7bpnIDopoHliKDpmaTpg6jliIbpobnvvIzliJvlu7rpg6jliIbpoblcbiAgICAgICAgICAgIHZhciBjaGFuZ2VTdGFydCA9IGNoYW5nZS5pbmRleDtcbiAgICAgICAgICAgIHZhciBkZWxldGVDb3VudCA9IGNoYW5nZS5kZWxldGVDb3VudDtcbiAgICAgICAgICAgIHZhciBpbnNlcnRpb25zTGVuID0gY2hhbmdlLmluc2VydGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5ld0NvdW50ID0gaW5zZXJ0aW9uc0xlbiAtIGRlbGV0ZUNvdW50O1xuXG4gICAgICAgICAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBjaGFuZ2Uub3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBleHByOiB0aGlzLnBhcmFtLmluZGV4XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGFuZ2VTdGFydCArIGRlbGV0ZUNvdW50OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAoY2hpbGRyZW5DaGFuZ2VzW2ldID0gY2hpbGRyZW5DaGFuZ2VzW2ldIHx8IFtdKS5wdXNoKGluZGV4Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXSAmJiB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleENoYW5nZS5leHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtIGRlbGV0ZUNvdW50ICsgaW5zZXJ0aW9uc0xlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaWxlbnQ6IDF9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsZXRlTGVuID0gZGVsZXRlQ291bnQ7XG4gICAgICAgICAgICB3aGlsZSAoZGVsZXRlTGVuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGVuIDwgaW5zZXJ0aW9uc0xlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGNoYW5nZVN0YXJ0ICsgZGVsZXRlTGVuO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgKGNoaWxkcmVuQ2hhbmdlc1tpXSA9IGNoaWxkcmVuQ2hhbmdlc1tpXSB8fCBbXSkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRhQ2hhbmdlVHlwZS5TRVQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IGNoYW5nZS5vcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3Nvcih0aGlzLnBhcmFtLml0ZW0ucGF0aHMuc2xpY2UoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5pbnNlcnRpb25zW2RlbGV0ZUxlbl1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnNjb3BlLl9zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5pbnNlcnRpb25zW2RlbGV0ZUxlbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NpbGVudDogMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdDb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlQ2hpbGRyZW4gPSBkaXNwb3NlQ2hpbGRyZW4uY29uY2F0KHRoaXMuY2hpbGRyZW4uc3BsaWNlKGNoYW5nZVN0YXJ0ICsgaW5zZXJ0aW9uc0xlbiwgLW5ld0NvdW50KSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzLnNwbGljZShjaGFuZ2VTdGFydCArIGluc2VydGlvbnNMZW4sIC1uZXdDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BsaWNlQXJncyA9IFtjaGFuZ2VTdGFydCArIGRlbGV0ZUNvdW50LCAwXS5jb25jYXQobmV3IEFycmF5KG5ld0NvdW50KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UuYXBwbHkodGhpcy5jaGlsZHJlbiwgc3BsaWNlQXJncyk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VzLnNwbGljZS5hcHBseShjaGlsZHJlbkNoYW5nZXMsIHNwbGljZUFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuTGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvLyDmoIforrAgbGVuZ3RoIOaYr+WQpuWPkeeUn+WPmOWMllxuICAgIGlmIChuZXdDaGlsZHJlbkxlbiAhPT0gb2xkQ2hpbGRyZW5MZW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aENoYW5nZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IERhdGFDaGFuZ2VUeXBlLlNFVCxcbiAgICAgICAgICAgIG9wdGlvbjoge30sXG4gICAgICAgICAgICBleHByOiBjcmVhdGVBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtLnZhbHVlLnBhdGhzLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4cHJUeXBlLlNUUklORyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdsZW5ndGgnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY2hhbmdlc0lzSW5EYXRhUmVmKFtsZW5ndGhDaGFuZ2VdLCB0aGlzLmFOb2RlLmhvdHNwb3QuZGF0YSkpIHtcbiAgICAgICAgICAgIHB1c2hUb0NoaWxkcmVuQ2hhbmdlcyhsZW5ndGhDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5riF6Zmk5bqU6K+l5bmy5o6J55qEIGNoaWxkXG4gICAgdGhpcy5fZG9DcmVhdGVBbmRVcGRhdGUgPSBkb0NyZWF0ZUFuZFVwZGF0ZTtcblxuICAgIC8vIOi/memHjOS4jeeUqGdldFRyYW5zaXRpb27vvIxnZXRUcmFuc2l0aW9u5ZKMc2NvcGXnm7jlhbPvvIxmb3Llkoxmb3JJdGVt55qEc2NvcGXmmK/kuI3lkIznmoRcbiAgICAvLyDmiYDku6VnZXRUcmFuc2l0aW9u57uT5p6c5pys6Lqr5Lmf5piv5LiN5LiA6Ie055qE44CC5LiN5aaC55u05o6l5Yik5pat5oyH5Luk5piv5ZCm5a2Y5Zyo77yM5aaC5p6c5a2Y5Zyo5bCx5LiN6L+b5YWl5pq05Yqb5riF6Zmk5qih5byPXG4gICAgLy8gdmFyIHZpb2xlbnRDbGVhciA9IGlzT25seVBhcmVudENoaWxkICYmIG5ld0NoaWxkcmVuTGVuID09PSAwICYmICFlbGVtZW50R2V0VHJhbnNpdGlvbihtZSk7XG4gICAgdmFyIHZpb2xlbnRDbGVhciA9ICFvcmlnaW5hbFVwZGF0ZSAmJiBpc09ubHlQYXJlbnRDaGlsZCAmJiBuZXdDaGlsZHJlbkxlbiA9PT0gMDtcblxuICAgIHZhciBkaXNwb3NlZENoaWxkQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcG9zZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaXNwb3NlQ2hpbGQgPSBkaXNwb3NlQ2hpbGRyZW5baV07XG4gICAgICAgIGlmIChkaXNwb3NlQ2hpbGQpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VDaGlsZC5fb25kaXNwb3NlZCA9IGNoaWxkRGlzcG9zZWQ7XG4gICAgICAgICAgICBkaXNwb3NlQ2hpbGQuZGlzcG9zZSh2aW9sZW50Q2xlYXIsIHZpb2xlbnRDbGVhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGlsZERpc3Bvc2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlvbGVudENsZWFyKSB7XG4gICAgICAgIC8vIGNsb25lTm9kZSArIHJlcGxhY2VDaGlsZCBpcyBmYXN0ZXJcbiAgICAgICAgLy8gcGFyZW50RWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHZhciByZXBsYWNlTm9kZSA9IHBhcmVudEVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIHBhcmVudEVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlcGxhY2VOb2RlLCBwYXJlbnRFbCk7XG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICByZXBsYWNlTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzcG9zZUNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb0NyZWF0ZUFuZFVwZGF0ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY2hpbGREaXNwb3NlZCgpIHtcbiAgICAgICAgZGlzcG9zZWRDaGlsZENvdW50Kys7XG4gICAgICAgIGlmIChkaXNwb3NlZENoaWxkQ291bnQgPT09IGRpc3Bvc2VDaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICYmIGRvQ3JlYXRlQW5kVXBkYXRlID09PSBtZS5fZG9DcmVhdGVBbmRVcGRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkb0NyZWF0ZUFuZFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9DcmVhdGVBbmRVcGRhdGUoKSB7XG4gICAgICAgIG1lLl9kb0NyZWF0ZUFuZFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIGlmICh2aW9sZW50Q2xlYXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGJlZm9yZUVsID0gbWUuZWw7XG5cbiAgICAgICAgLy8g5a+555u45bqU55qE6aG56L+b6KGM5pu05pawXG4gICAgICAgIGlmIChvbGRDaGlsZHJlbkxlbiA9PT0gMCAmJiBpc09ubHlQYXJlbnRDaGlsZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWUuY2hpbGRyZW5baV0gPSBjcmVhdGVGb3JEaXJlY3RpdmVDaGlsZChtZSwgbmV3TGlzdFtpXSwgaSk7XG4gICAgICAgICAgICAgICAgbWUuY2hpbGRyZW5baV0uYXR0YWNoKHBhcmVudEVsLCBiZWZvcmVFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzkuI1hdHRhY2hlZOWImeebtOaOpeWIm+W7uu+8jOWmguaenOWtmOWcqOWImeiwg+eUqOabtOaWsOWHveaVsFxuICAgICAgICAgICAgdmFyIGogPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW5MZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG1lLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuQ2hhbmdlc1tpXSAmJiBjaGlsZC5fdXBkYXRlKGNoaWxkcmVuQ2hhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbmV3Q2hpbGRyZW5MZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gbWUuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFbCA9IG5leHRDaGlsZC5zZWwgfHwgbmV4dENoaWxkLmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRyZW5baV0gPSBjcmVhdGVGb3JEaXJlY3RpdmVDaGlsZChtZSwgbmV3TGlzdFtpXSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNoaWxkcmVuW2ldLmF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwgfHwgbWUuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRm9yTm9kZTtcblxuXG4vKipcbiAqIEBmaWxlIOa4hea0l+adoeS7tiBhTm9kZVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgY3JlYXRlQU5vZGUgPSByZXF1aXJlKCcuLi9wYXJzZXIvY3JlYXRlLWEtbm9kZScpO1xuLy8gdmFyIGNsb25lRGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL3BhcnNlci9jbG9uZS1kaXJlY3RpdmVzJyk7XG5cblxuLyoqXG4gKiDmuIXmtJfmnaHku7YgYU5vZGXvvIzov5Tlm57nuq/lh4Dml6DmnaHku7bmjIfku6TnmoQgYU5vZGVcbiAqXG4gKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDmnaHku7boioLngrnlr7nosaFcbiAqIEByZXR1cm4ge0FOb2RlfVxuICovXG5mdW5jdGlvbiByaW5zZUNvbmRBTm9kZShhTm9kZSkge1xuICAgIHZhciBjbGVhckFOb2RlID0gY3JlYXRlQU5vZGUoe1xuICAgICAgICBjaGlsZHJlbjogYU5vZGUuY2hpbGRyZW4sXG4gICAgICAgIHByb3BzOiBhTm9kZS5wcm9wcyxcbiAgICAgICAgZXZlbnRzOiBhTm9kZS5ldmVudHMsXG4gICAgICAgIHRhZ05hbWU6IGFOb2RlLnRhZ05hbWUsXG4gICAgICAgIHZhcnM6IGFOb2RlLnZhcnMsXG4gICAgICAgIGhvdHNwb3Q6IGFOb2RlLmhvdHNwb3QsXG4gICAgICAgIGRpcmVjdGl2ZXM6IGNsb25lRGlyZWN0aXZlcyhhTm9kZS5kaXJlY3RpdmVzLCB7XG4gICAgICAgICAgICAnaWYnOiAxLFxuICAgICAgICAgICAgJ2Vsc2UnOiAxLFxuICAgICAgICAgICAgJ2VsaWYnOiAxXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xlYXJBTm9kZTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmluc2VDb25kQU5vZGU7XG5cblxuLyoqXG4gKiBAZmlsZSBpZiDmjIfku6ToioLngrnnsbtcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ3VpZCcpO1xuLy8gdmFyIGluc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaW5zZXJ0LWJlZm9yZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgcmluc2VDb25kQU5vZGUgPSByZXF1aXJlKCcuL3JpbnNlLWNvbmQtYW5vZGUnKTtcbi8vIHZhciBjcmVhdGVOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtbm9kZScpO1xuLy8gdmFyIGNyZWF0ZVJldmVyc2VOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtcmV2ZXJzZS1ub2RlJyk7XG4vLyB2YXIgbm9kZU93bkNyZWF0ZVN0dW1wID0gcmVxdWlyZSgnLi9ub2RlLW93bi1jcmVhdGUtc3R1bXAnKTtcbi8vIHZhciBlbGVtZW50VXBkYXRlQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2VsZW1lbnQtdXBkYXRlLWNoaWxkcmVuJyk7XG4vLyB2YXIgbm9kZU93blNpbXBsZURpc3Bvc2UgPSByZXF1aXJlKCcuL25vZGUtb3duLXNpbXBsZS1kaXNwb3NlJyk7XG5cbi8qKlxuICogaWYg5oyH5Luk6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gSWZOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcikge1xuICAgIHRoaXMuYU5vZGUgPSBhTm9kZTtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5jb25kID0gdGhpcy5hTm9kZS5kaXJlY3RpdmVzWydpZiddLnZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuXG4gICAgLy8gI1tiZWdpbl0gcmV2ZXJzZVxuICAgIGlmIChyZXZlcnNlV2Fsa2VyKSB7XG4gICAgICAgIGlmIChldmFsRXhwcih0aGlzLmNvbmQsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmVsc2VJbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblswXSA9IGNyZWF0ZVJldmVyc2VOb2RlKFxuICAgICAgICAgICAgICAgIHJpbnNlQ29uZEFOb2RlKGFOb2RlKSxcbiAgICAgICAgICAgICAgICByZXZlcnNlV2Fsa2VyLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgZWFjaChhTm9kZS5lbHNlcywgZnVuY3Rpb24gKGVsc2VBTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxpZiA9IGVsc2VBTm9kZS5kaXJlY3RpdmVzLmVsaWY7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVsaWYgfHwgZWxpZiAmJiBldmFsRXhwcihlbGlmLnZhbHVlLCBtZS5zY29wZSwgbWUub3duZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmVsc2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZS5jaGlsZHJlblswXSA9IGNyZWF0ZVJldmVyc2VOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmluc2VDb25kQU5vZGUoZWxzZUFOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VXYWxrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIHJldmVyc2VXYWxrZXIudGFyZ2V0LCByZXZlcnNlV2Fsa2VyLmN1cnJlbnQpO1xuICAgIH1cbiAgICAvLyAjW2VuZF1cbn1cblxuSWZOb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5vZGVUeXBlLklGO1xuXG5JZk5vZGUucHJvdG90eXBlLl9jcmVhdGUgPSBub2RlT3duQ3JlYXRlU3R1bXA7XG5JZk5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBub2RlT3duU2ltcGxlRGlzcG9zZTtcblxuSWZOb2RlLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocGFyZW50RWwsIGJlZm9yZUVsKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZWxzZUluZGV4O1xuICAgIHZhciBjaGlsZDtcblxuICAgIGlmIChldmFsRXhwcih0aGlzLmNvbmQsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpKSB7XG4gICAgICAgIGNoaWxkID0gY3JlYXRlTm9kZShyaW5zZUNvbmRBTm9kZShtZS5hTm9kZSksIG1lKTtcbiAgICAgICAgZWxzZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlYWNoKG1lLmFOb2RlLmVsc2VzLCBmdW5jdGlvbiAoZWxzZUFOb2RlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGVsaWYgPSBlbHNlQU5vZGUuZGlyZWN0aXZlcy5lbGlmO1xuXG4gICAgICAgICAgICBpZiAoIWVsaWYgfHwgZWxpZiAmJiBldmFsRXhwcihlbGlmLnZhbHVlLCBtZS5zY29wZSwgbWUub3duZXIpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjcmVhdGVOb2RlKHJpbnNlQ29uZEFOb2RlKGVsc2VBTm9kZSksIG1lKTtcbiAgICAgICAgICAgICAgICBlbHNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgICBtZS5jaGlsZHJlblswXSA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5hdHRhY2gocGFyZW50RWwsIGJlZm9yZUVsKTtcbiAgICAgICAgbWUuZWxzZUluZGV4ID0gZWxzZUluZGV4O1xuICAgIH1cblxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgaW5zZXJ0QmVmb3JlKHRoaXMuZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG59O1xuXG5cbi8qKlxuICog6KeG5Zu+5pu05paw5Ye95pWwXG4gKlxuICogQHBhcmFtIHtBcnJheX0gY2hhbmdlcyDmlbDmja7lj5jljJbkv6Hmga9cbiAqL1xuSWZOb2RlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjaGlsZEFOb2RlID0gbWUuYU5vZGU7XG4gICAgdmFyIGVsc2VJbmRleDtcblxuICAgIGlmIChldmFsRXhwcih0aGlzLmNvbmQsIHRoaXMuc2NvcGUsIHRoaXMub3duZXIpKSB7XG4gICAgICAgIGVsc2VJbmRleCA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWFjaChtZS5hTm9kZS5lbHNlcywgZnVuY3Rpb24gKGVsc2VBTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBlbGlmID0gZWxzZUFOb2RlLmRpcmVjdGl2ZXMuZWxpZjtcblxuICAgICAgICAgICAgaWYgKGVsaWYgJiYgZXZhbEV4cHIoZWxpZi52YWx1ZSwgbWUuc2NvcGUsIG1lLm93bmVyKSB8fCAhZWxpZikge1xuICAgICAgICAgICAgICAgIGVsc2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGNoaWxkQU5vZGUgPSBlbHNlQU5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZWxzZUluZGV4ID09PSBtZS5lbHNlSW5kZXgpIHtcbiAgICAgICAgZWxlbWVudFVwZGF0ZUNoaWxkcmVuKG1lLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG1lLmNoaWxkcmVuWzBdO1xuICAgICAgICBtZS5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLl9vbmRpc3Bvc2VkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdDaGlsZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZWxzZUluZGV4ID0gZWxzZUluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld0NoaWxkKCkge1xuICAgICAgICBpZiAodHlwZW9mIGVsc2VJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNyZWF0ZU5vZGUocmluc2VDb25kQU5vZGUoY2hpbGRBTm9kZSksIG1lKTtcbiAgICAgICAgICAgIC8vIHZhciBwYXJlbnRFbCA9IGdldE5vZGVTdHVtcFBhcmVudChtZSk7XG4gICAgICAgICAgICBjaGlsZC5hdHRhY2gobWUuZWwucGFyZW50Tm9kZSwgbWUuZWwpO1xuXG4gICAgICAgICAgICBtZS5jaGlsZHJlblswXSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSWZOb2RlO1xuXG5cbi8qKlxuICogQGZpbGUgdGVtcGxhdGUg6IqC54K557G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgTGlmZUN5Y2xlID0gcmVxdWlyZSgnLi9saWZlLWN5Y2xlJyk7XG4vLyB2YXIgbm9kZURpc3Bvc2UgPSByZXF1aXJlKCcuL25vZGUtZGlzcG9zZScpO1xuLy8gdmFyIGNyZWF0ZVJldmVyc2VOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtcmV2ZXJzZS1ub2RlJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2VDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlLWNoaWxkcmVuJyk7XG4vLyB2YXIgZWxlbWVudE93blRvUGhhc2UgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLXRvLXBoYXNlJyk7XG4vLyB2YXIgZWxlbWVudFVwZGF0ZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LXVwZGF0ZS1jaGlsZHJlbicpO1xuLy8gdmFyIG5vZGVPd25Pbmx5Q2hpbGRyZW5BdHRhY2ggPSByZXF1aXJlKCcuL25vZGUtb3duLW9ubHktY2hpbGRyZW4tYXR0YWNoJyk7XG5cbi8qKlxuICogdGVtcGxhdGUg6IqC54K557G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFOb2RlIOaKveixoeiKgueCuVxuICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tueOr+Wig1xuICogQHBhcmFtIHtNb2RlbD19IHNjb3BlIOaJgOWxnuaVsOaNrueOr+Wig1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQg54i25Lqy6IqC54K5XG4gKiBAcGFyYW0ge0RPTUNoaWxkcmVuV2Fsa2VyP30gcmV2ZXJzZVdhbGtlciDlrZDlhYPntKDpgY3ljoblr7nosaFcbiAqL1xuZnVuY3Rpb24gVGVtcGxhdGVOb2RlKGFOb2RlLCBvd25lciwgc2NvcGUsIHBhcmVudCwgcmV2ZXJzZVdhbGtlcikge1xuICAgIHRoaXMuYU5vZGUgPSBhTm9kZTtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgID8gcGFyZW50XG4gICAgICAgIDogcGFyZW50LnBhcmVudENvbXBvbmVudDtcblxuICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgdGhpcy5saWZlQ3ljbGUgPSBMaWZlQ3ljbGUuc3RhcnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgLy8gI1tiZWdpbl0gcmV2ZXJzZVxuICAgIGlmIChyZXZlcnNlV2Fsa2VyKSB7XG4gICAgICAgIHRoaXMuc2VsID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLmlkKTtcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuc2VsLCByZXZlcnNlV2Fsa2VyLnRhcmdldCwgcmV2ZXJzZVdhbGtlci5jdXJyZW50KTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBlYWNoKHRoaXMuYU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChhTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICBtZS5jaGlsZHJlbi5wdXNoKGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlQ2hpbGQsIHJldmVyc2VXYWxrZXIsIG1lKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMuaWQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUodGhpcy5lbCwgcmV2ZXJzZVdhbGtlci50YXJnZXQsIHJldmVyc2VXYWxrZXIuY3VycmVudCk7XG5cbiAgICAgICAgdGhpcy5fdG9QaGFzZSgnYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgLy8gI1tlbmRdXG59XG5cblxuXG5UZW1wbGF0ZU5vZGUucHJvdG90eXBlLm5vZGVUeXBlID0gTm9kZVR5cGUuVFBMO1xuXG5UZW1wbGF0ZU5vZGUucHJvdG90eXBlLmF0dGFjaCA9IG5vZGVPd25Pbmx5Q2hpbGRyZW5BdHRhY2g7XG5cbi8qKlxuICog6ZSA5q+B6YeK5pS+XG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9EZXRhY2gg5piv5ZCm5LiN6KaB5oqK6IqC54K55LuOZG9t56e76ZmkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1RyYW5zaXRpb24g5piv5ZCm5LiN5pi+56S66L+H5rih5Yqo55S75pWI5p6cXG4gKi9cblRlbXBsYXRlTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChub0RldGFjaCwgbm9UcmFuc2l0aW9uKSB7XG4gICAgZWxlbWVudERpc3Bvc2VDaGlsZHJlbih0aGlzLCBub0RldGFjaCwgbm9UcmFuc2l0aW9uKTtcbiAgICBub2RlRGlzcG9zZSh0aGlzKTtcbn07XG5cblxuVGVtcGxhdGVOb2RlLnByb3RvdHlwZS5fdG9QaGFzZSA9IGVsZW1lbnRPd25Ub1BoYXNlO1xuXG4vKipcbiAqIOinhuWbvuabtOaWsOWHveaVsFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMg5pWw5o2u5Y+Y5YyW5L+h5oGvXG4gKi9cblRlbXBsYXRlTm9kZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgZWxlbWVudFVwZGF0ZUNoaWxkcmVuKHRoaXMsIGNoYW5nZXMpO1xufTtcblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGVOb2RlO1xuXG5cbi8qKlxuICogQGZpbGUg5a+55YWD57Sg55qE5a2Q6IqC54K56L+b6KGM5Y+N6KejXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgRE9NQ2hpbGRyZW5XYWxrZXIgPSByZXF1aXJlKCcuL2RvbS1jaGlsZHJlbi13YWxrZXInKTtcbi8vIHZhciBjcmVhdGVSZXZlcnNlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlLXJldmVyc2Utbm9kZScpO1xuXG4vLyAjW2JlZ2luXSByZXZlcnNlXG5cbi8qKlxuICog5a+55YWD57Sg55qE5a2Q6IqC54K56L+b6KGM5Y+N6KejXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQg5YWD57SgXG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VFbGVtZW50Q2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHZhciBodG1sRGlyZWN0aXZlID0gZWxlbWVudC5hTm9kZS5kaXJlY3RpdmVzLmh0bWw7XG5cbiAgICBpZiAoIWh0bWxEaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIHJldmVyc2VXYWxrZXIgPSBuZXcgRE9NQ2hpbGRyZW5XYWxrZXIoZWxlbWVudC5lbCk7XG5cbiAgICAgICAgZWFjaChlbGVtZW50LmFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoYU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wdXNoKGNyZWF0ZVJldmVyc2VOb2RlKGFOb2RlQ2hpbGQsIHJldmVyc2VXYWxrZXIsIGVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJldmVyc2VFbGVtZW50Q2hpbGRyZW47XG5cblxuLyoqXG4gKiBAZmlsZSDlpITnkIblhYPntKDnmoTlsZ7mgKfmk43kvZxcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBnZXRQcm9wSGFuZGxlciA9IHJlcXVpcmUoJy4vZ2V0LXByb3AtaGFuZGxlcicpO1xuXG4vKipcbiAqIOWkhOeQhuWFg+e0oOWxnuaAp+aTjeS9nFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOWFg+e0oOWvueixoVxuICogQHBhcmFtIHsqfSB2YWx1ZSDlsZ7mgKflgLxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wIOWxnuaAp+S/oeaBr+WvueixoVxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wKGVsZW1lbnQsIHZhbHVlLCBwcm9wKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgZ2V0UHJvcEhhbmRsZXIoZWxlbWVudC50YWdOYW1lLCBuYW1lKS5wcm9wKGVsZW1lbnQuZWwsIHZhbHVlLCBuYW1lLCBlbGVtZW50LCBwcm9wKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaGFuZGxlUHJvcDtcblxuXG4vKipcbiAqIEBmaWxlIOWIm+W7uuiKgueCueWvueW6lOeahCBIVE1MRWxlbWVudCDkuLvlhYPntKBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBjcmVhdGVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvY3JlYXRlLWVsJyk7XG4vLyB2YXIgaGFuZGxlUHJvcCA9IHJlcXVpcmUoJy4vaGFuZGxlLXByb3AnKTtcbi8vIHZhciBMaWZlQ3ljbGUgPSByZXF1aXJlKCcuL2xpZmUtY3ljbGUnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG5cbnZhciBlbXB0eVByb3BXaGVuQ3JlYXRlID0ge1xuICAgICdjbGFzcyc6IDEsXG4gICAgJ3N0eWxlJzogMSxcbiAgICAnaWQnOiAxXG59O1xuXG4vKipcbiAqIOWIm+W7uuiKgueCueWvueW6lOeahCBIVE1MRWxlbWVudCDkuLvlhYPntKBcbiAqL1xuZnVuY3Rpb24gZWxlbWVudE93bkNyZWF0ZSgpIHtcbiAgICBpZiAoIXRoaXMubGlmZUN5Y2xlLmNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5saWZlQ3ljbGUgPSBMaWZlQ3ljbGUucGFpbnRpbmc7XG5cbiAgICAgICAgdmFyIGlzQ29tcG9uZW50ID0gdGhpcy5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVDtcbiAgICAgICAgdmFyIHNvdXJjZU5vZGUgPSB0aGlzLmFOb2RlLmhvdHNwb3Quc291cmNlTm9kZTtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5hTm9kZS5wcm9wcztcblxuICAgICAgICBpZiAoc291cmNlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5lbCA9IHNvdXJjZU5vZGUuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICBwcm9wcyA9IHRoaXMuYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsID0gY3JlYXRlRWwodGhpcy50YWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNDb21wb25lbnRcbiAgICAgICAgICAgICAgICA/IGV2YWxFeHByKHByb3AuZXhwciwgdGhpcy5kYXRhLCB0aGlzKVxuICAgICAgICAgICAgICAgIDogZXZhbEV4cHIocHJvcC5leHByLCB0aGlzLnNjb3BlLCB0aGlzLm93bmVyKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIHx8ICFlbXB0eVByb3BXaGVuQ3JlYXRlW3Byb3AubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wKHRoaXMsIHZhbHVlLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2NyZWF0ZWQnKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25DcmVhdGU7XG5cblxuLyoqXG4gKiBAZmlsZSDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBjcmVhdGVOb2RlID0gcmVxdWlyZSgnLi9jcmVhdGUtbm9kZScpO1xuLy8gdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi4vcnVudGltZS9ldmFsLWV4cHInKTtcbi8vIHZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuLi9icm93c2VyL2luc2VydC1iZWZvcmUnKTtcblxuLyoqXG4gKiDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKDoioLngrlcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudEVsIOimgea3u+WKoOWIsOeahOeItuWFg+e0oFxuICogQHBhcmFtIHtIVE1MRWxlbWVudO+8nX0gYmVmb3JlRWwg6KaB5re75Yqg5Yiw5ZOq5Liq5YWD57Sg5LmL5YmNXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRBdHRhY2goZWxlbWVudCwgcGFyZW50RWwsIGJlZm9yZUVsKSB7XG4gICAgZWxlbWVudC5fY3JlYXRlKCk7XG4gICAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQuZWwsIHBhcmVudEVsLCBiZWZvcmVFbCk7XG5cbiAgICBpZiAoIWVsZW1lbnQuX2NvbnRlbnRSZWFkeSkge1xuICAgICAgICB2YXIgaHRtbERpcmVjdGl2ZSA9IGVsZW1lbnQuYU5vZGUuZGlyZWN0aXZlcy5odG1sO1xuXG4gICAgICAgIGlmIChodG1sRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBlbGVtZW50LmVsLmlubmVySFRNTCA9IGV2YWxFeHByKGh0bWxEaXJlY3RpdmUudmFsdWUsIGVsZW1lbnQuc2NvcGUsIGVsZW1lbnQub3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFOb2RlQ2hpbGRyZW4gPSBlbGVtZW50LmFOb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTm9kZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY3JlYXRlTm9kZShhTm9kZUNoaWxkcmVuW2ldLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmF0dGFjaChlbGVtZW50LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuX2NvbnRlbnRSZWFkeSA9IDE7XG4gICAgfVxufVxuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRBdHRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDlsIblhYPntKBhdHRhY2jliLDpobXpnaJcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuLy8gdmFyIGVsZW1lbnRBdHRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtYXR0YWNoJyk7XG5cbi8qKlxuICog5bCG5YWD57SgYXR0YWNo5Yiw6aG16Z2iXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50RWwg6KaB5re75Yqg5Yiw55qE54i25YWD57SgXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW5077ydfSBiZWZvcmVFbCDopoHmt7vliqDliLDlk6rkuKrlhYPntKDkuYvliY1cbiAqL1xuZnVuY3Rpb24gZWxlbWVudE93bkF0dGFjaChwYXJlbnRFbCwgYmVmb3JlRWwpIHtcbiAgICBpZiAoIXRoaXMubGlmZUN5Y2xlLmF0dGFjaGVkKSB7XG4gICAgICAgIGVsZW1lbnRBdHRhY2godGhpcywgcGFyZW50RWwsIGJlZm9yZUVsKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWQoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25BdHRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDojrflj5YgZWxlbWVudCDnmoQgdHJhbnNpdGlvbiDmjqfliLblr7nosaFcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBldmFsQXJncyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZXZhbC1hcmdzJyk7XG4vLyB2YXIgZmluZE1ldGhvZCA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZmluZC1tZXRob2QnKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG5cbi8qKlxuICog6I635Y+WIGVsZW1lbnQg55qEIHRyYW5zaXRpb24g5o6n5Yi25a+56LGhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQg5YWD57SgXG4gKiBAcmV0dXJuIHtPYmplY3Q/fVxuICovXG5mdW5jdGlvbiBlbGVtZW50R2V0VHJhbnNpdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGFOb2RlID0gZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ01QVCA/IGVsZW1lbnQuZ2l2ZW5BTm9kZSA6IGVsZW1lbnQuYU5vZGU7XG4gICAgdmFyIGRpcmVjdGl2ZSA9IGFOb2RlICYmIGFOb2RlLmRpcmVjdGl2ZXMudHJhbnNpdGlvbjtcbiAgICB2YXIgb3duZXIgPSBlbGVtZW50Lm93bmVyO1xuXG4gICAgdmFyIHRyYW5zaXRpb247XG4gICAgaWYgKGRpcmVjdGl2ZSAmJiBvd25lcikge1xuICAgICAgICB0cmFuc2l0aW9uID0gZmluZE1ldGhvZChvd25lciwgZGlyZWN0aXZlLnZhbHVlLm5hbWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uYXBwbHkoXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgZXZhbEFyZ3MoZGlyZWN0aXZlLnZhbHVlLmFyZ3MsIGVsZW1lbnQuc2NvcGUsIG93bmVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2l0aW9uIHx8IGVsZW1lbnQudHJhbnNpdGlvbjtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudEdldFRyYW5zaXRpb247XG5cblxuLyoqXG4gKiBAZmlsZSDlhYPntKDoioLngrnmiafooYxsZWF2ZeihjOS4ulxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVsZW1lbnRHZXRUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9lbGVtZW50LWdldC10cmFuc2l0aW9uJyk7XG5cblxuLyoqXG4gKiDlhYPntKDoioLngrnmiafooYxsZWF2ZeihjOS4ulxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOWFg+e0oFxuICovXG5mdW5jdGlvbiBlbGVtZW50TGVhdmUoZWxlbWVudCkge1xuICAgIHZhciBsaWZlQ3ljbGUgPSBlbGVtZW50LmxpZmVDeWNsZTtcbiAgICBpZiAobGlmZUN5Y2xlLmxlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmRpc3Bvc2VOb1RyYW5zaXRpb24pIHtcbiAgICAgICAgZWxlbWVudC5fZG9uZUxlYXZlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGVsZW1lbnRHZXRUcmFuc2l0aW9uKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHRyYW5zaXRpb24ubGVhdmUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuX3RvUGhhc2UoJ2xlYXZpbmcnKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWxlbWVudC5lbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuX2RvbmVMZWF2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50Ll9kb25lTGVhdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudExlYXZlO1xuXG5cbi8qKlxuICogQGZpbGUg5bCG5YWD57Sg5LuO6aG16Z2i5LiK56e76ZmkXG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWxlbWVudExlYXZlID0gcmVxdWlyZSgnLi9lbGVtZW50LWxlYXZlJyk7XG5cbi8qKlxuICog5bCG5YWD57Sg5LuO6aG16Z2i5LiK56e76ZmkXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25EZXRhY2goKSB7XG4gICAgZWxlbWVudExlYXZlKHRoaXMpO1xufVxuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnRPd25EZXRhY2g7XG5cblxuLyoqXG4gKiBAZmlsZSDplIDmr4Hph4rmlL7lhYPntKBcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlbGVtZW50TGVhdmUgPSByZXF1aXJlKCcuL2VsZW1lbnQtbGVhdmUnKTtcblxuLyoqXG4gKiDplIDmr4Hph4rmlL7lhYPntKBcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub0RldGFjaCDmmK/lkKbkuI3opoHmioroioLngrnku45kb23np7vpmaRcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVHJhbnNpdGlvbiDmmK/lkKbkuI3mmL7npLrov4fmuKHliqjnlLvmlYjmnpxcbiAqL1xuZnVuY3Rpb24gZWxlbWVudE93bkRpc3Bvc2Uobm9EZXRhY2gsIG5vVHJhbnNpdGlvbikge1xuICAgIHRoaXMubGVhdmVEaXNwb3NlID0gMTtcbiAgICB0aGlzLmRpc3Bvc2VOb0RldGFjaCA9IG5vRGV0YWNoO1xuICAgIHRoaXMuZGlzcG9zZU5vVHJhbnNpdGlvbiA9IG5vVHJhbnNpdGlvbjtcblxuICAgIGVsZW1lbnRMZWF2ZSh0aGlzKTtcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudE93bkRpc3Bvc2U7XG5cblxuLyoqXG4gKiBAZmlsZSDkuLrlhYPntKDnmoQgZWwg57uR5a6a5LqL5Lu2XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgb24gPSByZXF1aXJlKCcuLi9icm93c2VyL29uJyk7XG5cbi8qKlxuICog5Li65YWD57Sg55qEIGVsIOe7keWumuS6i+S7tlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOS6i+S7tuWQjVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNhcHR1cmUg5piv5ZCm5piv5o2V6I636Zi25q616Kem5Y+RXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRPd25PbkVsKG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYXB0dXJlID0gISFjYXB0dXJlO1xuICAgICAgICB0aGlzLl9lbEZucy5wdXNoKFtuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZV0pO1xuICAgICAgICBvbih0aGlzLmVsLCBuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgfVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50T3duT25FbDtcblxuXG4vKipcbiAqIEBmaWxlICDkuovku7bnu5HlrprkuI3lrZjlnKjnmoQgd2FybmluZ1xuICogQGF1dGhvciB2YXJzaGEod2FuZ3NodW9ucHVAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbi8vICNbYmVnaW5dIGVycm9yXG4vKipcbiAqIOS6i+S7tue7keWumuS4jeWtmOWcqOeahCB3YXJuaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QmluZCDkuovku7bnu5Hlrprlr7nosaFcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nmoTnu4Tku7blr7nosaFcbiAqL1xuZnVuY3Rpb24gd2FybkV2ZW50TGlzdGVuTWV0aG9kKGV2ZW50QmluZCwgb3duZXIpIHtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIHZhciBtZXRob2QgPSBvd25lcjtcbiAgICBlYWNoKGV2ZW50QmluZC5leHByLm5hbWUucGF0aHMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWV0aG9kID0gbWV0aG9kW3BhdGgudmFsdWVdO1xuICAgICAgICB2YWxpZCA9ICEhbWV0aG9kO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgICBlYWNoKGV2ZW50QmluZC5leHByLm5hbWUucGF0aHMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGgudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnW1NBTiBXQVJOSU5HXSAnICsgZXZlbnRCaW5kLm5hbWUgKyAnIGxpc3RlbiBmYWlsLFwiJyArIHBhdGhzLmpvaW4oJy4nKSArICdcIiBub3QgZXhpc3QnO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB9XG59XG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd2FybkV2ZW50TGlzdGVuTWV0aG9kO1xuXG5cbi8qKlxuICogQGZpbGUg5a6M5oiQ5YWD57SgIGF0dGFjaGVkIOWQjueahOihjOS4ulxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgYmluZCA9IHJlcXVpcmUoJy4uL3V0aWwvYmluZCcpO1xuLy8gdmFyIGVtcHR5ID0gcmVxdWlyZSgnLi4vdXRpbC9lbXB0eScpO1xuLy8gdmFyIGlzQnJvd3NlciA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaXMtYnJvd3NlcicpO1xuLy8gdmFyIHRyaWdnZXIgPSByZXF1aXJlKCcuLi9icm93c2VyL3RyaWdnZXInKTtcbi8vIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vbm9kZS10eXBlJyk7XG4vLyB2YXIgZWxlbWVudEdldFRyYW5zaXRpb24gPSByZXF1aXJlKCcuL2VsZW1lbnQtZ2V0LXRyYW5zaXRpb24nKTtcbi8vIHZhciBldmVudERlY2xhcmF0aW9uTGlzdGVuZXIgPSByZXF1aXJlKCcuL2V2ZW50LWRlY2xhcmF0aW9uLWxpc3RlbmVyJyk7XG4vLyB2YXIgZ2V0UHJvcEhhbmRsZXIgPSByZXF1aXJlKCcuL2dldC1wcm9wLWhhbmRsZXInKTtcbi8vIHZhciB3YXJuRXZlbnRMaXN0ZW5NZXRob2QgPSByZXF1aXJlKCcuL3dhcm4tZXZlbnQtbGlzdGVuLW1ldGhvZCcpO1xuXG4vKipcbiAqIOWPjOe7kei+k+WFpeahhkNvbXBvc2l0aW9uRW5k5LqL5Lu255uR5ZCs5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGlucHV0T25Db21wb3NpdGlvbkVuZCgpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvc2luZyA9IDA7XG5cbiAgICB0cmlnZ2VyKHRoaXMsICdpbnB1dCcpO1xufVxuXG4vKipcbiAqIOWPjOe7kei+k+WFpeahhkNvbXBvc2l0aW9uU3RhcnTkuovku7bnm5HlkKzlh73mlbBcbiAqXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaW5wdXRPbkNvbXBvc2l0aW9uU3RhcnQoKSB7XG4gICAgdGhpcy5jb21wb3NpbmcgPSAxO1xufVxuXG5mdW5jdGlvbiB4UHJvcE91dHB1dGVyKHhQcm9wLCBkYXRhKSB7XG4gICAgZ2V0UHJvcEhhbmRsZXIodGhpcy50YWdOYW1lLCB4UHJvcC5uYW1lKS5vdXRwdXQodGhpcywgeFByb3AsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBpbnB1dFhQcm9wT3V0cHV0ZXIoZWxlbWVudCwgeFByb3AsIGRhdGEpIHtcbiAgICB2YXIgb3V0cHV0ZXIgPSBiaW5kKHhQcm9wT3V0cHV0ZXIsIGVsZW1lbnQsIHhQcm9wLCBkYXRhKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgb3V0cHV0ZXIoZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIOWujOaIkOWFg+e0oCBhdHRhY2hlZCDlkI7nmoTooYzkuLpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCDlhYPntKDoioLngrlcbiAqL1xuZnVuY3Rpb24gZWxlbWVudE93bkF0dGFjaGVkKCkge1xuICAgIHRoaXMuX3RvUGhhc2UoJ2NyZWF0ZWQnKTtcblxuICAgIHZhciBpc0NvbXBvbmVudCA9IHRoaXMubm9kZVR5cGUgPT09IE5vZGVUeXBlLkNNUFQ7XG4gICAgdmFyIGRhdGEgPSBpc0NvbXBvbmVudCA/IHRoaXMuZGF0YSA6IHRoaXMuc2NvcGU7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuICAgIC8vIOWkhOeQhuiHqui6q+WPmOWMluaXtuWPjOWQkee7keWumueahOmAu+i+kVxuICAgIHZhciB4UHJvcHMgPSB0aGlzLmFOb2RlLmhvdHNwb3QueFByb3BzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0geFByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgeFByb3AgPSB4UHJvcHNbaV07XG5cbiAgICAgICAgc3dpdGNoICh4UHJvcC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyICYmIHdpbmRvdy5Db21wb3NpdGlvbkV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FbCgnY2hhbmdlJywgaW5wdXRPbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVsKCdjb21wb3NpdGlvbnN0YXJ0JywgaW5wdXRPbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRWwoJ2NvbXBvc2l0aW9uZW5kJywgaW5wdXRPbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJ29uaW5wdXQnIGluIHRoaXMuZWwpID8gJ2lucHV0JyA6ICdwcm9wZXJ0eWNoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRYUHJvcE91dHB1dGVyKHRoaXMsIHhQcm9wLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRWwoJ2NoYW5nZScsIGJpbmQoeFByb3BPdXRwdXRlciwgdGhpcywgeFByb3AsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmVsLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVsKCdjbGljaycsIGJpbmQoeFByb3BPdXRwdXRlciwgdGhpcywgeFByb3AsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiaW5kIGV2ZW50c1xuICAgIHZhciBldmVudHMgPSBpc0NvbXBvbmVudFxuICAgICAgICA/IHRoaXMuYU5vZGUuZXZlbnRzLmNvbmNhdCh0aGlzLm5hdGl2ZUV2ZW50cylcbiAgICAgICAgOiB0aGlzLmFOb2RlLmV2ZW50cztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgZXZlbnRCaW5kID0gZXZlbnRzW2ldO1xuICAgICAgICB2YXIgb3duZXIgPSBpc0NvbXBvbmVudCA/IHRoaXMgOiB0aGlzLm93bmVyO1xuXG4gICAgICAgIC8vIOWIpOaWreaYr+WQpuaYr25hdGl2ZUV2ZW5077yM5LiL6Z2i55qEd2FybuaWueazleWSjOS6i+S7tue7keWumumDvemcgOimgVxuICAgICAgICAvLyDkvp3mraTmjIflrppldmVudEJpbmQuZXhwci5uYW1l5L2N5LqOb3duZXLov5jmmK9vd25lci5vd25lcuS4ilxuICAgICAgICBpZiAoZXZlbnRCaW5kLm1vZGlmaWVyLm5hdGl2ZSkge1xuICAgICAgICAgICAgb3duZXIgPSBvd25lci5vd25lcjtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLnNjb3BlIHx8IG93bmVyLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgICAgICB3YXJuRXZlbnRMaXN0ZW5NZXRob2QoZXZlbnRCaW5kLCBvd25lcik7XG4gICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgIHRoaXMuX29uRWwoXG4gICAgICAgICAgICBldmVudEJpbmQubmFtZSxcbiAgICAgICAgICAgIGJpbmQoXG4gICAgICAgICAgICAgICAgZXZlbnREZWNsYXJhdGlvbkxpc3RlbmVyLFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIGV2ZW50QmluZCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBldmVudEJpbmQubW9kaWZpZXIuY2FwdHVyZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3RvUGhhc2UoJ2F0dGFjaGVkJyk7XG5cblxuICAgIGlmICh0aGlzLl9pc0luaXRGcm9tRWwpIHtcbiAgICAgICAgdGhpcy5faXNJbml0RnJvbUVsID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGVsZW1lbnRHZXRUcmFuc2l0aW9uKHRoaXMpO1xuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB0cmFuc2l0aW9uLmVudGVyKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKHRoaXMuZWwsIGVtcHR5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZWxlbWVudE93bkF0dGFjaGVkO1xuXG5cbi8qKlxuICogQGZpbGUg6ZSA5q+B5YWD57Sg6IqC54K5XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciB1biA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvdW4nKTtcbi8vIHZhciByZW1vdmVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcmVtb3ZlLWVsJyk7XG4vLyB2YXIgZWxlbWVudERpc3Bvc2VDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlLWNoaWxkcmVuJyk7XG4vLyB2YXIgbm9kZURpc3Bvc2UgPSByZXF1aXJlKCcuL25vZGUtZGlzcG9zZScpO1xuXG4vKipcbiAqIOmUgOavgeWFg+e0oOiKgueCuVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IOimgemUgOavgeeahOWFg+e0oOiKgueCuVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIOmUgOavgeihjOS4uueahOWPguaVsFxuICovXG5mdW5jdGlvbiBlbGVtZW50RGlzcG9zZShlbGVtZW50KSB7XG4gICAgZWxlbWVudERpc3Bvc2VDaGlsZHJlbihlbGVtZW50LCAxLCAxKTtcblxuICAgIC8vIGVsIOS6i+S7tuino+e7kVxuICAgIHZhciBsZW4gPSBlbGVtZW50Ll9lbEZucy5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIHZhciBmbiA9IGVsZW1lbnQuX2VsRm5zW2xlbl07XG4gICAgICAgIHVuKGVsZW1lbnQuZWwsIGZuWzBdLCBmblsxXSwgZm5bMl0pO1xuICAgIH1cbiAgICBlbGVtZW50Ll9lbEZucyA9IG51bGw7XG5cblxuICAgIC8vIOWmguaenOayoeaciXBhcmVudO+8jOivtOaYjuaYr+S4gOS4qnJvb3QgY29tcG9uZW5077yM5LiA5a6a6KaB5LuOZG9t5qCR5LitcmVtb3ZlXG4gICAgaWYgKCFlbGVtZW50LmRpc3Bvc2VOb0RldGFjaCB8fCAhZWxlbWVudC5wYXJlbnQpIHtcbiAgICAgICAgcmVtb3ZlRWwoZWxlbWVudC5lbCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX3RvUGhhc2UpIHtcbiAgICAgICAgZWxlbWVudC5fdG9QaGFzZSgnZGV0YWNoZWQnKTtcbiAgICB9XG5cbiAgICBub2RlRGlzcG9zZShlbGVtZW50KTtcbn1cblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50RGlzcG9zZTtcblxuXG4vKipcbiAqIEBmaWxlIOWIneWni+WMliBlbGVtZW50IOiKgueCueeahCB0YWdOYW1lIOWkhOeQhlxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGllT2xkVGhhbjkgPSByZXF1aXJlKCcuLi9icm93c2VyL2llLW9sZC10aGFuLTknKTtcblxuLyoqXG4gKiDliJ3lp4vljJYgZWxlbWVudCDoioLngrnnmoQgdGFnTmFtZSDlpITnkIZcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSDoioLngrnlr7nosaFcbiAqL1xuZnVuY3Rpb24gZWxlbWVudEluaXRUYWdOYW1lKG5vZGUpIHtcbiAgICBub2RlLnRhZ05hbWUgPSBub2RlLnRhZ05hbWUgfHwgbm9kZS5hTm9kZS50YWdOYW1lIHx8ICdkaXYnO1xuXG4gICAgLy8gI1tiZWdpbl0gYWxsdWFcbiAgICAvLyBpZTgtIOS4jeaUr+aMgWlubmVySFRNTOi+k+WHuuiHquWumuS5ieagh+etvlxuICAgIGlmIChpZU9sZFRoYW45ICYmIG5vZGUudGFnTmFtZS5pbmRleE9mKCctJykgPiAwKSB7XG4gICAgICAgIG5vZGUudGFnTmFtZSA9ICdkaXYnO1xuICAgIH1cbiAgICAvLyAjW2VuZF1cbn1cblxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50SW5pdFRhZ05hbWU7XG5cblxuLyoqXG4gKiBAZmlsZSDnu5kgZGV2dG9vbCDlj5HpgJrnn6Xmtojmga9cbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBpc0Jyb3dzZXIgPSByZXF1aXJlKCcuLi9icm93c2VyL2lzLWJyb3dzZXInKTtcblxuLy8gI1tiZWdpbl0gZGV2dG9vbFxudmFyIHNhbjRkZXZ0b29sO1xuXG4vKipcbiAqIOe7mSBkZXZ0b29sIOWPkemAmuefpea2iOaBr1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOa2iOaBr+WQjeensFxuICogQHBhcmFtIHsqfSBhcmcg5raI5oGv5Y+C5pWwXG4gKi9cbmZ1bmN0aW9uIGVtaXREZXZ0b29sKG5hbWUsIGFyZykge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgc2FuNGRldnRvb2wgJiYgc2FuNGRldnRvb2wuZGVidWcgJiYgd2luZG93Ll9fc2FuX2RldnRvb2xfXykge1xuICAgICAgICB3aW5kb3cuX19zYW5fZGV2dG9vbF9fLmVtaXQobmFtZSwgYXJnKTtcbiAgICB9XG59XG5cbmVtaXREZXZ0b29sLnN0YXJ0ID0gZnVuY3Rpb24gKG1haW4pIHtcbiAgICBzYW40ZGV2dG9vbCA9IG1haW47XG4gICAgZW1pdERldnRvb2woJ3NhbicsIG1haW4pO1xufTtcbi8vICNbZW5kXVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbWl0RGV2dG9vbDtcblxuXG4vKipcbiAqIEBmaWxlIOe7hOS7tuexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGJpbmQgPSByZXF1aXJlKCcuLi91dGlsL2JpbmQnKTtcbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG4vLyB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ3VpZCcpO1xuLy8gdmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXh0ZW5kJyk7XG4vLyB2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCcuLi91dGlsL25leHQtdGljaycpO1xuLy8gdmFyIGVtaXREZXZ0b29sID0gcmVxdWlyZSgnLi4vdXRpbC9lbWl0LWRldnRvb2wnKTtcbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9leHByLXR5cGUnKTtcbi8vIHZhciBwYXJzZUV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZXIvcGFyc2UtZXhwcicpO1xuLy8gdmFyIGNyZWF0ZUFjY2Vzc29yID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hY2Nlc3NvcicpO1xuLy8gdmFyIHBvc3RQcm9wID0gcmVxdWlyZSgnLi4vcGFyc2VyL3Bvc3QtcHJvcCcpO1xuLy8gdmFyIHJlbW92ZUVsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9yZW1vdmUtZWwnKTtcbi8vIHZhciBEYXRhID0gcmVxdWlyZSgnLi4vcnVudGltZS9kYXRhJyk7XG4vLyB2YXIgZXZhbEV4cHIgPSByZXF1aXJlKCcuLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gdmFyIGNoYW5nZUV4cHJDb21wYXJlID0gcmVxdWlyZSgnLi4vcnVudGltZS9jaGFuZ2UtZXhwci1jb21wYXJlJyk7XG4vLyB2YXIgY29tcGlsZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcGlsZS1jb21wb25lbnQnKTtcbi8vIHZhciBjb21wb25lbnRQcmVoZWF0ID0gcmVxdWlyZSgnLi9jb21wb25lbnQtcHJlaGVhdCcpO1xuLy8gdmFyIExpZmVDeWNsZSA9IHJlcXVpcmUoJy4vbGlmZS1jeWNsZScpO1xuLy8gdmFyIGdldEFOb2RlUHJvcCA9IHJlcXVpcmUoJy4vZ2V0LWEtbm9kZS1wcm9wJyk7XG4vLyB2YXIgaXNEYXRhQ2hhbmdlQnlFbGVtZW50ID0gcmVxdWlyZSgnLi9pcy1kYXRhLWNoYW5nZS1ieS1lbGVtZW50Jyk7XG4vLyB2YXIgZXZlbnREZWNsYXJhdGlvbkxpc3RlbmVyID0gcmVxdWlyZSgnLi9ldmVudC1kZWNsYXJhdGlvbi1saXN0ZW5lcicpO1xuLy8gdmFyIHJldmVyc2VFbGVtZW50Q2hpbGRyZW4gPSByZXF1aXJlKCcuL3JldmVyc2UtZWxlbWVudC1jaGlsZHJlbicpO1xuLy8gdmFyIGNhbWVsQ29tcG9uZW50QmluZHMgPSByZXF1aXJlKCcuL2NhbWVsLWNvbXBvbmVudC1iaW5kcycpO1xuLy8gdmFyIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9ub2RlLXR5cGUnKTtcbi8vIHZhciBlbGVtZW50SW5pdFRhZ05hbWUgPSByZXF1aXJlKCcuL2VsZW1lbnQtaW5pdC10YWctbmFtZScpO1xuLy8gdmFyIGVsZW1lbnRPd25BdHRhY2hlZCA9IHJlcXVpcmUoJy4vZWxlbWVudC1vd24tYXR0YWNoZWQnKTtcbi8vIHZhciBlbGVtZW50RGlzcG9zZSA9IHJlcXVpcmUoJy4vZWxlbWVudC1kaXNwb3NlJyk7XG4vLyB2YXIgZWxlbWVudFVwZGF0ZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LXVwZGF0ZS1jaGlsZHJlbicpO1xuLy8gdmFyIGVsZW1lbnRPd25PbkVsID0gcmVxdWlyZSgnLi9lbGVtZW50LW93bi1vbi1lbCcpO1xuLy8gdmFyIGVsZW1lbnRPd25DcmVhdGUgPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWNyZWF0ZScpO1xuLy8gdmFyIGVsZW1lbnRPd25BdHRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWF0dGFjaCcpO1xuLy8gdmFyIGVsZW1lbnRPd25EZXRhY2ggPSByZXF1aXJlKCcuL2VsZW1lbnQtb3duLWRldGFjaCcpO1xuLy8gdmFyIGVsZW1lbnRPd25EaXNwb3NlID0gcmVxdWlyZSgnLi9lbGVtZW50LW93bi1kaXNwb3NlJyk7XG4vLyB2YXIgd2FybkV2ZW50TGlzdGVuTWV0aG9kID0gcmVxdWlyZSgnLi93YXJuLWV2ZW50LWxpc3Rlbi1tZXRob2QnKTtcbi8vIHZhciBlbGVtZW50RGlzcG9zZUNoaWxkcmVuID0gcmVxdWlyZSgnLi9lbGVtZW50LWRpc3Bvc2UtY2hpbGRyZW4nKTtcbi8vIHZhciBlbGVtZW50QXR0YWNoID0gcmVxdWlyZSgnLi9lbGVtZW50LWF0dGFjaCcpO1xuLy8gdmFyIGhhbmRsZVByb3AgPSByZXF1aXJlKCcuL2hhbmRsZS1wcm9wJyk7XG4vLyB2YXIgY3JlYXRlRGF0YVR5cGVzQ2hlY2tlciA9IHJlcXVpcmUoJy4uL3V0aWwvY3JlYXRlLWRhdGEtdHlwZXMtY2hlY2tlcicpO1xuXG5cblxuLyoqXG4gKiDnu4Tku7bnsbtcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWIneWni+WMluWPguaVsFxuICovXG5mdW5jdGlvbiBDb21wb25lbnQob3B0aW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZS5zdGFydDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fZWxGbnMgPSBbXTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuc2xvdENoaWxkcmVuID0gW107XG5cbiAgICB2YXIgY2xhenogPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgdGhpcy5maWx0ZXJzID0gdGhpcy5maWx0ZXJzIHx8IGNsYXp6LmZpbHRlcnMgfHwge307XG4gICAgdGhpcy5jb21wdXRlZCA9IHRoaXMuY29tcHV0ZWQgfHwgY2xhenouY29tcHV0ZWQgfHwge307XG4gICAgdGhpcy5tZXNzYWdlcyA9IHRoaXMubWVzc2FnZXMgfHwgY2xhenoubWVzc2FnZXMgfHwge307XG4gICAgdGhpcy5zdWJUYWcgPSBvcHRpb25zLnN1YlRhZztcblxuICAgIC8vIGNvbXBpbGVcbiAgICBjb21waWxlQ29tcG9uZW50KGNsYXp6KTtcbiAgICBjb21wb25lbnRQcmVoZWF0KGNsYXp6KTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHByb3RvQU5vZGUgPSBjbGF6ei5wcm90b3R5cGUuYU5vZGU7XG5cbiAgICBtZS5naXZlbkFOb2RlID0gb3B0aW9ucy5hTm9kZTtcbiAgICBtZS5naXZlbk5hbWVkU2xvdEJpbmRzID0gW107XG4gICAgbWUuZ2l2ZW5TbG90cyA9IHtcbiAgICAgICAgbmFtZWQ6IHt9XG4gICAgfTtcblxuICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgIHRoaXMuc2NvcGUgPSBvcHRpb25zLnNjb3BlO1xuICAgIHRoaXMuZWwgPSBvcHRpb25zLmVsO1xuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50Q29tcG9uZW50ID0gcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlVHlwZS5DTVBUXG4gICAgICAgICAgICA/IHBhcmVudFxuICAgICAgICAgICAgOiBwYXJlbnQgJiYgcGFyZW50LnBhcmVudENvbXBvbmVudDtcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gZ3VpZCgpO1xuXG4gICAgLy8gI1tiZWdpbl0gcmV2ZXJzZVxuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgIHZhciBmaXJzdENvbW1lbnROb2RlID0gdGhpcy5lbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDb21tZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgZmlyc3RDb21tZW50Tm9kZSA9IGZpcnN0Q29tbWVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RDb21tZW50Tm9kZSAmJiBmaXJzdENvbW1lbnROb2RlLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICB2YXIgc3R1bXBNYXRjaCA9IGZpcnN0Q29tbWVudE5vZGUuZGF0YS5tYXRjaCgvXlxccypzLWRhdGE6KFtcXHNcXFNdKyk/JC8pO1xuICAgICAgICAgICAgaWYgKHN0dW1wTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R1bXBUZXh0ID0gc3R1bXBNYXRjaFsxXTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbGwgY29tcG9uZW50IGRhdGFcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAobmV3IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuICcgKyBzdHVtcFRleHQucmVwbGFjZSgvXltcXHNcXG5dKi8sICcnKVxuICAgICAgICAgICAgICAgICkpKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb21tZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWwoZmlyc3RDb21tZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVFbChmaXJzdENvbW1lbnROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjW2VuZF1cblxuICAgIC8vIG5hdGl2ZeS6i+S7tuaVsOe7hFxuICAgIHRoaXMubmF0aXZlRXZlbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5naXZlbkFOb2RlKSB7XG4gICAgICAgIC8vIOe7hOS7tui/kOihjOaXtuS8oOWFpeeahOe7k+aehO+8jOWBmnNsb3Top6PmnpBcbiAgICAgICAgdGhpcy5fY3JlYXRlR2l2ZW5TbG90cygpO1xuXG4gICAgICAgIGVhY2godGhpcy5naXZlbkFOb2RlLmV2ZW50cywgZnVuY3Rpb24gKGV2ZW50QmluZCkge1xuICAgICAgICAgICAgLy8g5L+d5a2Y5b2T5YmN5a6e5L6L55qEbmF0aXZl5LqL5Lu277yM5LiL6Z2i5Yib5bu6YU5vZGXml7blgJnlgZrlkIjlubZcbiAgICAgICAgICAgIGlmIChldmVudEJpbmQubW9kaWZpZXIubmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgbWUubmF0aXZlRXZlbnRzLnB1c2goZXZlbnRCaW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICNbYmVnaW5dIGVycm9yXG4gICAgICAgICAgICB3YXJuRXZlbnRMaXN0ZW5NZXRob2QoZXZlbnRCaW5kLCBvcHRpb25zLm93bmVyKTtcbiAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICBtZS5vbihcbiAgICAgICAgICAgICAgICBldmVudEJpbmQubmFtZSxcbiAgICAgICAgICAgICAgICBiaW5kKGV2ZW50RGVjbGFyYXRpb25MaXN0ZW5lciwgb3B0aW9ucy5vd25lciwgZXZlbnRCaW5kLCAxLCBvcHRpb25zLnNjb3BlKSxcbiAgICAgICAgICAgICAgICBldmVudEJpbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHByb3RvQU5vZGUudGFnTmFtZSB8fCBtZS5naXZlbkFOb2RlLnRhZ05hbWU7XG4gICAgICAgIHRoaXMuYmluZHMgPSBjYW1lbENvbXBvbmVudEJpbmRzKHRoaXMuZ2l2ZW5BTm9kZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdG9QaGFzZSgnY29tcGlsZWQnKTtcblxuICAgIC8vIGluaXQgZGF0YVxuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhKFxuICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5pbml0RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmluaXREYXRhKCkgfHwge30sXG4gICAgICAgICAgICBvcHRpb25zLmRhdGFcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICBlbGVtZW50SW5pdFRhZ05hbWUodGhpcyk7XG5cbiAgICBlYWNoKHRoaXMuYmluZHMsIGZ1bmN0aW9uIChiaW5kKSB7XG4gICAgICAgIHBvc3RQcm9wKGJpbmQpO1xuXG4gICAgICAgIGlmIChtZS5zY29wZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZhbEV4cHIoYmluZC5leHByLCBtZS5zY29wZSwgbWUub3duZXIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvc2FuL2lzc3Vlcy8xOTFcbiAgICAgICAgICAgICAgICBtZS5kYXRhLnNldChiaW5kLm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICAvLyDlnKjliJ3lp4vljJYgKyDmlbDmja7nu5HlrprlkI7vvIzlvIDlp4vmlbDmja7moKHpqoxcbiAgICAvLyBOT1RFOiDlj6rlnKjlvIDlj5HniYjmnKzkuK3ov5vooYzlsZ7mgKfmoKHpqoxcbiAgICB2YXIgZGF0YVR5cGVzID0gdGhpcy5kYXRhVHlwZXMgfHwgY2xhenouZGF0YVR5cGVzO1xuICAgIGlmIChkYXRhVHlwZXMpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlQ2hlY2tlciA9IGNyZWF0ZURhdGFUeXBlc0NoZWNrZXIoXG4gICAgICAgICAgICBkYXRhVHlwZXMsXG4gICAgICAgICAgICB0aGlzLnN1YlRhZyB8fCB0aGlzLm5hbWUgfHwgY2xhenoubmFtZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRhdGEuc2V0VHlwZUNoZWNrZXIoZGF0YVR5cGVDaGVja2VyKTtcbiAgICAgICAgdGhpcy5kYXRhLmNoZWNrRGF0YVR5cGVzKCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgdGhpcy5jb21wdXRlZERlcHMgPSB7fTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbiAgICBmb3IgKHZhciBleHByIGluIHRoaXMuY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXB1dGVkRGVwc1tleHByXSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY0NvbXB1dGVkKGV4cHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXG5cbiAgICBpZiAoIXRoaXMuZGF0YUNoYW5nZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlciA9IGJpbmQodGhpcy5fZGF0YUNoYW5nZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGEubGlzdGVuKHRoaXMuZGF0YUNoYW5nZXIpO1xuICAgIH1cbiAgICB0aGlzLl90b1BoYXNlKCdpbml0ZWQnKTtcblxuICAgIC8vICNbYmVnaW5dIHJldmVyc2VcbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICB0aGlzLl9hdHRhY2hlZCgpO1xuICAgIH1cblxuICAgIHZhciB3YWxrZXIgPSBvcHRpb25zLnJldmVyc2VXYWxrZXI7XG4gICAgaWYgKHdhbGtlcikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB3YWxrZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVsID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICB3YWxrZXIuZ29OZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnNlRWxlbWVudENoaWxkcmVuKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkKCk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxufVxuXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKGFOb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50c1thTm9kZS50YWdOYW1lXTtcbn07XG5cbi8qKlxuICog5Yid5aeL5YyW5Yib5bu657uE5Lu25aSW6YOo5Lyg5YWl55qE5o+S5qe95a+56LGhXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9jcmVhdGVHaXZlblNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUuZ2l2ZW5TbG90cy5uYW1lZCA9IHt9O1xuXG4gICAgLy8g57uE5Lu26L+Q6KGM5pe25Lyg5YWl55qE57uT5p6E77yM5YGac2xvdOino+aekFxuICAgIG1lLmdpdmVuQU5vZGUgJiYgbWUuc2NvcGUgJiYgZWFjaChtZS5naXZlbkFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgICB2YXIgc2xvdEJpbmQgPSAhY2hpbGQudGV4dEV4cHIgJiYgZ2V0QU5vZGVQcm9wKGNoaWxkLCAnc2xvdCcpO1xuICAgICAgICBpZiAoc2xvdEJpbmQpIHtcbiAgICAgICAgICAgICFtZS5naXZlblNsb3RJbml0ZWQgJiYgbWUuZ2l2ZW5OYW1lZFNsb3RCaW5kcy5wdXNoKHNsb3RCaW5kKTtcblxuICAgICAgICAgICAgdmFyIHNsb3ROYW1lID0gZXZhbEV4cHIoc2xvdEJpbmQuZXhwciwgbWUuc2NvcGUsIG1lLm93bmVyKTtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lLmdpdmVuU2xvdHMubmFtZWRbc2xvdE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZS5naXZlblNsb3RzLm5hbWVkW3Nsb3ROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFtZS5naXZlblNsb3RJbml0ZWQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG1lLmdpdmVuU2xvdHMubm9uYW1lO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtZS5naXZlblNsb3RzLm5vbmFtZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ICYmIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICB9KTtcblxuICAgIG1lLmdpdmVuU2xvdEluaXRlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIOexu+Wei+agh+ivhlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUubm9kZVR5cGUgPSBOb2RlVHlwZS5DTVBUO1xuXG4vKipcbiAqIOWcqOS4i+S4gOS4quabtOaWsOWRqOacn+i/kOihjOWHveaVsFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgei/kOihjOeahOWHveaVsFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qIGVzbGludC1kaXNhYmxlIG9wZXJhdG9yLWxpbmVicmVhayAqL1xuLyoqXG4gKiDkvb/oioLngrnliLDovr7nm7jlupTnmoTnlJ/lkb3lkajmnJ9cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDnlJ/lkb3lkajmnJ/lkI3np7BcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fY2FsbEhvb2sgPVxuQ29tcG9uZW50LnByb3RvdHlwZS5fdG9QaGFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxpZmVDeWNsZVtuYW1lXSkge1xuICAgICAgICB0aGlzLmxpZmVDeWNsZSA9IExpZmVDeWNsZVtuYW1lXSB8fCB0aGlzLmxpZmVDeWNsZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDpgJrnn6VkZXZ0b29sXG4gICAgICAgIC8vICNbYmVnaW5dIGRldnRvb2xcbiAgICAgICAgZW1pdERldnRvb2woJ2NvbXAtJyArIG5hbWUsIHRoaXMpO1xuICAgICAgICAvLyAjW2VuZF1cbiAgICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSBvcGVyYXRvci1saW5lYnJlYWsgKi9cblxuXG4vKipcbiAqIOa3u+WKoOS6i+S7tuebkeWQrOWZqFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOS6i+S7tuWQjVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gKiBAcGFyYW0ge3N0cmluZz99IGRlY2xhcmF0aW9uIOWjsOaYjuW8j1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXS5wdXNoKHtmbjogbGlzdGVuZXIsIGRlY2xhcmF0aW9uOiBkZWNsYXJhdGlvbn0pO1xuICAgIH1cbn07XG5cbi8qKlxuICog56e76Zmk5LqL5Lu255uR5ZCs5ZmoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5LqL5Lu25ZCNXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gbGlzdGVuZXIg55uR5ZCs5ZmoXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUudW4gPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbmFtZUxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW25hbWVdO1xuICAgIHZhciBsZW4gPSBuYW1lTGlzdGVuZXJzICYmIG5hbWVMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgbGlzdGVuZXIgPT09IG5hbWVMaXN0ZW5lcnNbbGVuXS5mbikge1xuICAgICAgICAgICAgbmFtZUxpc3RlbmVycy5zcGxpY2UobGVuLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiDmtL7lj5Hkuovku7ZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDkuovku7blkI1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBlYWNoKHRoaXMubGlzdGVuZXJzW25hbWVdLCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIuZm4uY2FsbChtZSwgZXZlbnQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiDorqHnrpcgY29tcHV0ZWQg5bGe5oCn55qE5YC8XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wdXRlZEV4cHIgY29tcHV0ZWTooajovr7lvI/kuLJcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fY2FsY0NvbXB1dGVkID0gZnVuY3Rpb24gKGNvbXB1dGVkRXhwcikge1xuICAgIHZhciBjb21wdXRlZERlcHMgPSB0aGlzLmNvbXB1dGVkRGVwc1tjb21wdXRlZEV4cHJdO1xuICAgIGlmICghY29tcHV0ZWREZXBzKSB7XG4gICAgICAgIGNvbXB1dGVkRGVwcyA9IHRoaXMuY29tcHV0ZWREZXBzW2NvbXB1dGVkRXhwcl0gPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEuc2V0KGNvbXB1dGVkRXhwciwgdGhpcy5jb21wdXRlZFtjb21wdXRlZEV4cHJdLmNhbGwoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBnZXQ6IGJpbmQoZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAvLyAjW2JlZ2luXSBlcnJvclxuICAgICAgICAgICAgICAgIGlmICghZXhwcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRVJST1JdIGNhbGwgZ2V0IG1ldGhvZCBpbiBjb21wdXRlZCBuZWVkIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICNbZW5kXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlZERlcHNbZXhwcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREZXBzW2V4cHJdID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wdXRlZFtleHByXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsY0NvbXB1dGVkKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXRjaChleHByLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxjQ29tcHV0ZWQoY29tcHV0ZWRFeHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZXhwcik7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICB9XG4gICAgfSkpO1xufTtcblxuLyoqXG4gKiDmtL7lj5Hmtojmga9cbiAqIOe7hOS7tuWPr+S7pea0vuWPkea2iOaBr++8jOa2iOaBr+Wwhuayv+edgOe7hOS7tuagkeWQkeS4iuS8oOmAku+8jOebtOWIsOmBh+S4iuesrOS4gOS4quWkhOeQhua2iOaBr+eahOe7hOS7tlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOa2iOaBr+WQjeensFxuICogQHBhcmFtIHsqP30gdmFsdWUg5raI5oGv5YC8XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcGFyZW50Q29tcG9uZW50ID0gdGhpcy5wYXJlbnRDb21wb25lbnQ7XG5cbiAgICB3aGlsZSAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHBhcmVudENvbXBvbmVudC5tZXNzYWdlc1tuYW1lXSB8fCBwYXJlbnRDb21wb25lbnQubWVzc2FnZXNbJyonXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWNlaXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVjZWl2ZXIuY2FsbChcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAge3RhcmdldDogdGhpcywgdmFsdWU6IHZhbHVlLCBuYW1lOiBuYW1lfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50Q29tcG9uZW50ID0gcGFyZW50Q29tcG9uZW50LnBhcmVudENvbXBvbmVudDtcbiAgICB9XG59O1xuXG4vKipcbiAqIOiOt+WPlue7hOS7tuWGhemDqOeahCBzbG90XG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHNsb3TlkI3np7DvvIznqbrkuLpkZWZhdWx0IHNsb3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNsb3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gY2hpbGRyZW5UcmF2ZXJzYWwoY2hpbGRyZW4pIHtcbiAgICAgICAgZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGVUeXBlLlNMT1QgJiYgY2hpbGQub3duZXIgPT09IG1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzTmFtZWQgJiYgY2hpbGQubmFtZSA9PT0gbmFtZVxuICAgICAgICAgICAgICAgICAgICB8fCAhY2hpbGQuaXNOYW1lZCAmJiAhbmFtZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5UcmF2ZXJzYWwoY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGlsZHJlblRyYXZlcnNhbCh0aGlzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiDojrflj5bluKbmnIkgc2FuLXJlZiDmjIfku6TnmoTlrZDnu4Tku7blvJXnlKhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDlrZDnu4Tku7bnmoTlvJXnlKjlkI1cbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByZWZUYXJnZXQ7XG4gICAgdmFyIG93bmVyID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGNoaWxkcmVuVHJhdmVyc2FsKGNoaWxkcmVuKSB7XG4gICAgICAgIGVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgZWxlbWVudFRyYXZlcnNhbChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gIXJlZlRhcmdldDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxlbWVudFRyYXZlcnNhbChlbGVtZW50KSB7XG4gICAgICAgIHZhciBub2RlVHlwZSA9IGVsZW1lbnQubm9kZVR5cGU7XG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gTm9kZVR5cGUuVEVYVCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQub3duZXIgPT09IG93bmVyKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5FTEVNOlxuICAgICAgICAgICAgICAgICAgICByZWYgPSBlbGVtZW50LmFOb2RlLmRpcmVjdGl2ZXMucmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmICYmIGV2YWxFeHByKHJlZi52YWx1ZSwgZWxlbWVudC5zY29wZSwgb3duZXIpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUYXJnZXQgPSBlbGVtZW50LmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5DTVBUOlxuICAgICAgICAgICAgICAgICAgICByZWYgPSBlbGVtZW50LmdpdmVuQU5vZGUuZGlyZWN0aXZlcy5yZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgJiYgZXZhbEV4cHIocmVmLnZhbHVlLCBlbGVtZW50LnNjb3BlLCBvd25lcikgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXJlZlRhcmdldCAmJiBjaGlsZHJlblRyYXZlcnNhbChlbGVtZW50LnNsb3RDaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICAhcmVmVGFyZ2V0ICYmIGNoaWxkcmVuVHJhdmVyc2FsKGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGNoaWxkcmVuVHJhdmVyc2FsKHRoaXMuY2hpbGRyZW4pO1xuXG4gICAgcmV0dXJuIHJlZlRhcmdldDtcbn07XG5cblxuLyoqXG4gKiDop4blm77mm7TmlrDlh73mlbBcbiAqXG4gKiBAcGFyYW0ge0FycmF5P30gY2hhbmdlcyDmlbDmja7lj5jljJbkv6Hmga9cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICBpZiAodGhpcy5saWZlQ3ljbGUuZGlzcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cblxuICAgIHZhciBuZWVkUmVsb2FkRm9yU2xvdCA9IGZhbHNlO1xuICAgIHRoaXMuX25vdGlmeU5lZWRSZWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5lZWRSZWxvYWRGb3JTbG90ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgZWFjaChjaGFuZ2VzLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlRXhwciA9IGNoYW5nZS5leHByO1xuXG4gICAgICAgICAgICBlYWNoKG1lLmJpbmRzLCBmdW5jdGlvbiAoYmluZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb247XG4gICAgICAgICAgICAgICAgdmFyIHNldEV4cHIgPSBiaW5kSXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVFeHByID0gYmluZEl0ZW0uZXhwcjtcblxuICAgICAgICAgICAgICAgIGlmICghaXNEYXRhQ2hhbmdlQnlFbGVtZW50KGNoYW5nZSwgbWUsIHNldEV4cHIpXG4gICAgICAgICAgICAgICAgICAgICYmIChyZWxhdGlvbiA9IGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZUV4cHIsIHVwZGF0ZUV4cHIsIG1lLnNjb3BlKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXhwciA9IGNyZWF0ZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXhwclR5cGUuU1RSSU5HLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNldEV4cHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KGNoYW5nZUV4cHIucGF0aHMuc2xpY2UodXBkYXRlRXhwci5wYXRocy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRXhwciA9IGNoYW5nZUV4cHI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhLnNldChzZXRFeHByLCBldmFsRXhwcih1cGRhdGVFeHByLCBtZS5zY29wZSwgbWUub3duZXIpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbWUub3duZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVhY2gobWUuZ2l2ZW5OYW1lZFNsb3RCaW5kcywgZnVuY3Rpb24gKGJpbmRJdGVtKSB7XG4gICAgICAgICAgICAgICAgbmVlZFJlbG9hZEZvclNsb3QgPSBuZWVkUmVsb2FkRm9yU2xvdCB8fCBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBiaW5kSXRlbS5leHByLCBtZS5zY29wZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuZWVkUmVsb2FkRm9yU2xvdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmVlZFJlbG9hZEZvclNsb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUdpdmVuU2xvdHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGFpbnRDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNsb3RDaGlsZHJlbkxlbiA9IHRoaXMuc2xvdENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChzbG90Q2hpbGRyZW5MZW4tLSkge1xuICAgICAgICAgICAgICAgIHZhciBzbG90Q2hpbGQgPSB0aGlzLnNsb3RDaGlsZHJlbltzbG90Q2hpbGRyZW5MZW5dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNsb3RDaGlsZC5saWZlQ3ljbGUuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG90Q2hpbGRyZW4uc3BsaWNlKHNsb3RDaGlsZHJlbkxlbiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RDaGlsZC5pc0luc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3RDaGlsZC5fdXBkYXRlKGNoYW5nZXMsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRhQ2hhbmdlcyA9IHRoaXMuZGF0YUNoYW5nZXM7XG4gICAgaWYgKGRhdGFDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZXMgPSBudWxsO1xuICAgICAgICBlYWNoKHRoaXMuYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBlYWNoKGRhdGFDaGFuZ2VzLCBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUV4cHJDb21wYXJlKGNoYW5nZS5leHByLCBwcm9wLmV4cHIsIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHx8IHByb3AuaGludEV4cHIgJiYgY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIHByb3AuaGludEV4cHIsIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVByb3AobWUsIGV2YWxFeHByKHByb3AuZXhwciwgbWUuZGF0YSwgbWUpLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50VXBkYXRlQ2hpbGRyZW4odGhpcywgZGF0YUNoYW5nZXMpO1xuICAgICAgICBpZiAobmVlZFJlbG9hZEZvclNsb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUdpdmVuU2xvdHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGFpbnRDaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9QaGFzZSgndXBkYXRlZCcpO1xuXG4gICAgICAgIGlmICh0aGlzLm93bmVyKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCaW5keE93bmVyKGRhdGFDaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMub3duZXIuX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5TmVlZFJlbG9hZCA9IG51bGw7XG59O1xuXG5Db21wb25lbnQucHJvdG90eXBlLl91cGRhdGVCaW5keE93bmVyID0gZnVuY3Rpb24gKGRhdGFDaGFuZ2VzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlmICh0aGlzLm93bmVyKSB7XG4gICAgICAgIGVhY2goZGF0YUNoYW5nZXMsIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIGVhY2gobWUuYmluZHMsIGZ1bmN0aW9uIChiaW5kSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VFeHByID0gY2hhbmdlLmV4cHI7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRJdGVtLnhcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRGF0YUNoYW5nZUJ5RWxlbWVudChjaGFuZ2UsIG1lLm93bmVyKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2VFeHByQ29tcGFyZShjaGFuZ2VFeHByLCBwYXJzZUV4cHIoYmluZEl0ZW0ubmFtZSksIG1lLmRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTY29wZUV4cHIgPSBiaW5kSXRlbS5leHByO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlRXhwci5wYXRocy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY29wZUV4cHIgPSBjcmVhdGVBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kSXRlbS5leHByLnBhdGhzLmNvbmNhdChjaGFuZ2VFeHByLnBhdGhzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLnNjb3BlLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNjb3BlRXhwcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxFeHByKGNoYW5nZUV4cHIsIG1lLmRhdGEsIG1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBiaW5kSXRlbS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOmHjeaWsOe7mOWItue7hOS7tueahOWGheWuuVxuICog5b2TIGR5bmFtaWMgc2xvdCBuYW1lIOWPkeeUn+WPmOabtOaIliBzbG90IOWMuemFjeWPkeeUn+WPmOWMluaXtu+8jOmHjeaWsOe7mOWItlxuICog5Zyo57uE5Lu257qn5Yir6YeN57uY5pyJ54K557KX5pq077yM5L2G5piv6IO95L+d6K+B6KeG5Zu+57uT5p6c5q2j56Gu5oCnXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuX3JlcGFpbnRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50RGlzcG9zZUNoaWxkcmVuKHRoaXMsIDAsIDEpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX2NvbnRlbnRSZWFkeSA9IDA7XG4gICAgdGhpcy5zbG90Q2hpbGRyZW4gPSBbXTtcbiAgICBlbGVtZW50QXR0YWNoKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIOe7hOS7tuWGhemDqOebkeWQrOaVsOaNruWPmOWMlueahOWHveaVsFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlIOaVsOaNruWPmOWMluS/oeaBr1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9kYXRhQ2hhbmdlciA9IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5saWZlQ3ljbGUucGFpbnRpbmcgfHwgdGhpcy5saWZlQ3ljbGUuY3JlYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YUNoYW5nZXMpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5saWZlQ3ljbGUuaW5pdGVkICYmIHRoaXMub3duZXIpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmluZHhPd25lcihbY2hhbmdlXSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIOebkeWQrOe7hOS7tueahOaVsOaNruWPmOWMllxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhTmFtZSDlj5jljJbnmoTmlbDmja7poblcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIOebkeWQrOWHveaVsFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGRhdGFOYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBkYXRhRXhwciA9IHBhcnNlRXhwcihkYXRhTmFtZSk7XG5cbiAgICB0aGlzLmRhdGEubGlzdGVuKGJpbmQoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICBpZiAoY2hhbmdlRXhwckNvbXBhcmUoY2hhbmdlLmV4cHIsIGRhdGFFeHByLCB0aGlzLmRhdGEpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2YWxFeHByKGRhdGFFeHByLCB0aGlzLmRhdGEsIHRoaXMpLCBjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiDnu4Tku7bplIDmr4HnmoTooYzkuLpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDplIDmr4HooYzkuLrnmoTlj4LmlbBcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZWxlbWVudE93bkRpc3Bvc2U7XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuX2RvbmVMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZWF2ZURpc3Bvc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpZmVDeWNsZS5kaXNwb3NlZCkge1xuICAgICAgICAgICAgLy8g6L+Z6YeM5LiN55So5oyo5Liq6LCD55SoIGRpc3Bvc2Ug5LqG77yM5Zug5Li6IGNoaWxkcmVuIOmHiuaUvumTvuS8muiwg+eUqOeahFxuICAgICAgICAgICAgdGhpcy5zbG90Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGEudW5saXN0ZW4oKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcyA9IG51bGw7XG5cbiAgICAgICAgICAgIGVsZW1lbnREaXNwb3NlKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTm9EZXRhY2gsXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTm9UcmFuc2l0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLmdpdmVuQU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5naXZlblNsb3RzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2l2ZW5OYW1lZFNsb3RCaW5kcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5saWZlQ3ljbGUuYXR0YWNoZWQpIHtcbiAgICAgICAgcmVtb3ZlRWwodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuX3RvUGhhc2UoJ2RldGFjaGVkJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDlrozmiJDnu4Tku7YgYXR0YWNoZWQg5ZCO55qE6KGM5Li6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQg5YWD57Sg6IqC54K5XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuX2F0dGFjaGVkID0gZWxlbWVudE93bkF0dGFjaGVkO1xuXG5Db21wb25lbnQucHJvdG90eXBlLmF0dGFjaCA9IGVsZW1lbnRPd25BdHRhY2g7XG5Db21wb25lbnQucHJvdG90eXBlLmRldGFjaCA9IGVsZW1lbnRPd25EZXRhY2g7XG5Db21wb25lbnQucHJvdG90eXBlLl9jcmVhdGUgPSBlbGVtZW50T3duQ3JlYXRlO1xuQ29tcG9uZW50LnByb3RvdHlwZS5fb25FbCA9IGVsZW1lbnRPd25PbkVsO1xuXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcblxuXG4vKipcbiAqIEBmaWxlIOWIm+W7uue7hOS7tuexu1xuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50Jyk7XG4vLyB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG5cbi8qKlxuICog5Yib5bu657uE5Lu257G7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIOe7hOS7tuexu+eahOaWueazleihqFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChwcm90bykge1xuICAgIC8vIOWmguaenOS8oOWFpeS4gOS4quS4jeaYryBzYW4gY29tcG9uZW50IOeahCBjb25zdHJ1Y3Rvcu+8jOebtOaOpei/lOWbnuS4jeaYr+e7hOS7tuaehOmAoOWHveaVsFxuICAgIC8vIOi/meenjeWcuuaZr+WvvOiHtOeahOmUmeivryBzYW4g5LiN5LqI6ICD6JmRXG4gICAgaWYgKHR5cGVvZiBwcm90byA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgfVxuXG4gICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICBpZiAodHlwZW9mIHByb3RvICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTQU4gRkFUQUxdIHBhcmFtIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIC8vICNbZW5kXVxuXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50Q2xhc3Mob3B0aW9uKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgQ29tcG9uZW50LmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICB9XG5cbiAgICBDb21wb25lbnRDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcbiAgICBpbmhlcml0cyhDb21wb25lbnRDbGFzcywgQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBDb21wb25lbnRDbGFzcztcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVmaW5lQ29tcG9uZW50O1xuXG5cbi8qKlxuICogQGZpbGUg57yW6K+R57uE5Lu257G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbi8vIHZhciBjcmVhdGVBTm9kZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9jcmVhdGUtYS1ub2RlJyk7XG4vLyB2YXIgcGFyc2VUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9wYXJzZS10ZW1wbGF0ZScpO1xuLy8gdmFyIHBhcnNlVGV4dCA9IHJlcXVpcmUoJy4uL3BhcnNlci9wYXJzZS10ZXh0Jyk7XG4vLyB2YXIgZGVmaW5lQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9kZWZpbmUtY29tcG9uZW50Jyk7XG5cblxuLyoqXG4gKiDnvJbor5Hnu4Tku7bnsbvjgILpooTop6PmnpB0ZW1wbGF0ZeWSjGNvbXBvbmVudHNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb21wb25lbnRDbGFzcyDnu4Tku7bnsbtcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUNvbXBvbmVudChDb21wb25lbnRDbGFzcykge1xuICAgIHZhciBwcm90byA9IENvbXBvbmVudENsYXNzLnByb3RvdHlwZTtcblxuICAgIC8vIHByZSBkZWZpbmUgY29tcG9uZW50cyBjbGFzc1xuICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ19jbXB0UmVhZHknKSkge1xuICAgICAgICBwcm90by5jb21wb25lbnRzID0gQ29tcG9uZW50Q2xhc3MuY29tcG9uZW50cyB8fCBwcm90by5jb21wb25lbnRzIHx8IHt9O1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IHByb3RvLmNvbXBvbmVudHM7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudENsYXNzID0gY29tcG9uZW50c1trZXldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNba2V5XSA9IGRlZmluZUNvbXBvbmVudChjb21wb25lbnRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRDbGFzcyA9PT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1trZXldID0gQ29tcG9uZW50Q2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm90by5fY21wdFJlYWR5ID0gMTtcbiAgICB9XG5cblxuICAgIC8vIHByZSBjb21waWxlIHRlbXBsYXRlXG4gICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnYU5vZGUnKSkge1xuICAgICAgICBwcm90by5hTm9kZSA9IGNyZWF0ZUFOb2RlKCk7XG5cbiAgICAgICAgdmFyIHRwbCA9IENvbXBvbmVudENsYXNzLnRlbXBsYXRlIHx8IHByb3RvLnRlbXBsYXRlO1xuICAgICAgICBpZiAodHBsKSB7XG4gICAgICAgICAgICB2YXIgYU5vZGUgPSBwYXJzZVRlbXBsYXRlKHRwbCwge1xuICAgICAgICAgICAgICAgIHRyaW1XaGl0ZXNwYWNlOiBwcm90by50cmltV2hpdGVzcGFjZSB8fCBDb21wb25lbnRDbGFzcy50cmltV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzOiBwcm90by5kZWxpbWl0ZXJzIHx8IENvbXBvbmVudENsYXNzLmRlbGltaXRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBhTm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgLy8gI1tiZWdpbl0gZXJyb3JcbiAgICAgICAgICAgIGlmIChhTm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgZmlyc3RDaGlsZC50ZXh0RXhwcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1NBTiBGQVRBTF0gdGVtcGxhdGUgbXVzdCBoYXZlIGEgcm9vdCBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gI1tlbmRdXG5cbiAgICAgICAgICAgIHByb3RvLmFOb2RlID0gZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChmaXJzdENoaWxkLnRhZ05hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLnRhZ05hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UHJvcEV4dHJhID0ge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtuYW1lOiAnY2xhc3MnLCBleHByOiBwYXJzZVRleHQoJ3t7Y2xhc3MgfCBfY2xhc3MgfCBfc2VwKFwiIFwiKX19Jyl9LFxuICAgICAgICAgICAgICAgICdzdHlsZSc6IHtuYW1lOiAnc3R5bGUnLCBleHByOiBwYXJzZVRleHQoJ3t7c3R5bGUgfCBfc3R5bGUgfCBfc2VwKFwiO1wiKX19Jyl9LFxuICAgICAgICAgICAgICAgICdpZCc6IHtuYW1lOiAnaWQnLCBleHByOiBwYXJzZVRleHQoJ3t7aWR9fScpfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGZpcnN0Q2hpbGQucHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBmaXJzdENoaWxkLnByb3BzW2xlbl07XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhID0gY29tcG9uZW50UHJvcEV4dHJhW3Byb3AubmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDaGlsZC5wcm9wcy5zcGxpY2UobGVuLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcEV4dHJhW3Byb3AubmFtZV0gPSBwcm9wO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm5hbWUgIT09ICdpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AuZXhwci5zZWdzLnB1c2goZXh0cmEuZXhwci5zZWdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AuZXhwci52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQucHJvcHMucHVzaChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wRXh0cmFbJ2NsYXNzJ10sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcEV4dHJhLnN0eWxlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BFeHRyYS5pZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29tcGlsZUNvbXBvbmVudDtcblxuXG4vKipcbiAqIEBmaWxlIOe7hOS7tumihOeDrVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIEV4cHJUeXBlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBjcmVhdGVFbCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvY3JlYXRlLWVsJyk7XG4vLyB2YXIgZ2V0UHJvcEhhbmRsZXIgPSByZXF1aXJlKCcuL2dldC1wcm9wLWhhbmRsZXInKTtcbi8vIHZhciBnZXRBTm9kZVByb3AgPSByZXF1aXJlKCcuL2dldC1hLW5vZGUtcHJvcCcpO1xuLy8gdmFyIGlzQnJvd3NlciA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvaXMtYnJvd3NlcicpO1xuXG4vKipcbiAqIOe7hOS7tumihOeDre+8jOWIhuaekOe7hOS7tmFOb2Rl55qE5pWw5o2u5byV55So562J5L+h5oGvXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudFByZWhlYXQoQ29tcG9uZW50Q2xhc3MpIHtcbiAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHJlY29yZEhvdHNwb3REYXRhKHJlZnMsIG5vdENvbnRlbnREYXRhKSB7XG4gICAgICAgIHZhciBsZW4gPSBzdGFjay5sZW5ndGg7XG4gICAgICAgIGVhY2goc3RhY2ssIGZ1bmN0aW9uIChhTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghbm90Q29udGVudERhdGEgfHwgaW5kZXggIT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBlYWNoKHJlZnMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5kYXRhW3JlZl0gPSAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFuYWx5c2VBTm9kZUhvdHNwb3QoYU5vZGUpIHtcbiAgICAgICAgaWYgKCFhTm9kZS5ob3RzcG90KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFOb2RlKTtcblxuXG4gICAgICAgICAgICBpZiAoYU5vZGUudGV4dEV4cHIpIHtcbiAgICAgICAgICAgICAgICBhTm9kZS5ob3RzcG90ID0ge2RhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICByZWNvcmRIb3RzcG90RGF0YShhbmFseXNlRXhwckRhdGFIb3RzcG90KGFOb2RlLnRleHRFeHByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyICYmIGFOb2RlLnRhZ05hbWUgJiYgIS9eKHRlbXBsYXRlfHNsb3R8c2VsZWN0fGlucHV0fG9wdGlvbikkL2kudGVzdChhTm9kZS50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlID0gY3JlYXRlRWwoYU5vZGUudGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wczogW10sXG4gICAgICAgICAgICAgICAgICAgIHhQcm9wczogW10sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZTogc291cmNlTm9kZVxuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIC8vID09PSBhbmFseXNlIGhvdHNwb3QgZGF0YTogc3RhcnRcbiAgICAgICAgICAgICAgICBlYWNoKGFOb2RlLnZhcnMsIGZ1bmN0aW9uICh2YXJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEhvdHNwb3REYXRhKGFuYWx5c2VFeHByRGF0YUhvdHNwb3QodmFySXRlbS5leHByKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlYWNoKGFOb2RlLnByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRIb3RzcG90RGF0YShhbmFseXNlRXhwckRhdGFIb3RzcG90KHByb3AuZXhwcikpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFOb2RlLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IGFOb2RlLmRpcmVjdGl2ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkSG90c3BvdERhdGEoYW5hbHlzZUV4cHJEYXRhSG90c3BvdChkaXJlY3RpdmUudmFsdWUpLCBrZXkgIT09ICdodG1sJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXG5cbiAgICAgICAgICAgICAgICBlYWNoKGFOb2RlLmVsc2VzLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5hbHlzZUFOb2RlSG90c3BvdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlYWNoKGFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5hbHlzZUFOb2RlSG90c3BvdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gPT09IGFuYWx5c2UgaG90c3BvdCBkYXRhOiBlbmRcblxuXG4gICAgICAgICAgICAgICAgLy8gPT09IGFuYWx5c2UgaG90c3BvdCBwcm9wczogc3RhcnRcbiAgICAgICAgICAgICAgICBlYWNoKGFOb2RlLnByb3BzLCBmdW5jdGlvbiAocHJvcCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5wcm9wc1twcm9wLm5hbWVdID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AubmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC5pZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhTm9kZS5ob3RzcG90LmlkUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBhTm9kZS5ob3RzcG90LmR5bmFtaWNQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3AuZXhwci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3BIYW5kbGVyKGFOb2RlLnRhZ05hbWUsIHByb3AubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3Aoc291cmNlTm9kZSwgcHJvcC5leHByLnZhbHVlLCBwcm9wLm5hbWUsIGFOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTm9kZS5ob3RzcG90LnhQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gaWUg5LiL77yM5aaC5p6cIG9wdGlvbiDmsqHmnIkgdmFsdWUg5bGe5oCn77yMc2VsZWN0LnZhbHVlID0geHgg5pON5L2c5LiN5Lya6YCJ5LitIG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIOaJgOS7peayoeacieiuvue9riB2YWx1ZSDml7bvvIzpu5jorqTmioogb3B0aW9uIOeahOWGheWuueS9nOS4uiB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChhTm9kZS50YWdOYW1lID09PSAnb3B0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAmJiAhZ2V0QU5vZGVQcm9wKGFOb2RlLCAndmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAmJiBhTm9kZS5jaGlsZHJlblswXVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVQcm9wID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHI6IGFOb2RlLmNoaWxkcmVuWzBdLnRleHRFeHByXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlLnByb3BzLnB1c2godmFsdWVQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgYU5vZGUuaG90c3BvdC5keW5hbWljUHJvcHMucHVzaCh2YWx1ZVByb3ApO1xuICAgICAgICAgICAgICAgICAgICBhTm9kZS5ob3RzcG90LnByb3BzLnZhbHVlID0gYU5vZGUucHJvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPT09IGFuYWx5c2UgaG90c3BvdCBwcm9wczogZW5kXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYW5hbHlzZUFOb2RlSG90c3BvdChDb21wb25lbnRDbGFzcy5wcm90b3R5cGUuYU5vZGUpO1xufVxuXG4vKipcbiAqIOWIhuaekOihqOi+vuW8j+eahOaVsOaNruW8leeUqFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByIOimgeWIhuaekOeahOihqOi+vuW8j1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFuYWx5c2VFeHByRGF0YUhvdHNwb3QoZXhwcikge1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmdW5jdGlvbiBhbmFseXNlRXhwcnMoZXhwcnMpIHtcbiAgICAgICAgZWFjaChleHBycywgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHJlZnMgPSByZWZzLmNvbmNhdChhbmFseXNlRXhwckRhdGFIb3RzcG90KGV4cHIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBFeHByVHlwZS5BQ0NFU1NPUjpcbiAgICAgICAgICAgIHZhciBwYXRocyA9IGV4cHIucGF0aHM7XG4gICAgICAgICAgICByZWZzLnB1c2gocGF0aHNbMF0udmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAocGF0aHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaChwYXRoc1swXS52YWx1ZSArICcuJyArIChwYXRoc1sxXS52YWx1ZSB8fCAnKicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5hbHlzZUV4cHJzKHBhdGhzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuVU5BUlk6XG4gICAgICAgICAgICByZXR1cm4gYW5hbHlzZUV4cHJEYXRhSG90c3BvdChleHByLmV4cHIpO1xuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuVEVYVDpcbiAgICAgICAgY2FzZSBFeHByVHlwZS5CSU5BUlk6XG4gICAgICAgIGNhc2UgRXhwclR5cGUuVEVSVElBUlk6XG4gICAgICAgICAgICBhbmFseXNlRXhwcnMoZXhwci5zZWdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRXhwclR5cGUuSU5URVJQOlxuICAgICAgICAgICAgcmVmcyA9IGFuYWx5c2VFeHByRGF0YUhvdHNwb3QoZXhwci5leHByKTtcblxuICAgICAgICAgICAgZWFjaChleHByLmZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBhbmFseXNlRXhwcnMoZmlsdGVyLm5hbWUucGF0aHMpO1xuICAgICAgICAgICAgICAgIGFuYWx5c2VFeHBycyhmaWx0ZXIuYXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50UHJlaGVhdDtcblxuXG4vKipcbiAqIEBmaWxlIOWwhiBiaW5kcyDnmoQgbmFtZSDku44ga2ViYWJjYXNlIOi9rOaNouaIkCBjYW1lbGNhc2VcbiAqIEBhdXRob3IgZXJyb3JyaWsoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8vIHZhciBrZWJhYjJjYW1lbCA9IHJlcXVpcmUoJy4uL3V0aWwva2ViYWIyY2FtZWwnKTtcbi8vIHZhciBlYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbi8qKlxuICog5bCGIGJpbmRzIOeahCBuYW1lIOS7jiBrZWJhYmNhc2Ug6L2s5o2i5oiQIGNhbWVsY2FzZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpbmRzIGJpbmRz6ZuG5ZCIXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gY2FtZWxDb21wb25lbnRCaW5kcyhiaW5kcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoKGJpbmRzLCBmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBrZWJhYjJjYW1lbChiaW5kLm5hbWUpLFxuICAgICAgICAgICAgZXhwcjogYmluZC5leHByLFxuICAgICAgICAgICAgeDogYmluZC54LFxuICAgICAgICAgICAgcmF3OiBiaW5kLnJhd1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ29tcG9uZW50QmluZHM7XG5cblxuLyoqXG4gKiBAZmlsZSDnvJbor5HmupDnoIHnmoQgaGVscGVyIOaWueazlembhuWQiFxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLy8gdmFyIGVhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcbi8vIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4uL3BhcnNlci9leHByLXR5cGUnKTtcblxuLy8gI1tiZWdpbl0gc3NyXG4vLyBcbi8vIC8qKlxuLy8gICog57yW6K+R5rqQ56CB55qEIGhlbHBlciDmlrnms5Xpm4blkIjlr7nosaFcbi8vICAqL1xuLy8gdmFyIGNvbXBpbGVFeHByU291cmNlID0ge1xuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog5a2X56ym5Liy5a2X6Z2i5YyWXG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIOmcgOimgeWtl+mdouWMlueahOWtl+espuS4slxuLy8gICAgICAqIEByZXR1cm4ge3N0cmluZ30g5a2X56ym5Liy5a2X6Z2i5YyW57uT5p6cXG4vLyAgICAgICovXG4vLyAgICAgc3RyaW5nTGl0ZXJhbGl6ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICByZXR1cm4gJ1wiJ1xuLy8gICAgICAgICAgICAgKyBzb3VyY2Vcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4NUMvZywgJ1xcXFxcXFxcJylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG4vLyAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xceDBBL2csICdcXFxcbicpXG4vLyAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA5L2csICdcXFxcdCcpXG4vLyAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xceDBEL2csICdcXFxccicpXG4vLyAgICAgICAgICAgICAgICAgLy8gLnJlcGxhY2UoIC9cXHgwOC9nLCAnXFxcXGInIClcbi8vICAgICAgICAgICAgICAgICAvLyAucmVwbGFjZSggL1xceDBDL2csICdcXFxcZicgKVxuLy8gICAgICAgICAgICAgKyAnXCInO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnlJ/miJDmlbDmja7orr/pl67ooajovr7lvI/ku6PnoIFcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7T2JqZWN0P30gYWNjZXNzb3JFeHByIGFjY2Vzc29y6KGo6L6+5byP5a+56LGhXG4vLyAgICAgICogQHJldHVybiB7c3RyaW5nfVxuLy8gICAgICAqL1xuLy8gICAgIGRhdGFBY2Nlc3M6IGZ1bmN0aW9uIChhY2Nlc3NvckV4cHIpIHtcbi8vICAgICAgICAgdmFyIGNvZGUgPSAnY29tcG9uZW50Q3R4LmRhdGEnO1xuLy8gICAgICAgICBpZiAoYWNjZXNzb3JFeHByKSB7XG4vLyAgICAgICAgICAgICBlYWNoKGFjY2Vzc29yRXhwci5wYXRocywgZnVuY3Rpb24gKHBhdGgpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAocGF0aC50eXBlID09PSBFeHByVHlwZS5BQ0NFU1NPUikge1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2RlICs9ICdbJyArIGNvbXBpbGVFeHByU291cmNlLmRhdGFBY2Nlc3MocGF0aCkgKyAnXSc7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwYXRoLnZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlICs9ICcuJyArIHBhdGgudmFsdWU7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29kZSArPSAnWycgKyBwYXRoLnZhbHVlICsgJ10nO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICByZXR1cm4gY29kZTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog55Sf5oiQ5o+S5YC85Luj56CBXG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW50ZXJwRXhwciDmj5LlgLzooajovr7lvI/lr7nosaFcbi8vICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgICAgICovXG4vLyAgICAgaW50ZXJwOiBmdW5jdGlvbiAoaW50ZXJwRXhwcikge1xuLy8gICAgICAgICB2YXIgY29kZSA9IGNvbXBpbGVFeHByU291cmNlLmV4cHIoaW50ZXJwRXhwci5leHByKTtcbi8vIFxuLy8gXG4vLyAgICAgICAgIGVhY2goaW50ZXJwRXhwci5maWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7XG4vLyAgICAgICAgICAgICBjb2RlID0gJ2NvbXBvbmVudEN0eC5jYWxsRmlsdGVyKFwiJyArIGZpbHRlci5uYW1lLnBhdGhzWzBdLnZhbHVlICsgJ1wiLCBbJyArIGNvZGU7XG4vLyAgICAgICAgICAgICBlYWNoKGZpbHRlci5hcmdzLCBmdW5jdGlvbiAoYXJnKSB7XG4vLyAgICAgICAgICAgICAgICAgY29kZSArPSAnLCAnICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihhcmcpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBjb2RlICs9ICddKSc7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIGlmICghaW50ZXJwRXhwci5vcmlnaW5hbCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuICdlc2NhcGVIVE1MKCcgKyBjb2RlICsgJyknO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIGNvZGU7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOeUn+aIkOaWh+acrOeJh+auteS7o+eggVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRFeHByIOaWh+acrOeJh+auteihqOi+vuW8j+WvueixoVxuLy8gICAgICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAgICAgKi9cbi8vICAgICB0ZXh0OiBmdW5jdGlvbiAodGV4dEV4cHIpIHtcbi8vICAgICAgICAgaWYgKHRleHRFeHByLnNlZ3MubGVuZ3RoID09PSAwKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gJ1wiXCInO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIGNvZGUgPSAnJztcbi8vIFxuLy8gICAgICAgICBlYWNoKHRleHRFeHByLnNlZ3MsIGZ1bmN0aW9uIChzZWcpIHtcbi8vICAgICAgICAgICAgIHZhciBzZWdDb2RlID0gY29tcGlsZUV4cHJTb3VyY2UuZXhwcihzZWcpO1xuLy8gICAgICAgICAgICAgY29kZSArPSBjb2RlID8gJyArICcgKyBzZWdDb2RlIDogc2VnQ29kZTtcbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIGNvZGU7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOS6jOWFg+ihqOi+vuW8j+aTjeS9nOespuaYoOWwhOihqFxuLy8gICAgICAqXG4vLyAgICAgICogQHR5cGUge09iamVjdH1cbi8vICAgICAgKi9cbi8vICAgICBiaW5hcnlPcDoge1xuLy8gICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gICAgICAgICA0MzogJysnLFxuLy8gICAgICAgICA0NTogJy0nLFxuLy8gICAgICAgICA0MjogJyonLFxuLy8gICAgICAgICA0NzogJy8nLFxuLy8gICAgICAgICA2MDogJzwnLFxuLy8gICAgICAgICA2MjogJz4nLFxuLy8gICAgICAgICA3NjogJyYmJyxcbi8vICAgICAgICAgOTQ6ICchPScsXG4vLyAgICAgICAgIDEyMTogJzw9Jyxcbi8vICAgICAgICAgMTIyOiAnPT0nLFxuLy8gICAgICAgICAxMjM6ICc+PScsXG4vLyAgICAgICAgIDE1NTogJyE9PScsXG4vLyAgICAgICAgIDE4MzogJz09PScsXG4vLyAgICAgICAgIDI0ODogJ3x8J1xuLy8gICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOeUn+aIkOihqOi+vuW8j+S7o+eggVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byP5a+56LGhXG4vLyAgICAgICogQHJldHVybiB7c3RyaW5nfVxuLy8gICAgICAqL1xuLy8gICAgIGV4cHI6IGZ1bmN0aW9uIChleHByKSB7XG4vLyAgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLlVOQVJZOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiAnIScgKyBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIuZXhwcik7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuQklOQVJZOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIuc2Vnc1swXSlcbi8vICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5iaW5hcnlPcFtleHByLm9wZXJhdG9yXVxuLy8gICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoZXhwci5zZWdzWzFdKTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSBFeHByVHlwZS5URVJUSUFSWTpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2UuZXhwcihleHByLnNlZ3NbMF0pXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJz8nICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihleHByLnNlZ3NbMV0pXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJzonICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihleHByLnNlZ3NbMl0pO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLlNUUklORzpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2Uuc3RyaW5nTGl0ZXJhbGl6ZShleHByLmxpdGVyYWwgfHwgZXhwci52YWx1ZSk7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgRXhwclR5cGUuTlVNQkVSOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLkJPT0w6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLkFDQ0VTU09SOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5kYXRhQWNjZXNzKGV4cHIpO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLklOVEVSUDpcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2UuaW50ZXJwKGV4cHIpO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlIEV4cHJUeXBlLlRFWFQ6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVFeHByU291cmNlLnRleHQoZXhwcik7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVFeHByU291cmNlO1xuXG5cbi8qKlxuICogQGZpbGUg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVy57G7XG4gKiBAYXV0aG9yIGVycm9ycmlrKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGNvbXBpbGVFeHByU291cmNlID0gcmVxdWlyZSgnLi9jb21waWxlLWV4cHItc291cmNlJyk7XG5cblxuLy8gI1tiZWdpbl0gc3NyXG4vLyAvKipcbi8vICAqIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlcuexu1xuLy8gICpcbi8vICAqIEBjbGFzc1xuLy8gICovXG4vLyBmdW5jdGlvbiBDb21waWxlU291cmNlQnVmZmVyKCkge1xuLy8gICAgIHRoaXMuc2VncyA9IFtdO1xuLy8gfVxuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoOWOn+Wni+S7o+egge+8jOWwhuWOn+WwgeS4jeWKqOi+k+WHulxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIOWOn+Wni+S7o+eggVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5hZGRSYXcgPSBmdW5jdGlvbiAoY29kZSkge1xuLy8gICAgIHRoaXMuc2Vncy5wdXNoKHtcbi8vICAgICAgICAgdHlwZTogJ1JBVycsXG4vLyAgICAgICAgIGNvZGU6IGNvZGVcbi8vICAgICB9KTtcbi8vIH07XG4vLyBcbi8vIC8qKlxuLy8gICog5re75Yqg6KKr5ou85o6l5Li6aHRtbOeahOWOn+Wni+S7o+eggVxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIOWOn+Wni+S7o+eggVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5qb2luUmF3ID0gZnVuY3Rpb24gKGNvZGUpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX1JBVycsXG4vLyAgICAgICAgIGNvZGU6IGNvZGVcbi8vICAgICB9KTtcbi8vIH07XG4vLyBcbi8vIC8qKlxuLy8gICog5re75YqgcmVuZGVyZXLmlrnms5XnmoTotbflp4vmupDnoIFcbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYWRkUmVuZGVyZXJTdGFydCA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aGlzLmFkZFJhdygnZnVuY3Rpb24gKGRhdGEsIHBhcmVudEN0eCwgZ2l2ZW5TbG90cykgeycpO1xuLy8gICAgIHRoaXMuYWRkUmF3KCd2YXIgaHRtbCA9IFwiXCI7Jyk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoHJlbmRlcmVy5pa55rOV55qE57uT5p2f5rqQ56CBXG4vLyAgKi9cbi8vIENvbXBpbGVTb3VyY2VCdWZmZXIucHJvdG90eXBlLmFkZFJlbmRlcmVyRW5kID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHRoaXMuYWRkUmF3KCdyZXR1cm4gaHRtbDsnKTtcbi8vICAgICB0aGlzLmFkZFJhdygnfScpO1xuLy8gfTtcbi8vIFxuLy8gLyoqXG4vLyAgKiDmt7vliqDooqvmi7zmjqXkuLpodG1s55qE6Z2Z5oCB5a2X56ym5LiyXG4vLyAgKlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IHN0ciDooqvmi7zmjqXnmoTlrZfnrKbkuLJcbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuam9pblN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHN0cjogc3RyLFxuLy8gICAgICAgICB0eXBlOiAnSk9JTl9TVFJJTkcnXG4vLyAgICAgfSk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOa3u+WKoOiiq+aLvOaOpeS4umh0bWznmoTmlbDmja7orr/pl65cbi8vICAqXG4vLyAgKiBAcGFyYW0ge09iamVjdD99IGFjY2Vzc29yIOaVsOaNruiuv+mXruihqOi+vuW8j+WvueixoVxuLy8gICovXG4vLyBDb21waWxlU291cmNlQnVmZmVyLnByb3RvdHlwZS5qb2luRGF0YVN0cmluZ2lmeSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX0RBVEFfU1RSSU5HSUZZJ1xuLy8gICAgIH0pO1xuLy8gfTtcbi8vIFxuLy8gLyoqXG4vLyAgKiDmt7vliqDooqvmi7zmjqXkuLpodG1s55qE6KGo6L6+5byPXG4vLyAgKlxuLy8gICogQHBhcmFtIHtPYmplY3R9IGV4cHIg6KGo6L6+5byP5a+56LGhXG4vLyAgKi9cbi8vIENvbXBpbGVTb3VyY2VCdWZmZXIucHJvdG90eXBlLmpvaW5FeHByID0gZnVuY3Rpb24gKGV4cHIpIHtcbi8vICAgICB0aGlzLnNlZ3MucHVzaCh7XG4vLyAgICAgICAgIGV4cHI6IGV4cHIsXG4vLyAgICAgICAgIHR5cGU6ICdKT0lOX0VYUFInXG4vLyAgICAgfSk7XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe8luivkeWQjuS7o+eggVxuLy8gICpcbi8vICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAqL1xuLy8gQ29tcGlsZVNvdXJjZUJ1ZmZlci5wcm90b3R5cGUudG9Db2RlID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBjb2RlID0gW107XG4vLyAgICAgdmFyIHRlbXAgPSAnJztcbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGdlblN0ckxpdGVyYWwoKSB7XG4vLyAgICAgICAgIGlmICh0ZW1wKSB7XG4vLyAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gJyArIGNvbXBpbGVFeHByU291cmNlLnN0cmluZ0xpdGVyYWxpemUodGVtcCkgKyAnOycpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdGVtcCA9ICcnO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGVhY2godGhpcy5zZWdzLCBmdW5jdGlvbiAoc2VnKSB7XG4vLyAgICAgICAgIGlmIChzZWcudHlwZSA9PT0gJ0pPSU5fU1RSSU5HJykge1xuLy8gICAgICAgICAgICAgdGVtcCArPSBzZWcuc3RyO1xuLy8gICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgZ2VuU3RyTGl0ZXJhbCgpO1xuLy8gICAgICAgICBzd2l0Y2ggKHNlZy50eXBlKSB7XG4vLyAgICAgICAgICAgICBjYXNlICdKT0lOX0RBVEFfU1RSSU5HSUZZJzpcbi8vICAgICAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gc3RyaW5naWZpZXIuYW55KCcgKyBjb21waWxlRXhwclNvdXJjZS5kYXRhQWNjZXNzKCkgKyAnKTsnKTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnSk9JTl9FWFBSJzpcbi8vICAgICAgICAgICAgICAgICBjb2RlLnB1c2goJ2h0bWwgKz0gJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoc2VnLmV4cHIpICsgJzsnKTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnSk9JTl9SQVcnOlxuLy8gICAgICAgICAgICAgICAgIGNvZGUucHVzaCgnaHRtbCArPSAnICsgc2VnLmNvZGUgKyAnOycpO1xuLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlICdSQVcnOlxuLy8gICAgICAgICAgICAgICAgIGNvZGUucHVzaChzZWcuY29kZSk7XG4vLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyBcbi8vICAgICAgICAgfVxuLy8gICAgIH0pO1xuLy8gXG4vLyAgICAgZ2VuU3RyTGl0ZXJhbCgpO1xuLy8gXG4vLyAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4vLyB9O1xuLy8gXG4vLyAjW2VuZF1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29tcGlsZVNvdXJjZUJ1ZmZlcjtcblxuXG4vKipcbiAqIEBmaWxlIOWwhue7hOS7tue8luivkeaIkCByZW5kZXIg5pa55rOV55qEIGpzIOa6kOeggVxuICogQGF1dGhvciBlcnJvcnJpayhlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4vLyB2YXIgZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuLy8gdmFyIGd1aWQgPSByZXF1aXJlKCcuLi91dGlsL2d1aWQnKTtcbi8vIHZhciBwYXJzZUV4cHIgPSByZXF1aXJlKCcuLi9wYXJzZXIvcGFyc2UtZXhwcicpO1xuLy8gdmFyIGNyZWF0ZUFOb2RlID0gcmVxdWlyZSgnLi4vcGFyc2VyL2NyZWF0ZS1hLW5vZGUnKTtcbi8vIHZhciBjbG9uZURpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9wYXJzZXIvY2xvbmUtZGlyZWN0aXZlcycpO1xuLy8gdmFyIGF1dG9DbG9zZVRhZ3MgPSByZXF1aXJlKCcuLi9icm93c2VyL2F1dG8tY2xvc2UtdGFncycpO1xuLy8gdmFyIENvbXBpbGVTb3VyY2VCdWZmZXIgPSByZXF1aXJlKCcuL2NvbXBpbGUtc291cmNlLWJ1ZmZlcicpO1xuLy8gdmFyIGNvbXBpbGVFeHByU291cmNlID0gcmVxdWlyZSgnLi9jb21waWxlLWV4cHItc291cmNlJyk7XG4vLyB2YXIgcmluc2VDb25kQU5vZGUgPSByZXF1aXJlKCcuL3JpbnNlLWNvbmQtYW5vZGUnKTtcbi8vIHZhciBnZXRBTm9kZVByb3AgPSByZXF1aXJlKCcuL2dldC1hLW5vZGUtcHJvcCcpO1xuXG4vLyAjW2JlZ2luXSBzc3Jcbi8vIFxuLy8gLyoqXG4vLyAgKiDnlJ/miJDluo/liJfljJbml7botbflp4vmoannmoRodG1sXG4vLyAgKlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5qGp57G75Z6L5qCH6K+GXG4vLyAgKiBAcGFyYW0ge3N0cmluZz99IGNvbnRlbnQg5qGp5YaF55qE5YaF5a65XG4vLyAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHNlcmlhbGl6ZVN0dW1wKHR5cGUsIGNvbnRlbnQpIHtcbi8vICAgICByZXR1cm4gJzwhLS1zLScgKyB0eXBlICsgKGNvbnRlbnQgPyAnOicgKyBjb250ZW50IDogJycpICsgJy0tPic7XG4vLyB9XG4vLyBcbi8vIC8qKlxuLy8gICog55Sf5oiQ5bqP5YiX5YyW5pe257uT5p2f5qGp55qEaHRtbFxuLy8gICpcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOahqeexu+Wei+agh+ivhlxuLy8gICogQHJldHVybiB7c3RyaW5nfVxuLy8gICovXG4vLyBmdW5jdGlvbiBzZXJpYWxpemVTdHVtcEVuZCh0eXBlKSB7XG4vLyAgICAgcmV0dXJuICc8IS0tL3MtJyArIHR5cGUgKyAnLS0+Jztcbi8vIH1cbi8vIFxuLy8gLyoqXG4vLyAgKiBlbGVtZW50IOeahOe8luivkeaWueazlembhuWQiOWvueixoVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICovXG4vLyB2YXIgZWxlbWVudFNvdXJjZUNvbXBpbGVyID0ge1xuLy8gXG4vLyAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LXBhcmFtcyAqL1xuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeWFg+e0oOagh+etvuWktFxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUg5qCH562+5ZCNXG4vLyAgICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMg5bGe5oCn5YiX6KGoXG4vLyAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBleHRyYVByb3Ag6aKd5aSW55qE5bGe5oCn5LiyXG4vLyAgICAgICogQHBhcmFtIHtib29sZWFuP30gaXNDbG9zZSDmmK/lkKbpl63lkIhcbi8vICAgICAgKi9cbi8vICAgICB0YWdTdGFydDogZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlciwgdGFnTmFtZSwgcHJvcHMsIGV4dHJhUHJvcCwgaXNDbG9zZSkge1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnPCcgKyB0YWdOYW1lKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoZXh0cmFQcm9wIHx8ICcnKTtcbi8vIFxuLy8gICAgICAgICAvLyBpbmRleCBsaXN0XG4vLyAgICAgICAgIHZhciBwcm9wc0luZGV4ID0ge307XG4vLyAgICAgICAgIGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4vLyAgICAgICAgICAgICBwcm9wc0luZGV4W3Byb3AubmFtZV0gPSBwcm9wO1xuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICBlYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuLy8gICAgICAgICAgICAgaWYgKHByb3AubmFtZSA9PT0gJ3Nsb3QnKSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICBpZiAocHJvcC5uYW1lID09PSAndmFsdWUnKSB7XG4vLyAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWdOYW1lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJHNlbGVjdFZhbHVlID0gJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIHx8IFwiXCI7J1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlICdvcHRpb24nOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJG9wdGlvblZhbHVlID0gJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihwcm9wLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnOydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnaWYgKCRvcHRpb25WYWx1ZSAhPSBudWxsKSB7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblJhdygnXCIgdmFsdWU9XFxcXFwiXCIgKyAkb3B0aW9uVmFsdWUgKyBcIlxcXFxcIlwiJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdpZiAoJG9wdGlvblZhbHVlID09PSAkc2VsZWN0VmFsdWUpIHsnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKCcgc2VsZWN0ZWQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIHN3aXRjaCAocHJvcC5uYW1lKSB7XG4vLyAgICAgICAgICAgICAgICAgY2FzZSAncmVhZG9ubHknOlxuLy8gICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbi8vICAgICAgICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnJhdyA9PT0gJycpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKCcgJyArIHByb3AubmFtZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblJhdygnYm9vbEF0dHJGaWx0ZXIoXCInICsgcHJvcC5uYW1lICsgJ1wiLCAnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHByb3AuZXhwcilcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcpJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0Jykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHByb3BzSW5kZXgudmFsdWU7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVDb2RlID0gY29tcGlsZUV4cHJTb3VyY2UuZXhwcih2YWx1ZVByb3AuZXhwcik7XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVByb3ApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BzSW5kZXgudHlwZS5yYXcpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnaWYgKGNvbnRhaW5zKCdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGNvbXBpbGVFeHByU291cmNlLmV4cHIocHJvcC5leHByKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJywgJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgdmFsdWVDb2RlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnKSkgeydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnIGNoZWNrZWQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2lmICgnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHByb3AuZXhwcilcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgPT09ICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHZhbHVlQ29kZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJykgeydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnIGNoZWNrZWQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIFxuLy8gICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLmF0dHIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKCcgJyArIHByb3AuYXR0cik7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuam9pblJhdygnYXR0ckZpbHRlcihcIicgKyBwcm9wLm5hbWUgKyAnXCIsICdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChwcm9wLnggPyAnZXNjYXBlSFRNTCgnIDogJycpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHByb3AuZXhwcilcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChwcm9wLnggPyAnKScgOiAnJylcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcpJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoaXNDbG9zZSA/ICcvPicgOiAnPicpO1xuLy8gICAgIH0sXG4vLyAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtcGFyYW1zICovXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5HlhYPntKDpl63lkIhcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIOagh+etvuWQjVxuLy8gICAgICAqL1xuLy8gICAgIHRhZ0VuZDogZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlciwgdGFnTmFtZSkge1xuLy8gICAgICAgICBpZiAoIWF1dG9DbG9zZVRhZ3NbdGFnTmFtZV0pIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKCc8LycgKyB0YWdOYW1lICsgJz4nKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIGlmICh0YWdOYW1lID09PSAnc2VsZWN0Jykge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJHNlbGVjdFZhbHVlID0gbnVsbDsnKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJG9wdGlvblZhbHVlID0gbnVsbDsnKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5HlhYPntKDlhoXlrrlcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOWFg+e0oOeahOaKveixoeiKgueCueS/oeaBr1xuLy8gICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7blrp7kvovnjq/looNcbi8vICAgICAgKi9cbi8vICAgICBpbm5lcjogZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlciwgYU5vZGUsIG93bmVyKSB7XG4vLyAgICAgICAgIC8vIGlubmVyIGNvbnRlbnRcbi8vICAgICAgICAgaWYgKGFOb2RlLnRhZ05hbWUgPT09ICd0ZXh0YXJlYScpIHtcbi8vICAgICAgICAgICAgIHZhciB2YWx1ZVByb3AgPSBnZXRBTm9kZVByb3AoYU5vZGUsICd2YWx1ZScpO1xuLy8gICAgICAgICAgICAgaWYgKHZhbHVlUHJvcCkge1xuLy8gICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luUmF3KCdlc2NhcGVIVE1MKCdcbi8vICAgICAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHZhbHVlUHJvcC5leHByKVxuLy8gICAgICAgICAgICAgICAgICAgICArICcpJ1xuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybjtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHZhciBodG1sRGlyZWN0aXZlID0gYU5vZGUuZGlyZWN0aXZlcy5odG1sO1xuLy8gICAgICAgICBpZiAoaHRtbERpcmVjdGl2ZSkge1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5FeHByKGh0bWxEaXJlY3RpdmUudmFsdWUpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbi8vICAgICAgICAgICAgIGVhY2goYU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChhTm9kZUNoaWxkKSB7XG4vLyAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhhTm9kZUNvbXBpbGVyLmNvbXBpbGUoYU5vZGVDaGlsZCwgc291cmNlQnVmZmVyLCBvd25lcikpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIEFOb2RlIOeahOe8luivkeaWueazlembhuWQiOWvueixoVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICovXG4vLyB2YXIgYU5vZGVDb21waWxlciA9IHtcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkeiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg5oq96LGh6IqC54K5XG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSDnvJbor5HmiYDpnIDnmoTkuIDkupvpop3lpJbkv6Hmga9cbi8vICAgICAgKi9cbi8vICAgICBjb21waWxlOiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlciwgb3duZXIsIGV4dHJhKSB7XG4vLyAgICAgICAgIGV4dHJhID0gZXh0cmEgfHwge307XG4vLyAgICAgICAgIHZhciBjb21waWxlTWV0aG9kID0gJ2NvbXBpbGVFbGVtZW50Jztcbi8vIFxuLy8gICAgICAgICBpZiAoYU5vZGUudGV4dEV4cHIpIHtcbi8vICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZVRleHQnO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2UgaWYgKGFOb2RlLmRpcmVjdGl2ZXNbJ2lmJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbi8vICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZUlmJztcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIGlmIChhTm9kZS5kaXJlY3RpdmVzWydmb3InXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuLy8gICAgICAgICAgICAgY29tcGlsZU1ldGhvZCA9ICdjb21waWxlRm9yJztcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIGlmIChhTm9kZS50YWdOYW1lID09PSAnc2xvdCcpIHtcbi8vICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZVNsb3QnO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2UgaWYgKGFOb2RlLnRhZ05hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbi8vICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZVRlbXBsYXRlJztcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgIHZhciBDb21wb25lbnRUeXBlID0gb3duZXIuZ2V0Q29tcG9uZW50VHlwZShhTm9kZSk7XG4vLyAgICAgICAgICAgICBpZiAoQ29tcG9uZW50VHlwZSkge1xuLy8gICAgICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSAnY29tcGlsZUNvbXBvbmVudCc7XG4vLyAgICAgICAgICAgICAgICAgZXh0cmEuQ29tcG9uZW50Q2xhc3MgPSBDb21wb25lbnRUeXBlO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgYU5vZGVDb21waWxlcltjb21waWxlTWV0aG9kXShhTm9kZSwgc291cmNlQnVmZmVyLCBvd25lciwgZXh0cmEpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5HmlofmnKzoioLngrlcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOiKgueCueWvueixoVxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVUZXh0OiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlcikge1xuLy8gICAgICAgICBpZiAoYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKHNlcmlhbGl6ZVN0dW1wKCd0ZXh0JykpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5FeHByKGFOb2RlLnRleHRFeHByKTtcbi8vIFxuLy8gICAgICAgICBpZiAoYU5vZGUudGV4dEV4cHIub3JpZ2luYWwpIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luU3RyaW5nKHNlcmlhbGl6ZVN0dW1wRW5kKCd0ZXh0JykpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIOe8luivkXRlbXBsYXRl6IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDoioLngrnlr7nosaFcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICovXG4vLyAgICAgY29tcGlsZVRlbXBsYXRlOiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlciwgb3duZXIpIHtcbi8vICAgICAgICAgZWxlbWVudFNvdXJjZUNvbXBpbGVyLmlubmVyKHNvdXJjZUJ1ZmZlciwgYU5vZGUsIG93bmVyKTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog57yW6K+RIGlmIOiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg6IqC54K55a+56LGhXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVJZjogZnVuY3Rpb24gKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyKSB7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyhmdW5jdGlvbiAoKSB7Jyk7XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyIGlmSW5kZXggPSBudWxsOycpO1xuLy8gXG4vLyAgICAgICAgIC8vIG91dHB1dCBtYWluIGlmXG4vLyAgICAgICAgIHZhciBpZkRpcmVjdGl2ZSA9IGFOb2RlLmRpcmVjdGl2ZXNbJ2lmJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2lmICgnICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihpZkRpcmVjdGl2ZS52YWx1ZSkgKyAnKSB7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoXG4vLyAgICAgICAgICAgICBhTm9kZUNvbXBpbGVyLmNvbXBpbGUoXG4vLyAgICAgICAgICAgICAgICAgcmluc2VDb25kQU5vZGUoYU5vZGUpLFxuLy8gICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlcixcbi8vICAgICAgICAgICAgICAgICBvd25lclxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyBcbi8vICAgICAgICAgLy8gb3V0cHV0IGVsaWYgYW5kIGVsc2Vcbi8vICAgICAgICAgZWFjaChhTm9kZS5lbHNlcywgZnVuY3Rpb24gKGVsc2VBTm9kZSwgaW5kZXgpIHtcbi8vICAgICAgICAgICAgIHZhciBlbGlmRGlyZWN0aXZlID0gZWxzZUFOb2RlLmRpcmVjdGl2ZXMuZWxpZjtcbi8vICAgICAgICAgICAgIGlmIChlbGlmRGlyZWN0aXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZWxzZSBpZiAoJyArIGNvbXBpbGVFeHByU291cmNlLmV4cHIoZWxpZkRpcmVjdGl2ZS52YWx1ZSkgKyAnKSB7Jyk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdlbHNlIHsnKTtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhcbi8vICAgICAgICAgICAgICAgICBhTm9kZUNvbXBpbGVyLmNvbXBpbGUoXG4vLyAgICAgICAgICAgICAgICAgICAgIHJpbnNlQ29uZEFOb2RlKGVsc2VBTm9kZSksXG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlcixcbi8vICAgICAgICAgICAgICAgICAgICAgb3duZXJcbi8vICAgICAgICAgICAgICAgICApXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gICAgICAgICB9KTtcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9KSgpOycpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5EgZm9yIOiKgueCuVxuLy8gICAgICAqXG4vLyAgICAgICogQHBhcmFtIHtBTm9kZX0gYU5vZGUg6IqC54K55a+56LGhXG4vLyAgICAgICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIOaJgOWxnue7hOS7tuWunuS+i+eOr+Wig1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVGb3I6IGZ1bmN0aW9uIChhTm9kZSwgc291cmNlQnVmZmVyLCBvd25lcikge1xuLy8gICAgICAgICB2YXIgZm9yRWxlbWVudEFOb2RlID0gY3JlYXRlQU5vZGUoe1xuLy8gICAgICAgICAgICAgY2hpbGRyZW46IGFOb2RlLmNoaWxkcmVuLFxuLy8gICAgICAgICAgICAgcHJvcHM6IGFOb2RlLnByb3BzLFxuLy8gICAgICAgICAgICAgZXZlbnRzOiBhTm9kZS5ldmVudHMsXG4vLyAgICAgICAgICAgICB0YWdOYW1lOiBhTm9kZS50YWdOYW1lLFxuLy8gICAgICAgICAgICAgZGlyZWN0aXZlczogY2xvbmVEaXJlY3RpdmVzKGFOb2RlLmRpcmVjdGl2ZXMsIHtcbi8vICAgICAgICAgICAgICAgICAnZm9yJzogMVxuLy8gICAgICAgICAgICAgfSksXG4vLyAgICAgICAgICAgICBob3RzcG90OiBhTm9kZS5ob3RzcG90XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHZhciBmb3JEaXJlY3RpdmUgPSBhTm9kZS5kaXJlY3RpdmVzWydmb3InXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbi8vICAgICAgICAgdmFyIGl0ZW1OYW1lID0gZm9yRGlyZWN0aXZlLml0ZW0ucmF3O1xuLy8gICAgICAgICB2YXIgaW5kZXhOYW1lID0gZm9yRGlyZWN0aXZlLmluZGV4LnJhdztcbi8vICAgICAgICAgdmFyIGxpc3ROYW1lID0gY29tcGlsZUV4cHJTb3VyY2UuZGF0YUFjY2Vzcyhmb3JEaXJlY3RpdmUudmFsdWUpO1xuLy8gXG4vLyAgICAgICAgIGlmIChpbmRleE5hbWUgPT09ICckaW5kZXgnKSB7XG4vLyAgICAgICAgICAgICBpbmRleE5hbWUgPSBndWlkKCk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdmb3IgKCdcbi8vICAgICAgICAgICAgICsgJ3ZhciAnICsgaW5kZXhOYW1lICsgJyA9IDA7ICdcbi8vICAgICAgICAgICAgICsgaW5kZXhOYW1lICsgJyA8ICcgKyBsaXN0TmFtZSArICcubGVuZ3RoOyAnXG4vLyAgICAgICAgICAgICArIGluZGV4TmFtZSArICcrKykgeydcbi8vICAgICAgICAgKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnY29tcG9uZW50Q3R4LmRhdGEuJyArIGluZGV4TmFtZSArICc9JyArIGluZGV4TmFtZSArICc7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2NvbXBvbmVudEN0eC5kYXRhLicgKyBpdGVtTmFtZSArICc9ICcgKyBsaXN0TmFtZSArICdbJyArIGluZGV4TmFtZSArICddOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KFxuLy8gICAgICAgICAgICAgYU5vZGVDb21waWxlci5jb21waWxlKFxuLy8gICAgICAgICAgICAgICAgIGZvckVsZW1lbnRBTm9kZSxcbi8vICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIsXG4vLyAgICAgICAgICAgICAgICAgb3duZXJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5Egc2xvdCDoioLngrlcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOiKgueCueWvueixoVxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7blrp7kvovnjq/looNcbi8vICAgICAgKi9cbi8vICAgICBjb21waWxlU2xvdDogZnVuY3Rpb24gKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyKSB7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyhmdW5jdGlvbiAoKSB7Jyk7XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZnVuY3Rpb24gJGRlZmF1bHRTbG90UmVuZGVyKGNvbXBvbmVudEN0eCkgeycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIHZhciBodG1sID0gXCJcIjsnKTtcbi8vICAgICAgICAgZWFjaChhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGFOb2RlQ2hpbGQpIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoYU5vZGVDb21waWxlci5jb21waWxlKGFOb2RlQ2hpbGQsIHNvdXJjZUJ1ZmZlciwgb3duZXIpKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgcmV0dXJuIGh0bWw7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30nKTtcbi8vIFxuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIHZhciAkZ2l2ZW5TbG90ID0gW107Jyk7XG4vLyBcbi8vICAgICAgICAgdmFyIG5hbWVQcm9wID0gZ2V0QU5vZGVQcm9wKGFOb2RlLCAnbmFtZScpO1xuLy8gICAgICAgICBpZiAobmFtZVByb3ApIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAkc2xvdE5hbWUgPSAnICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihuYW1lUHJvcC5leHByKSArICc7Jyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd2YXIgJHNsb3ROYW1lID0gbnVsbDsnKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAkY3R4R2l2ZW5TbG90cyA9IGNvbXBvbmVudEN0eC5naXZlblNsb3RzOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdmb3IgKHZhciAkaSA9IDA7ICRpIDwgJGN0eEdpdmVuU2xvdHMubGVuZ3RoOyAkaSsrKSB7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgaWYgKCRjdHhHaXZlblNsb3RzWyRpXVsxXSA9PSAkc2xvdE5hbWUpIHsnKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICAgICRnaXZlblNsb3QucHVzaCgkY3R4R2l2ZW5TbG90c1skaV1bMF0pOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIH0nKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyICRpc0luc2VydGVkID0gJGdpdmVuU2xvdC5sZW5ndGggPiAwOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCdpZiAoISRpc0luc2VydGVkKSB7ICRnaXZlblNsb3QucHVzaCgkZGVmYXVsdFNsb3RSZW5kZXIpOyB9Jyk7XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyICRzbG90Q3R4ID0gJGlzSW5zZXJ0ZWQgPyBjb21wb25lbnRDdHgub3duZXIgOiBjb21wb25lbnRDdHg7Jyk7XG4vLyAgICAgICAgIGlmIChhTm9kZS52YXJzKSB7XG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckc2xvdEN0eCA9IHtkYXRhOiBleHRlbmQoe30sICRzbG90Q3R4LmRhdGEpLCBmaWx0ZXJzOiAkc2xvdEN0eC5maWx0ZXJzLCBjYWxsRmlsdGVyOiAkc2xvdEN0eC5jYWxsRmlsdGVyfTsnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLy8gICAgICAgICAgICAgZWFjaChhTm9kZS52YXJzLCBmdW5jdGlvbiAodmFySXRlbSkge1xuLy8gICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoXG4vLyAgICAgICAgICAgICAgICAgICAgICckc2xvdEN0eC5kYXRhW1wiJyArIHZhckl0ZW0ubmFtZSArICdcIl0gPSAnXG4vLyAgICAgICAgICAgICAgICAgICAgICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcih2YXJJdGVtLmV4cHIpXG4vLyAgICAgICAgICAgICAgICAgICAgICsgJzsnXG4vLyAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZm9yICh2YXIgJHJlbmRlckluZGV4ID0gMDsgJHJlbmRlckluZGV4IDwgJGdpdmVuU2xvdC5sZW5ndGg7ICRyZW5kZXJJbmRleCsrKSB7Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgaHRtbCArPSAkZ2l2ZW5TbG90WyRyZW5kZXJJbmRleF0oJHNsb3RDdHgpOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCd9Jyk7XG4vLyBcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfSkoKTsnKTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICog57yW6K+R5pmu6YCa6IqC54K5XG4vLyAgICAgICpcbi8vICAgICAgKiBAcGFyYW0ge0FOb2RlfSBhTm9kZSDoioLngrnlr7nosaFcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTb3VyY2VCdWZmZXJ9IHNvdXJjZUJ1ZmZlciDnvJbor5HmupDnoIHnmoTkuK3pl7RidWZmZXJcbi8vICAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIg5omA5bGe57uE5Lu25a6e5L6L546v5aKDXG4vLyAgICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIOe8luivkeaJgOmcgOeahOS4gOS6m+mineWkluS/oeaBr1xuLy8gICAgICAqL1xuLy8gICAgIGNvbXBpbGVFbGVtZW50OiBmdW5jdGlvbiAoYU5vZGUsIHNvdXJjZUJ1ZmZlciwgb3duZXIsIGV4dHJhKSB7XG4vLyAgICAgICAgIGV4dHJhID0gZXh0cmEgfHwge307XG4vLyAgICAgICAgIC8vIGlmIChhTm9kZS50YWdOYW1lID09PSAnb3B0aW9uJ1xuLy8gICAgICAgICAvLyAgICAgJiYgIWdldEFOb2RlUHJvcChhTm9kZSwgJ3ZhbHVlJylcbi8vICAgICAgICAgLy8gICAgICYmIGFOb2RlLmNoaWxkcmVuWzBdXG4vLyAgICAgICAgIC8vICkge1xuLy8gICAgICAgICAvLyAgICAgYU5vZGUucHJvcHMucHVzaCh7XG4vLyAgICAgICAgIC8vICAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbi8vICAgICAgICAgLy8gICAgICAgICBleHByOiBhTm9kZS5jaGlsZHJlblswXS50ZXh0RXhwclxuLy8gICAgICAgICAvLyAgICAgfSk7XG4vLyAgICAgICAgIC8vIH1cbi8vIFxuLy8gICAgICAgICBlbGVtZW50U291cmNlQ29tcGlsZXIudGFnU3RhcnQoXG4vLyAgICAgICAgICAgICBzb3VyY2VCdWZmZXIsXG4vLyAgICAgICAgICAgICBhTm9kZS50YWdOYW1lLFxuLy8gICAgICAgICAgICAgYU5vZGUucHJvcHMsXG4vLyAgICAgICAgICAgICBleHRyYS5wcm9wXG4vLyAgICAgICAgICk7XG4vLyBcbi8vICAgICAgICAgZWxlbWVudFNvdXJjZUNvbXBpbGVyLmlubmVyKHNvdXJjZUJ1ZmZlciwgYU5vZGUsIG93bmVyKTtcbi8vICAgICAgICAgZWxlbWVudFNvdXJjZUNvbXBpbGVyLnRhZ0VuZChzb3VyY2VCdWZmZXIsIGFOb2RlLnRhZ05hbWUpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiDnvJbor5Hnu4Tku7boioLngrlcbi8vICAgICAgKlxuLy8gICAgICAqIEBwYXJhbSB7QU5vZGV9IGFOb2RlIOiKgueCueWvueixoVxuLy8gICAgICAqIEBwYXJhbSB7Q29tcGlsZVNvdXJjZUJ1ZmZlcn0gc291cmNlQnVmZmVyIOe8luivkea6kOeggeeahOS4remXtGJ1ZmZlclxuLy8gICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBvd25lciDmiYDlsZ7nu4Tku7blrp7kvovnjq/looNcbi8vICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEg57yW6K+R5omA6ZyA55qE5LiA5Lqb6aKd5aSW5L+h5oGvXG4vLyAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXh0cmEuQ29tcG9uZW50Q2xhc3Mg5a+55bqU57uE5Lu257G7XG4vLyAgICAgICovXG4vLyAgICAgY29tcGlsZUNvbXBvbmVudDogZnVuY3Rpb24gKGFOb2RlLCBzb3VyY2VCdWZmZXIsIG93bmVyLCBleHRyYSkge1xuLy8gICAgICAgICBpZiAoYU5vZGUpIHtcbi8vICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ3ZhciAkc2xvdE5hbWUgPSBudWxsOycpO1xuLy8gICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygndmFyICRnaXZlblNsb3RzID0gW107Jyk7XG4vLyAgICAgICAgICAgICBlYWNoKGFOb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgc2xvdEJpbmQgPSAhY2hpbGQudGV4dEV4cHIgJiYgZ2V0QU5vZGVQcm9wKGNoaWxkLCAnc2xvdCcpO1xuLy8gICAgICAgICAgICAgICAgIGlmIChzbG90QmluZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckc2xvdE5hbWUgPSAnICsgY29tcGlsZUV4cHJTb3VyY2UuZXhwcihzbG90QmluZC5leHByKSArICc7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyRnaXZlblNsb3RzLnB1c2goW2Z1bmN0aW9uIChjb21wb25lbnRDdHgpIHsnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICB2YXIgaHRtbCA9IFwiXCI7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoYU5vZGVDb21waWxlci5jb21waWxlKGNoaWxkLCBzb3VyY2VCdWZmZXIsIG93bmVyKSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgcmV0dXJuIGh0bWw7Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ30sICRzbG90TmFtZV0pOycpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnJGdpdmVuU2xvdHMucHVzaChbZnVuY3Rpb24gKGNvbXBvbmVudEN0eCkgeycpO1xuLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCcgIHZhciBodG1sID0gXCJcIjsnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhhTm9kZUNvbXBpbGVyLmNvbXBpbGUoY2hpbGQsIHNvdXJjZUJ1ZmZlciwgb3duZXIpKTtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICByZXR1cm4gaHRtbDsnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfV0pOycpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgdmFyIENvbXBvbmVudENsYXNzID0gZXh0cmEuQ29tcG9uZW50Q2xhc3M7XG4vLyAgICAgICAgIHZhciBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50Q2xhc3Moe1xuLy8gICAgICAgICAgICAgYU5vZGU6IGFOb2RlLFxuLy8gICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuLy8gICAgICAgICAgICAgc3ViVGFnOiBhTm9kZS50YWdOYW1lXG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHZhciBnaXZlbkRhdGEgPSBbXTtcbi8vIFxuLy8gICAgICAgICBlYWNoKGNvbXBvbmVudC5iaW5kcywgZnVuY3Rpb24gKHByb3ApIHtcbi8vICAgICAgICAgICAgIGdpdmVuRGF0YS5wdXNoKFxuLy8gICAgICAgICAgICAgICAgIGNvbXBpbGVFeHByU291cmNlLnN0cmluZ0xpdGVyYWxpemUocHJvcC5uYW1lKVxuLy8gICAgICAgICAgICAgICAgICsgJzonXG4vLyAgICAgICAgICAgICAgICAgKyBjb21waWxlRXhwclNvdXJjZS5leHByKHByb3AuZXhwcilcbi8vICAgICAgICAgICAgICk7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2h0bWwgKz0gKCcpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmVuZGVyZXJTdGFydCgpO1xuLy8gICAgICAgICBjb21waWxlQ29tcG9uZW50U291cmNlKHNvdXJjZUJ1ZmZlciwgY29tcG9uZW50LCBleHRyYSAmJiBleHRyYS5wcm9wKTtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmFkZFJlbmRlcmVyRW5kKCk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJykoeycgKyBnaXZlbkRhdGEuam9pbignLFxcbicpICsgJ30sIGNvbXBvbmVudEN0eCwgJGdpdmVuU2xvdHMpOycpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuYWRkUmF3KCckZ2l2ZW5TbG90cyA9IG51bGw7Jyk7XG4vLyAgICAgfVxuLy8gfTtcbi8vIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe7hOS7tiByZW5kZXJlciDml7YgY3R4IOWvueixoeaehOW7uueahOS7o+eggVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICogQHBhcmFtIHtDb21waWxlU291cmNlQnVmZmVyfSBzb3VyY2VCdWZmZXIg57yW6K+R5rqQ56CB55qE5Lit6Ze0YnVmZmVyXG4vLyAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IOe7hOS7tuWunuS+i1xuLy8gICogQHBhcmFtIHtzdHJpbmc/fSBleHRyYVByb3Ag6aKd5aSW55qE5bGe5oCn5LiyXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIGNvbXBpbGVDb21wb25lbnRTb3VyY2Uoc291cmNlQnVmZmVyLCBjb21wb25lbnQsIGV4dHJhUHJvcCkge1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoZ2VuQ29tcG9uZW50Q29udGV4dENvZGUoY29tcG9uZW50KSk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnY29tcG9uZW50Q3R4Lm93bmVyID0gcGFyZW50Q3R4OycpO1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJ2NvbXBvbmVudEN0eC5naXZlblNsb3RzID0gZ2l2ZW5TbG90czsnKTtcbi8vIFxuLy8gXG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZGF0YSA9IGV4dGVuZChjb21wb25lbnRDdHguZGF0YSwgZGF0YSk7Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnZm9yICh2YXIgJGkgPSAwOyAkaSA8IGNvbXBvbmVudEN0eC5jb21wdXRlZE5hbWVzLmxlbmd0aDsgJGkrKykgeycpO1xuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSYXcoJyAgdmFyICRjb21wdXRlZE5hbWUgPSBjb21wb25lbnRDdHguY29tcHV0ZWROYW1lc1skaV07Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnICBkYXRhWyRjb21wdXRlZE5hbWVdID0gY29tcG9uZW50Q3R4LmNvbXB1dGVkWyRjb21wdXRlZE5hbWVdKCk7Jyk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdygnfScpO1xuLy8gXG4vLyAgICAgZXh0cmFQcm9wID0gZXh0cmFQcm9wIHx8ICcnO1xuLy8gXG4vLyAgICAgdmFyIGV2ZW50RGVjbGFyYXRpb25zID0gW107XG4vLyAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudC5saXN0ZW5lcnMpIHtcbi8vICAgICAgICAgZWFjaChjb21wb25lbnQubGlzdGVuZXJzW2tleV0sIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuLy8gICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmRlY2xhcmF0aW9uKSB7XG4vLyAgICAgICAgICAgICAgICAgZXZlbnREZWNsYXJhdGlvbnMucHVzaChsaXN0ZW5lci5kZWNsYXJhdGlvbik7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci50YWdTdGFydChcbi8vICAgICAgICAgc291cmNlQnVmZmVyLFxuLy8gICAgICAgICBjb21wb25lbnQudGFnTmFtZSxcbi8vICAgICAgICAgY29tcG9uZW50LmFOb2RlLnByb3BzLFxuLy8gICAgICAgICBleHRyYVByb3Bcbi8vICAgICApO1xuLy8gXG4vLyAgICAgaWYgKCFjb21wb25lbnQub3duZXIpIHtcbi8vICAgICAgICAgc291cmNlQnVmZmVyLmpvaW5TdHJpbmcoJzwhLS1zLWRhdGE6Jyk7XG4vLyAgICAgICAgIHNvdXJjZUJ1ZmZlci5qb2luRGF0YVN0cmluZ2lmeSgpO1xuLy8gICAgICAgICBzb3VyY2VCdWZmZXIuam9pblN0cmluZygnLS0+Jyk7XG4vLyAgICAgfVxuLy8gXG4vLyBcbi8vIFxuLy8gICAgIGVsZW1lbnRTb3VyY2VDb21waWxlci5pbm5lcihzb3VyY2VCdWZmZXIsIGNvbXBvbmVudC5hTm9kZSwgY29tcG9uZW50KTtcbi8vICAgICBlbGVtZW50U291cmNlQ29tcGlsZXIudGFnRW5kKHNvdXJjZUJ1ZmZlciwgY29tcG9uZW50LnRhZ05hbWUpO1xuLy8gfVxuLy8gXG4vLyB2YXIgc3RyaW5naWZpZXIgPSB7XG4vLyAgICAgb2JqOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgIHZhciBwcmVmaXhDb21tYTtcbi8vICAgICAgICAgdmFyIHJlc3VsdCA9ICd7Jztcbi8vIFxuLy8gICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4vLyAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICBpZiAocHJlZml4Q29tbWEpIHtcbi8vICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgcHJlZml4Q29tbWEgPSAxO1xuLy8gXG4vLyAgICAgICAgICAgICByZXN1bHQgKz0gY29tcGlsZUV4cHJTb3VyY2Uuc3RyaW5nTGl0ZXJhbGl6ZShrZXkpICsgJzonICsgc3RyaW5naWZpZXIuYW55KHNvdXJjZVtrZXldKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIGFycjogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICB2YXIgcHJlZml4Q29tbWE7XG4vLyAgICAgICAgIHZhciByZXN1bHQgPSAnWyc7XG4vLyBcbi8vICAgICAgICAgZWFjaChzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSkge1xuLy8gICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmaWVyLmFueSh2YWx1ZSk7XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIHN0cjogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICByZXR1cm4gY29tcGlsZUV4cHJTb3VyY2Uuc3RyaW5nTGl0ZXJhbGl6ZShzb3VyY2UpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICBkYXRlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIHNvdXJjZS5nZXRUaW1lKCkgKyAnKSc7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIGFueTogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzb3VyY2UpIHtcbi8vICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVyLnN0cihzb3VyY2UpO1xuLy8gXG4vLyAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuLy8gICAgICAgICAgICAgICAgIHJldHVybiAnJyArIHNvdXJjZTtcbi8vIFxuLy8gICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4vLyBcbi8vICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4vLyAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5hcnIoc291cmNlKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRGF0ZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuZGF0ZShzb3VyY2UpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5vYmooc291cmNlKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IFN0cmluZ2lmeTonICsgc291cmNlKTtcbi8vICAgICB9XG4vLyB9O1xuLy8gXG4vLyAvKipcbi8vICAqIOeUn+aIkOe7hOS7tiByZW5kZXJlciDml7YgY3R4IOWvueixoeaehOW7uueahOS7o+eggVxuLy8gICpcbi8vICAqIEBpbm5lclxuLy8gICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCDnu4Tku7blrp7kvotcbi8vICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAqL1xuLy8gZnVuY3Rpb24gZ2VuQ29tcG9uZW50Q29udGV4dENvZGUoY29tcG9uZW50KSB7XG4vLyAgICAgdmFyIGNvZGUgPSBbJ3ZhciBjb21wb25lbnRDdHggPSB7J107XG4vLyBcbi8vICAgICAvLyBnaXZlbiBhbm9kZVxuLy8gICAgIGNvZGUucHVzaCgnZ2l2ZW5TbG90czogW10sJyk7XG4vLyBcbi8vICAgICAvLyBmaWx0ZXJzXG4vLyAgICAgY29kZS5wdXNoKCdmaWx0ZXJzOiB7Jyk7XG4vLyAgICAgdmFyIGZpbHRlckNvZGUgPSBbXTtcbi8vICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50LmZpbHRlcnMpIHtcbi8vICAgICAgICAgdmFyIGZpbHRlciA9IGNvbXBvbmVudC5maWx0ZXJzW2tleV07XG4vLyBcbi8vICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgIGZpbHRlckNvZGUucHVzaChrZXkgKyAnOiAnICsgZmlsdGVyLnRvU3RyaW5nKCkpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGNvZGUucHVzaChmaWx0ZXJDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCd9LCcpO1xuLy8gXG4vLyAgICAgY29kZS5wdXNoKFxuLy8gICAgICAgICAnY2FsbEZpbHRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHsnLFxuLy8gICAgICAgICAnICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcnNbbmFtZV0gfHwgREVGQVVMVF9GSUxURVJTW25hbWVdOycsXG4vLyAgICAgICAgICcgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikgeycsXG4vLyAgICAgICAgICcgICAgICAgIHJldHVybiBmaWx0ZXIuYXBwbHkodGhpcywgYXJncyk7Jyxcbi8vICAgICAgICAgJyAgICB9Jyxcbi8vICAgICAgICAgJ30sJ1xuLy8gICAgICk7XG4vLyBcbi8vICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cbi8vICAgICAvLyBjb21wdXRlZCBvYmpcbi8vICAgICBjb2RlLnB1c2goJ2NvbXB1dGVkOiB7Jyk7XG4vLyAgICAgdmFyIGNvbXB1dGVkQ29kZSA9IFtdO1xuLy8gICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnQuY29tcHV0ZWQpIHtcbi8vICAgICAgICAgdmFyIGNvbXB1dGVkID0gY29tcG9uZW50LmNvbXB1dGVkW2tleV07XG4vLyBcbi8vICAgICAgICAgaWYgKHR5cGVvZiBjb21wdXRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgICAgICAgICAgY29tcHV0ZWRDb2RlLnB1c2goa2V5ICsgJzogJ1xuLy8gICAgICAgICAgICAgICAgICsgY29tcHV0ZWQudG9TdHJpbmcoKS5yZXBsYWNlKFxuLy8gICAgICAgICAgICAgICAgICAgICAvdGhpcy5kYXRhLmdldFxcKChbXlxcKV0rKVxcKS9nLFxuLy8gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIGV4cHJMaXRlcmFsKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwclN0ciA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZXhwckxpdGVyYWwpKSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHIoZXhwclN0cik7XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlRXhwclNvdXJjZS5leHByKGV4cHIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBjb2RlLnB1c2goY29tcHV0ZWRDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCd9LCcpO1xuLy8gXG4vLyAgICAgLy8gY29tcHV0ZWQgbmFtZXNcbi8vICAgICBjb2RlLnB1c2goJ2NvbXB1dGVkTmFtZXM6IFsnKTtcbi8vICAgICBjb21wdXRlZENvZGUgPSBbXTtcbi8vICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50LmNvbXB1dGVkKSB7XG4vLyAgICAgICAgIHZhciBjb21wdXRlZCA9IGNvbXBvbmVudC5jb21wdXRlZFtrZXldO1xuLy8gXG4vLyAgICAgICAgIGlmICh0eXBlb2YgY29tcHV0ZWQgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgICAgIGNvbXB1dGVkQ29kZS5wdXNoKCdcIicgKyBrZXkgKyAnXCInKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBjb2RlLnB1c2goY29tcHV0ZWRDb2RlLmpvaW4oJywnKSk7XG4vLyAgICAgY29kZS5wdXNoKCddLCcpO1xuLy8gICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG4vLyBcbi8vICAgICAvLyBkYXRhXG4vLyAgICAgY29kZS5wdXNoKCdkYXRhOiAnICsgc3RyaW5naWZpZXIuYW55KGNvbXBvbmVudC5kYXRhLmdldCgpKSArICcsJyk7XG4vLyBcbi8vICAgICAvLyB0YWdOYW1lXG4vLyAgICAgY29kZS5wdXNoKCd0YWdOYW1lOiBcIicgKyBjb21wb25lbnQudGFnTmFtZSArICdcIicpO1xuLy8gICAgIGNvZGUucHVzaCgnfTsnKTtcbi8vIFxuLy8gICAgIHJldHVybiBjb2RlLmpvaW4oJ1xcbicpO1xuLy8gfVxuLy8gXG4vLyAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuLy8gXG4vLyAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gLyogZXNsaW50LWRpc2FibGUgZmVjcy1jYW1lbGNhc2UgKi9cbi8vIFxuLy8gLyoqXG4vLyAgKiDnu4Tku7bnvJbor5HnmoTmqKHmnb/lh73mlbBcbi8vICAqXG4vLyAgKiBAaW5uZXJcbi8vICAqL1xuLy8gZnVuY3Rpb24gY29tcG9uZW50Q29tcGlsZVByZUNvZGUoKSB7XG4vLyAgICAgdmFyICR2ZXJzaW9uID0gJzMuNS43Jztcbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuLy8gICAgICAgICBpZiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuLy8gICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICByZXR1cm4gdGFyZ2V0O1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGVhY2goYXJyYXksIGl0ZXJhdG9yKSB7XG4vLyAgICAgICAgIGlmIChhcnJheSAmJiBhcnJheS5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvcihhcnJheVtpXSwgaSkgPT09IGZhbHNlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuLy8gICAgICAgICB2YXIgcmVzdWx0O1xuLy8gICAgICAgICBlYWNoKGFycmF5LCBmdW5jdGlvbiAoaXRlbSkge1xuLy8gICAgICAgICAgICAgcmVzdWx0ID0gaXRlbSA9PT0gdmFsdWU7XG4vLyAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdDtcbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbi8vICAgICB9XG4vLyBcbi8vICAgICB2YXIgSFRNTF9FTlRJVFkgPSB7XG4vLyAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbi8vICAgICAgICAgJyYnOiAnJmFtcDsnLFxuLy8gICAgICAgICAnPCc6ICcmbHQ7Jyxcbi8vICAgICAgICAgJz4nOiAnJmd0OycsXG4vLyAgICAgICAgICdcIic6ICcmcXVvdDsnLFxuLy8gICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBxdW90ZXMgKi9cbi8vICAgICAgICAgXCInXCI6ICcmIzM5Oydcbi8vICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBxdW90ZXMgKi9cbi8vICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbi8vICAgICB9O1xuLy8gXG4vLyAgICAgZnVuY3Rpb24gaHRtbEZpbHRlclJlcGxhY2VyKGMpIHtcbi8vICAgICAgICAgcmV0dXJuIEhUTUxfRU5USVRZW2NdO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIGVzY2FwZUhUTUwoc291cmNlKSB7XG4vLyAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuICcnO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIFN0cmluZyhzb3VyY2UpLnJlcGxhY2UoL1smPD5cIiddL2csIGh0bWxGaWx0ZXJSZXBsYWNlcik7XG4vLyAgICAgfVxuLy8gXG4vLyAgICAgdmFyIERFRkFVTFRfRklMVEVSUyA9IHtcbi8vICAgICAgICAgdXJsOiBlbmNvZGVVUklDb21wb25lbnQsXG4vLyAgICAgICAgIF9jbGFzczogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5qb2luKCcgJyk7XG4vLyAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIF9zdHlsZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuLy8gICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnOicgKyBzb3VyY2Vba2V5XSArICc7Jztcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbi8vICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSB8fCAnJztcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgX3NlcDogZnVuY3Rpb24gKHNvdXJjZSwgc2VwKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gc291cmNlID8gc2VwICsgc291cmNlIDogJyc7XG4vLyAgICAgICAgIH1cbi8vICAgICB9O1xuLy8gXG4vLyAgICAgZnVuY3Rpb24gYXR0ckZpbHRlcihuYW1lLCB2YWx1ZSkge1xuLy8gICAgICAgICBpZiAodmFsdWUpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnICcgKyBuYW1lICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4vLyAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICByZXR1cm4gJyc7XG4vLyAgICAgfVxuLy8gXG4vLyAgICAgZnVuY3Rpb24gYm9vbEF0dHJGaWx0ZXIobmFtZSwgdmFsdWUpIHtcbi8vICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnZmFsc2UnICYmIHZhbHVlICE9PSAnMCcpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnICcgKyBuYW1lO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuICcnO1xuLy8gICAgIH1cbi8vIFxuLy8gICAgIGZ1bmN0aW9uIHN0cmluZ0xpdGVyYWxpemUoc291cmNlKSB7XG4vLyAgICAgICAgIHJldHVybiAnXCInXG4vLyAgICAgICAgICAgICArIHNvdXJjZVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHg1Qy9nLCAnXFxcXFxcXFwnKVxuLy8gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MEEvZywgJ1xcXFxuJylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MDkvZywgJ1xcXFx0Jylcbi8vICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx4MEQvZywgJ1xcXFxyJylcbi8vICAgICAgICAgICAgICsgJ1wiJztcbi8vICAgICB9XG4vLyBcbi8vICAgICB2YXIgc3RyaW5naWZpZXIgPSB7XG4vLyAgICAgICAgIG9iajogZnVuY3Rpb24gKHNvdXJjZSkge1xuLy8gICAgICAgICAgICAgdmFyIHByZWZpeENvbW1hO1xuLy8gICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICd7Jztcbi8vIFxuLy8gICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdMaXRlcmFsaXplKGtleSkgKyAnOicgKyBzdHJpbmdpZmllci5hbnkoc291cmNlW2tleV0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgYXJyOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICB2YXIgcHJlZml4Q29tbWE7XG4vLyAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1snO1xuLy8gXG4vLyAgICAgICAgICAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKHByZWZpeENvbW1hKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIHByZWZpeENvbW1hID0gMTtcbi8vIFxuLy8gICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZmllci5hbnkodmFsdWUpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgc3RyOiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbGl6ZShzb3VyY2UpO1xuLy8gICAgICAgICB9LFxuLy8gXG4vLyAgICAgICAgIGRhdGU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbi8vICAgICAgICAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIHNvdXJjZS5nZXRUaW1lKCkgKyAnKSc7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgYW55OiBmdW5jdGlvbiAoc291cmNlKSB7XG4vLyAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzb3VyY2UpIHtcbi8vICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuc3RyKHNvdXJjZSk7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyBzb3VyY2U7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4vLyBcbi8vICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vIFxuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllci5hcnIoc291cmNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZXIuZGF0ZShzb3VyY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVyLm9iaihzb3VyY2UpO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBTdHJpbmdpZnk6JyArIHNvdXJjZSk7XG4vLyAgICAgICAgIH1cbi8vICAgICB9O1xuLy8gfVxuLy8gLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gLyogZXNsaW50LWVuYWJsZSBmZWNzLWNhbWVsY2FzZSAqL1xuLy8gXG4vLyAvKipcbi8vICAqIOWwhue7hOS7tue8luivkeaIkCByZW5kZXIg5pa55rOV55qEIGpzIOa6kOeggVxuLy8gICpcbi8vICAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudENsYXNzIOe7hOS7tuexu1xuLy8gICogQHJldHVybiB7c3RyaW5nfVxuLy8gICovXG4vLyBmdW5jdGlvbiBjb21waWxlSlNTb3VyY2UoQ29tcG9uZW50Q2xhc3MpIHtcbi8vICAgICB2YXIgc291cmNlQnVmZmVyID0gbmV3IENvbXBpbGVTb3VyY2VCdWZmZXIoKTtcbi8vIFxuLy8gICAgIHNvdXJjZUJ1ZmZlci5hZGRSZW5kZXJlclN0YXJ0KCk7XG4vLyAgICAgc291cmNlQnVmZmVyLmFkZFJhdyhcbi8vICAgICAgICAgY29tcG9uZW50Q29tcGlsZVByZUNvZGUudG9TdHJpbmcoKVxuLy8gICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuLy8gICAgICAgICAgICAgLnNsaWNlKDEpXG4vLyAgICAgICAgICAgICAuam9pbignXFxuJylcbi8vICAgICAgICAgICAgIC5yZXBsYWNlKC9cXH1cXHMqJC8sICcnKVxuLy8gICAgICk7XG4vLyBcbi8vICAgICAvLyDlhYjliJ3lp4vljJbkuKrlrp7kvovvvIzorqnmqKHmnb/nvJbor5HmiJAgQU5vZGXvvIzlubbkuJTog73ojrflvpfliJ3lp4vljJbmlbDmja5cbi8vICAgICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKCk7XG4vLyBcbi8vICAgICBjb21waWxlQ29tcG9uZW50U291cmNlKHNvdXJjZUJ1ZmZlciwgY29tcG9uZW50KTtcbi8vICAgICBzb3VyY2VCdWZmZXIuYWRkUmVuZGVyZXJFbmQoKTtcbi8vICAgICByZXR1cm4gc291cmNlQnVmZmVyLnRvQ29kZSgpO1xuLy8gfVxuLy8gI1tlbmRdXG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVKU1NvdXJjZTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyAgICAgdmFyIG5leHRUaWNrID0gcmVxdWlyZSgnLi91dGlsL25leHQtdGljaycpO1xuLy8gICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbC9pbmhlcml0cycpO1xuLy8gICAgIHZhciBwYXJzZVRlbXBsYXRlID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2UtdGVtcGxhdGUnKTtcbi8vICAgICB2YXIgcGFyc2VFeHByID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2UtZXhwcicpO1xuLy8gICAgIHZhciBFeHByVHlwZSA9IHJlcXVpcmUoJy4vcGFyc2VyL2V4cHItdHlwZScpO1xuLy8gICAgIHZhciBMaWZlQ3ljbGUgPSByZXF1aXJlKCcuL3ZpZXcvbGlmZS1jeWNsZScpO1xuLy8gICAgIHZhciBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vdmlldy9ub2RlLXR5cGUnKTtcbi8vICAgICB2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi92aWV3L2NvbXBvbmVudCcpO1xuLy8gICAgIHZhciBjb21waWxlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi92aWV3L2NvbXBpbGUtY29tcG9uZW50Jyk7XG4vLyAgICAgdmFyIGRlZmluZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vdmlldy9kZWZpbmUtY29tcG9uZW50Jyk7XG4vLyAgICAgdmFyIGVtaXREZXZ0b29sID0gcmVxdWlyZSgnLi91dGlsL2VtaXQtZGV2dG9vbCcpO1xuLy8gICAgIHZhciBjb21waWxlSlNTb3VyY2UgPSByZXF1aXJlKCcuL3ZpZXcvY29tcGlsZS1qcy1zb3VyY2UnKTtcbi8vICAgICB2YXIgRGF0YSA9IHJlcXVpcmUoJy4vcnVudGltZS9kYXRhJyk7XG4vLyAgICAgdmFyIGV2YWxFeHByID0gcmVxdWlyZSgnLi9ydW50aW1lL2V2YWwtZXhwcicpO1xuLy8gICAgIHZhciBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL3V0aWwvZGF0YS10eXBlcycpO1xuXG5cbiAgICB2YXIgc2FuID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2Fu54mI5pys5Y+3XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJzaW9uOiAnMy41LjcnLFxuXG4gICAgICAgIC8vICNbYmVnaW5dIGRldnRvb2xcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuW8gOWQr+iwg+ivleOAguW8gOWQr+iwg+ivleaXtiBkZXZ0b29sIOS8muW3peS9nFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAvLyAjW2JlZ2luXSBzc3Jcbi8vICAgICAgICAgLyoqXG4vLyAgICAgICAgICAqIOWwhue7hOS7tuexu+e8luivkeaIkCByZW5kZXJlciDmlrnms5Vcbi8vICAgICAgICAgICpcbi8vICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4vLyAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKE9iamVjdCk6c3RyaW5nfVxuLy8gICAgICAgICAgKi9cbi8vICAgICAgICAgY29tcGlsZVRvUmVuZGVyZXI6IGZ1bmN0aW9uIChDb21wb25lbnRDbGFzcykge1xuLy8gICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gQ29tcG9uZW50Q2xhc3MuX19zc3JSZW5kZXJlcjtcbi8vIFxuLy8gICAgICAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuLy8gICAgICAgICAgICAgICAgIHZhciBjb2RlID0gY29tcGlsZUpTU291cmNlKENvbXBvbmVudENsYXNzKTtcbi8vICAgICAgICAgICAgICAgICByZW5kZXJlciA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgY29kZSkpKCk7XG4vLyAgICAgICAgICAgICAgICAgQ29tcG9uZW50Q2xhc3MuX19zc3JSZW5kZXJlciA9IHJlbmRlcmVyO1xuLy8gICAgICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4vLyAgICAgICAgIH0sXG4vLyBcbi8vICAgICAgICAgLyoqXG4vLyAgICAgICAgICAqIOWwhue7hOS7tuexu+e8luivkeaIkCByZW5kZXJlciDmlrnms5XnmoTmupDmlofku7Zcbi8vICAgICAgICAgICpcbi8vICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4vLyAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbi8vICAgICAgICAgICovXG4vLyAgICAgICAgIGNvbXBpbGVUb1NvdXJjZTogY29tcGlsZUpTU291cmNlLFxuICAgICAgICAvLyAjW2VuZF1cblxuICAgICAgICAvKipcbiAgICAgICAgICog57uE5Lu25Z+657G7XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rnu4Tku7bnsbtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIOe7hOS7tuexu+eahOaWueazleihqFxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZUNvbXBvbmVudDogZGVmaW5lQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvJbor5Hnu4Tku7bnsbvjgILpooTop6PmnpB0ZW1wbGF0ZeWSjGNvbXBvbmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29tcG9uZW50Q2xhc3Mg57uE5Lu257G7XG4gICAgICAgICAqL1xuICAgICAgICBjb21waWxlQ29tcG9uZW50OiBjb21waWxlQ29tcG9uZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6PmnpAgdGVtcGxhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgdGVtcGxhdGUg5rqQ56CBXG4gICAgICAgICAqIEByZXR1cm4ge0FOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VUZW1wbGF0ZTogcGFyc2VUZW1wbGF0ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6Kej5p6Q6KGo6L6+5byPXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Ug5rqQ56CBXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlRXhwcjogcGFyc2VFeHByLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDooajovr7lvI/nsbvlnovmnprkuL5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBFeHByVHlwZTogRXhwclR5cGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUn+WRveWRqOacn1xuICAgICAgICAgKi9cbiAgICAgICAgTGlmZUN5Y2xlOiBMaWZlQ3ljbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiKgueCueexu+Wei1xuICAgICAgICAgKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIE5vZGVUeXBlOiBOb2RlVHlwZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zyo5LiL5LiA5Liq5pu05paw5ZGo5pyf6L+Q6KGM5Ye95pWwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgei/kOihjOeahOWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlbDmja7nsbtcbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0P30gZGF0YSDliJ3lp4vmlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtEYXRhP30gcGFyZW50IOeItue6p+aVsOaNruWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgRGF0YTogRGF0YSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6h566X6KGo6L6+5byP55qE5YC8XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIOihqOi+vuW8j+WvueixoVxuICAgICAgICAgKiBAcGFyYW0ge0RhdGF9IGRhdGEg5pWw5o2u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7Q29tcG9uZW50PX0gb3duZXIg57uE5Lu25a+56LGh77yM55So5LqO6KGo6L6+5byP5LitZmlsdGVy55qE5omn6KGMXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICBldmFsRXhwcjogZXZhbEV4cHIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaehOW7uuexu+S5i+mXtOeahOe7p+aJv+WFs+ezu1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJDbGFzcyDlrZDnsbvlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyDniLbnsbvlh73mlbBcbiAgICAgICAgICovXG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVR5cGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVHlwZXM6IERhdGFUeXBlc1xuICAgIH07XG5cbiAgICAvLyBleHBvcnRcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEZvciBDb21tb25KU1xuICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzYW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBGb3IgQU1EXG4gICAgICAgIGRlZmluZSgnc2FuJywgW10sIHNhbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGb3IgPHNjcmlwdCBzcmM9XCIuLi5cIlxuICAgICAgICByb290LnNhbiA9IHNhbjtcbiAgICB9XG5cbiAgICAvLyAjW2JlZ2luXSBkZXZ0b29sXG4gICAgZW1pdERldnRvb2wuc3RhcnQoc2FuKTtcbiAgICAvLyAjW2VuZF1cbn0pKHRoaXMpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///3\\n\")},function(module,exports){eval('module.exports = \"\\\\n<div class=\\\\\"hello\\\\\">hello {{msg}}</div>\\\\n\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVsbG8uc2FuPzJhNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaURBQWlELEtBQUsiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48ZGl2IGNsYXNzPVxcXCJoZWxsb1xcXCI+aGVsbG8ge3ttc2d9fTwvZGl2PlxcblwiOyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n')},function(module,exports,__webpack_require__){\"use strict\";eval('\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n    value: true\\n});\\n// <template>\\n//     <div class=\"hello\">hello {{msg}}</div>\\n// </template>\\n//\\n// <script>\\nexports.default = {\\n    initData: function initData() {\\n        return {\\n            msg: \\'world~~~~~\\'\\n        };\\n    }\\n};\\n// <\\/script>\\n//\\n// <style>\\n//     .hello {\\n//         color: blue;\\n//     }\\n// </style>\\n/* generated by san-loader *///# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaGVsbG8uc2FuPzg0MTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBS0E7O2tDQUVBOztpQkFHQTtBQUZBO0FBR0E7QUFMQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJoZWxsb1wiPmhlbGxvIHt7bXNnfX08L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBpbml0RGF0YSAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1zZzogJ3dvcmxkfn5+fn4nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgICAuaGVsbG8ge1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICB9XG48L3N0eWxlPiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(1)(true);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n.hello {\\\\n    color: blue;\\\\n}\\\\n\", \"\", {\"version\":3,\"sources\":[\"/Users/liyuze/WebstormProjects/WebpackAndSan/src/hello.san?104008bc\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;AAeA;IACA,YAAA;CACA\",\"file\":\"hello.san\",\"sourcesContent\":[\"<template>\\\\n    <div class=\\\\\"hello\\\\\">hello {{msg}}</div>\\\\n</template>\\\\n\\\\n<script>\\\\n    export default {\\\\n        initData () {\\\\n            return {\\\\n                msg: \\'world~~~~~\\'\\\\n            };\\\\n        }\\\\n    }\\\\n<\\/script>\\\\n\\\\n<style>\\\\n    .hello {\\\\n        color: blue;\\\\n    }\\\\n</style>\"],\"sourceRoot\":\"\"}]);\\n\\n// exports\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVsbG8uc2FuP2NiYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwrREFBZ0Usa0JBQWtCLEdBQUcsVUFBVSxvSUFBb0ksS0FBSyxVQUFVLHlGQUF5RixLQUFLLHFEQUFxRCx1QkFBdUIsc0JBQXNCLG1EQUFtRCxXQUFXLE9BQU8sb0NBQW9DLHNCQUFzQixPQUFPLDZCQUE2Qjs7QUFFcmxCIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLmhlbGxvIHtcXG4gICAgY29sb3I6IGJsdWU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvbGl5dXplL1dlYnN0b3JtUHJvamVjdHMvV2VicGFja0FuZFNhbi9zcmMvaGVsbG8uc2FuPzEwNDAwOGJjXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0lBQ0EsWUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJoZWxsby5zYW5cIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJoZWxsb1xcXCI+aGVsbG8ge3ttc2d9fTwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG4gICAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICAgICAgaW5pdERhdGEgKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIG1zZzogJ3dvcmxkfn5+fn4nXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgfVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4gICAgLmhlbGxvIHtcXG4gICAgICAgIGNvbG9yOiBibHVlO1xcbiAgICB9XFxuPC9zdHlsZT5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///6\\n')},function(module,exports,__webpack_require__){eval(\"\\nvar content = __webpack_require__(6);\\n\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n\\nvar transform;\\nvar insertInto;\\n\\n\\n\\nvar options = {\\\"hmr\\\":true}\\n\\noptions.transform = transform\\noptions.insertInto = undefined;\\n\\nvar update = __webpack_require__(0)(content, options);\\n\\nif(content.locals) module.exports = content.locals;\\n\\nif(false) {}//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVsbG8uc2FuP2M0OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Nhbi1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4uL25vZGVfbW9kdWxlcy9zYW4tbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9oZWxsby5zYW5cIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvc2FuLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Nhbi1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2hlbGxvLnNhblwiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvc2FuLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Nhbi1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2hlbGxvLnNhblwiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///7\\n\")},function(module,exports,__webpack_require__){eval(\"var __san_script__, __san_template__\\nvar __san_styles__ = {}\\n__webpack_require__(7)\\n__san_script__ = __webpack_require__(5)\\nif (__san_script__ &&\\n    __san_script__.__esModule &&\\n    Object.keys(__san_script__).length > 1) {\\n  console.warn(\\\"[san-loader] src/hello.san: named exports in *.san files are ignored.\\\")}\\n__san_template__ = __webpack_require__(4)\\nvar __san_proto__ = {}\\nif (__san_script__) {\\n  __san_proto__ = __san_script__.__esModule\\n    ? __san_script__['default']\\n    : __san_script__\\n}\\nif (__san_template__) {\\n  __san_proto__.template = __san_template__\\n}\\nvar san = __webpack_require__(3)\\nvar __san_exports__ = san.defineComponent(__san_proto__)\\nmodule.exports = __san_exports__\\nif (module.exports.__esModule) module.exports = module.exports['default']\\nif (!__san_exports__.computed) __san_exports__.computed = {}\\nObject.keys(__san_styles__).forEach(function (key) {\\nvar module = __san_styles__[key]\\n__san_exports__.computed[key] = function () { return module }\\n})\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVsbG8uc2FuPzFkYjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsQ0FBQyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fc2FuX3NjcmlwdF9fLCBfX3Nhbl90ZW1wbGF0ZV9fXG52YXIgX19zYW5fc3R5bGVzX18gPSB7fVxucmVxdWlyZShcIiEhc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy9zYW4tbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLi9ub2RlX21vZHVsZXMvc2FuLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vaGVsbG8uc2FuXCIpXG5fX3Nhbl9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvc2FuLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2hlbGxvLnNhblwiKVxuaWYgKF9fc2FuX3NjcmlwdF9fICYmXG4gICAgX19zYW5fc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fc2FuX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIltzYW4tbG9hZGVyXSBzcmMvaGVsbG8uc2FuOiBuYW1lZCBleHBvcnRzIGluICouc2FuIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fc2FuX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISFodG1sLWxvYWRlcj9taW5pbWl6ZT1mYWxzZSEuLi9ub2RlX21vZHVsZXMvc2FuLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaGVsbG8uc2FuXCIpXG52YXIgX19zYW5fcHJvdG9fXyA9IHt9XG5pZiAoX19zYW5fc2NyaXB0X18pIHtcbiAgX19zYW5fcHJvdG9fXyA9IF9fc2FuX3NjcmlwdF9fLl9fZXNNb2R1bGVcbiAgICA/IF9fc2FuX3NjcmlwdF9fWydkZWZhdWx0J11cbiAgICA6IF9fc2FuX3NjcmlwdF9fXG59XG5pZiAoX19zYW5fdGVtcGxhdGVfXykge1xuICBfX3Nhbl9wcm90b19fLnRlbXBsYXRlID0gX19zYW5fdGVtcGxhdGVfX1xufVxudmFyIHNhbiA9IHJlcXVpcmUoXCJzYW5cIilcbnZhciBfX3Nhbl9leHBvcnRzX18gPSBzYW4uZGVmaW5lQ29tcG9uZW50KF9fc2FuX3Byb3RvX18pXG5tb2R1bGUuZXhwb3J0cyA9IF9fc2FuX2V4cG9ydHNfX1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNbJ2RlZmF1bHQnXVxuaWYgKCFfX3Nhbl9leHBvcnRzX18uY29tcHV0ZWQpIF9fc2FuX2V4cG9ydHNfXy5jb21wdXRlZCA9IHt9XG5PYmplY3Qua2V5cyhfX3Nhbl9zdHlsZXNfXykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG52YXIgbW9kdWxlID0gX19zYW5fc3R5bGVzX19ba2V5XVxuX19zYW5fZXhwb3J0c19fLmNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///8\\n\")},function(module,exports){eval('\\n/**\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\n * bundle instead of the current page.\\n *\\n * One solution is to only use full urls, but that may be impossible.\\n *\\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\\n *\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\n *\\n */\\n\\nmodule.exports = function (css) {\\n  // get current location\\n  var location = typeof window !== \"undefined\" && window.location;\\n\\n  if (!location) {\\n    throw new Error(\"fixUrls requires window.location\");\\n  }\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \"string\") {\\n\\t  return css;\\n  }\\n\\n  var baseUrl = location.protocol + \"//\" + location.host;\\n  var currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \"/\");\\n\\n\\t// convert each url(...)\\n\\t/*\\n\\tThis regular expression is just a way to recursively match brackets within\\n\\ta string.\\n\\n\\t /url\\\\s*\\\\(  = Match on the word \"url\" with any whitespace after it and then a parens\\n\\t   (  = Start a capturing group\\n\\t     (?:  = Start a non-capturing group\\n\\t         [^)(]  = Match anything that isn\\'t a parentheses\\n\\t         |  = OR\\n\\t         \\\\(  = Match a start parentheses\\n\\t             (?:  = Start another non-capturing groups\\n\\t                 [^)(]+  = Match anything that isn\\'t a parentheses\\n\\t                 |  = OR\\n\\t                 \\\\(  = Match a start parentheses\\n\\t                     [^)(]*  = Match anything that isn\\'t a parentheses\\n\\t                 \\\\)  = Match a end parentheses\\n\\t             )  = End Group\\n              *\\\\) = Match anything and then a close parens\\n          )  = Close non-capturing group\\n          *  = Match anything\\n       )  = Close capturing group\\n\\t \\\\)  = Match a close parens\\n\\n\\t /gi  = Get all matches, not the first.  Be case insensitive.\\n\\t */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function(fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl\\n\\t\\t\\t.trim()\\n\\t\\t\\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\\n\\t\\t\\t.replace(/^\\'(.*)\\'$/, function(o, $1){ return $1; });\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/|\\\\s*$)/i.test(unquotedOrigUrl)) {\\n\\t\\t  return fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\\n\\t\\t  \\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \\'/\\'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \"\"); // Strip leading \\'./\\'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///9\\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(1)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \"/* main.css */\\\\nhtml {\\\\n  box-sizing: border-box;\\\\n  -ms-text-size-adjust: 100%;\\\\n  -webkit-text-size-adjust: 100%;\\\\n}\\\\n\\\\n*, *:before, *:after {\\\\n  box-sizing: inherit;\\\\n}\\\\n\\\\nbody {\\\\n  margin: 0;\\\\n  font-family: \\'Helvetica Neue\\', Helvetica, Arial, sans-serif;\\\\n}\\\\n\\\\nh1, h2, h3, h4, h5, h6, p, ul {\\\\n  margin: 0;\\\\n  padding: 0;\\\\n}\", \"\"]);\\n\\n// exports\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5jc3M/NGI3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtDQUFnRCwyQkFBMkIsK0JBQStCLG1DQUFtQyxHQUFHLDBCQUEwQix3QkFBd0IsR0FBRyxVQUFVLGNBQWMsZ0VBQWdFLEdBQUcsbUNBQW1DLGNBQWMsZUFBZSxHQUFHOztBQUVuVyIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogbWFpbi5jc3MgKi9cXG5odG1sIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcXG59XFxuXFxuKiwgKjpiZWZvcmUsICo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogaW5oZXJpdDtcXG59XFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7XFxuICBmb250LWZhbWlseTogJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG59XFxuXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgdWwge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///10\\n')},function(module,exports,__webpack_require__){eval(\"\\nvar content = __webpack_require__(10);\\n\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n\\nvar transform;\\nvar insertInto;\\n\\n\\n\\nvar options = {\\\"hmr\\\":true}\\n\\noptions.transform = transform\\noptions.insertInto = undefined;\\n\\nvar update = __webpack_require__(0)(content, options);\\n\\nif(content.locals) module.exports = content.locals;\\n\\nif(false) {}//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5jc3M/ZTBkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21haW4uY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21haW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tYWluLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///11\\n\")},function(module,exports){eval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///12\\n\")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\\n    \"use strict\";\\n\\n    if (global.setImmediate) {\\n        return;\\n    }\\n\\n    var nextHandle = 1; // Spec says greater than zero\\n    var tasksByHandle = {};\\n    var currentlyRunningATask = false;\\n    var doc = global.document;\\n    var registerImmediate;\\n\\n    function setImmediate(callback) {\\n      // Callback can either be a function or a string\\n      if (typeof callback !== \"function\") {\\n        callback = new Function(\"\" + callback);\\n      }\\n      // Copy function arguments\\n      var args = new Array(arguments.length - 1);\\n      for (var i = 0; i < args.length; i++) {\\n          args[i] = arguments[i + 1];\\n      }\\n      // Store and register the task\\n      var task = { callback: callback, args: args };\\n      tasksByHandle[nextHandle] = task;\\n      registerImmediate(nextHandle);\\n      return nextHandle++;\\n    }\\n\\n    function clearImmediate(handle) {\\n        delete tasksByHandle[handle];\\n    }\\n\\n    function run(task) {\\n        var callback = task.callback;\\n        var args = task.args;\\n        switch (args.length) {\\n        case 0:\\n            callback();\\n            break;\\n        case 1:\\n            callback(args[0]);\\n            break;\\n        case 2:\\n            callback(args[0], args[1]);\\n            break;\\n        case 3:\\n            callback(args[0], args[1], args[2]);\\n            break;\\n        default:\\n            callback.apply(undefined, args);\\n            break;\\n        }\\n    }\\n\\n    function runIfPresent(handle) {\\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\\n        // So if we\\'re currently running a task, we\\'ll need to delay this invocation.\\n        if (currentlyRunningATask) {\\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\\n            // \"too much recursion\" error.\\n            setTimeout(runIfPresent, 0, handle);\\n        } else {\\n            var task = tasksByHandle[handle];\\n            if (task) {\\n                currentlyRunningATask = true;\\n                try {\\n                    run(task);\\n                } finally {\\n                    clearImmediate(handle);\\n                    currentlyRunningATask = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    function installNextTickImplementation() {\\n        registerImmediate = function(handle) {\\n            process.nextTick(function () { runIfPresent(handle); });\\n        };\\n    }\\n\\n    function canUsePostMessage() {\\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\\n        // where `global.postMessage` means something completely different and can\\'t be used for this purpose.\\n        if (global.postMessage && !global.importScripts) {\\n            var postMessageIsAsynchronous = true;\\n            var oldOnMessage = global.onmessage;\\n            global.onmessage = function() {\\n                postMessageIsAsynchronous = false;\\n            };\\n            global.postMessage(\"\", \"*\");\\n            global.onmessage = oldOnMessage;\\n            return postMessageIsAsynchronous;\\n        }\\n    }\\n\\n    function installPostMessageImplementation() {\\n        // Installs an event handler on `global` for the `message` event: see\\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\\n\\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\\n        var onGlobalMessage = function(event) {\\n            if (event.source === global &&\\n                typeof event.data === \"string\" &&\\n                event.data.indexOf(messagePrefix) === 0) {\\n                runIfPresent(+event.data.slice(messagePrefix.length));\\n            }\\n        };\\n\\n        if (global.addEventListener) {\\n            global.addEventListener(\"message\", onGlobalMessage, false);\\n        } else {\\n            global.attachEvent(\"onmessage\", onGlobalMessage);\\n        }\\n\\n        registerImmediate = function(handle) {\\n            global.postMessage(messagePrefix + handle, \"*\");\\n        };\\n    }\\n\\n    function installMessageChannelImplementation() {\\n        var channel = new MessageChannel();\\n        channel.port1.onmessage = function(event) {\\n            var handle = event.data;\\n            runIfPresent(handle);\\n        };\\n\\n        registerImmediate = function(handle) {\\n            channel.port2.postMessage(handle);\\n        };\\n    }\\n\\n    function installReadyStateChangeImplementation() {\\n        var html = doc.documentElement;\\n        registerImmediate = function(handle) {\\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\\'s been called.\\n            var script = doc.createElement(\"script\");\\n            script.onreadystatechange = function () {\\n                runIfPresent(handle);\\n                script.onreadystatechange = null;\\n                html.removeChild(script);\\n                script = null;\\n            };\\n            html.appendChild(script);\\n        };\\n    }\\n\\n    function installSetTimeoutImplementation() {\\n        registerImmediate = function(handle) {\\n            setTimeout(runIfPresent, 0, handle);\\n        };\\n    }\\n\\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\\n\\n    // Don\\'t get fooled by e.g. browserify environments.\\n    if ({}.toString.call(global.process) === \"[object process]\") {\\n        // For Node.js before 0.9\\n        installNextTickImplementation();\\n\\n    } else if (canUsePostMessage()) {\\n        // For non-IE10 modern browsers\\n        installPostMessageImplementation();\\n\\n    } else if (global.MessageChannel) {\\n        // For web workers, where supported\\n        installMessageChannelImplementation();\\n\\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\\n        // For IE 6–8\\n        installReadyStateChangeImplementation();\\n\\n    } else {\\n        // For older browsers\\n        installSetTimeoutImplementation();\\n    }\\n\\n    attachTo.setImmediate = setImmediate;\\n    attachTo.clearImmediate = clearImmediate;\\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2), __webpack_require__(12)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///13\\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\\n            (typeof self !== \"undefined\" && self) ||\\n            window;\\nvar apply = Function.prototype.apply;\\n\\n// DOM APIs, for completeness\\n\\nexports.setTimeout = function() {\\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\\n};\\nexports.setInterval = function() {\\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\\n};\\nexports.clearTimeout =\\nexports.clearInterval = function(timeout) {\\n  if (timeout) {\\n    timeout.close();\\n  }\\n};\\n\\nfunction Timeout(id, clearFn) {\\n  this._id = id;\\n  this._clearFn = clearFn;\\n}\\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\\nTimeout.prototype.close = function() {\\n  this._clearFn.call(scope, this._id);\\n};\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = msecs;\\n};\\n\\nexports.unenroll = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = -1;\\n};\\n\\nexports._unrefActive = exports.active = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n\\n  var msecs = item._idleTimeout;\\n  if (msecs >= 0) {\\n    item._idleTimeoutId = setTimeout(function onTimeout() {\\n      if (item._onTimeout)\\n        item._onTimeout();\\n    }, msecs);\\n  }\\n};\\n\\n// setimmediate attaches itself to the global object\\n__webpack_require__(13);\\n// On some exotic environments, it\\'s not clear which object `setimmediate` was\\n// able to install onto.  Search each possibility in the same order as the\\n// `setimmediate` library.\\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\\n                       (this && this.setImmediate);\\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\\n                         (this && this.clearImmediate);\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///14\\n')},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar _san = __webpack_require__(3);\\n\\nvar _san2 = _interopRequireDefault(_san);\\n\\n__webpack_require__(11);\\n\\nvar _hello = __webpack_require__(8);\\n\\nvar _hello2 = _interopRequireDefault(_hello);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nnew _hello2.default().attach(document.body);//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbImF0dGFjaCIsImRvY3VtZW50IiwiYm9keSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQSxzQkFBZUEsTUFBZixDQUFzQkMsU0FBU0MsSUFBL0IiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2FuIGZyb20gXCJzYW5cIlxuaW1wb3J0IFwiLi9tYWluLmNzc1wiXG5pbXBvcnQgaGVsbG9zYW4gZnJvbSBcIi4vaGVsbG8uc2FuXCJcblxubmV3IGhlbGxvc2FuKCkuYXR0YWNoKGRvY3VtZW50LmJvZHkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///15\\n\")}]);","extractedComments":[]}